<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>骑士安全</title>
  <subtitle>Standing on the shoulders of giants.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://harmansecurity.cn/"/>
  <updated>2017-02-10T09:10:30.869Z</updated>
  <id>http://harmansecurity.cn/</id>
  
  <author>
    <name>如梦星影坠</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Http抓包与调试(Fiddler)</title>
    <link href="http://harmansecurity.cn/2017/02/09/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95(Fiddler)/"/>
    <id>http://harmansecurity.cn/2017/02/09/Http抓包与调试(Fiddler)/</id>
    <published>2017-02-09T13:19:07.000Z</published>
    <updated>2017-02-10T09:10:30.869Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、什么是Fiddler？"><a href="#一、什么是Fiddler？" class="headerlink" title="一、什么是Fiddler？"></a>一、什么是Fiddler？</h4><p>　 　1.Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一。它能够记录客户端和服务器之间的所有HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。既然是代理，也就是说：客户端的所有请求都要先经过Fiddler，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过Fiddler然后发送到客户端，基于这个原因，Fiddler支持所有可以设置http代理为 127.0.0.1:8888 的浏览器和应用程序。<br>使用了Fiddler之后，web客户端和服务器的请求如下所示:</p>
<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%291.png" alt=""><br></div><br>　 　2.Fiddler 作为系统代理，当启用Fiddler时，IE的PROXY设定会变成 127.0.0.1:8888，因此如果你的浏览器在开启fiddler之后没有设置相应的代理，则fiddler是无法捕获到HTTP请求的。如下是启动Fiddler之后，IE浏览器的代理设置：<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%292.png" alt=""><br></div><br><a id="more"></a><br>　 　3.以Firefox为例，默认情况下，firefox是没有启用代理的（如果你安装了proxy等代理工具或插件，是另外一种情况），在firefox中配置http代理的步骤如下：工具-&gt;选项-&gt;高级-&gt;网络-&gt;设置。并配置相应的代理如下就可以使用Fiddler抓取Firefox的HTTP请求了。<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%293.png" alt=""><br></div>

<hr>
<h4 id="二、Fiddler使用界面简介"><a href="#二、Fiddler使用界面简介" class="headerlink" title="二、Fiddler使用界面简介"></a>二、Fiddler使用界面简介</h4><p>Fiddler主界面的布局如下：</p>
<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%294.png" alt=""><br></div>

<h6 id="主界面中主要包括四个常用的块："><a href="#主界面中主要包括四个常用的块：" class="headerlink" title="主界面中主要包括四个常用的块："></a>主界面中主要包括四个常用的块：</h6><ul>
<li>Fiddler的菜单栏，上图绿色部分。包括捕获http请求，停止捕获请求，保存http请求，载入本地session、设置捕获规则等功能。</li>
<li>Fiddler的工具栏,上图红色部分。<code>Replay：回放按钮;</code> <code>X：清空监控面板；</code> <code>Go：调试Debug；</code> <code>Stream：模式切换；（流模式与缓冲模式）</code> <code>Decode：解压请求；</code> <code>Keep session：保持会话；</code> <code>Any Process：过滤请求；（如只查看Chrome的请求）</code> <code>Find：查找；</code> <code>Save：保存会话；</code> <code>保存截图；</code> <code>计时器；</code> <code>Browser：快速启动浏览器；</code> <code>TextWizard：编码/解码；（非常常用）</code> <code>Tearoff：分离面板；</code> <code>MSDN Search：MSDN搜索；</code></li>
<li>web Session面板，上图黄色区域，主要是Fiddler抓取到的每条http请求（每一条称为一个session）,主要包含了请求的url，协议，状态码，body等信息，详细的字段含义如下图所示：<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%295.png" alt=""><br></div></li>
<li>详情和数据统计面板。针对每条http请求的具体统计（例如发送/接受字节数，发送/接收时间，还有粗略统计世界各地访问该服务器所花费的时间）和数据包分析。如inspector面板下，提供headers、textview、hexview,Raw等多种方式查看单条http请求的请求报文的信息：<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%296.png" alt=""><br></div><br>而composer面板下，则可以模拟向相应的服务器发送数据的过程（这就是灌水机器人的基本原理,也可以是部分http flood的一种方式）。<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%297.png" alt=""><br></div><br>也可以粘贴一次请求的raw http headers,达到模拟请求的目的：<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%298.png" alt=""><br></div>

</li>
</ul>
<hr>
<h4 id="三、Fiddler内置命令"><a href="#三、Fiddler内置命令" class="headerlink" title="三、Fiddler内置命令"></a>三、Fiddler内置命令</h4><p>　 　为了更加方便的管理所有的session, Fiddler提供了一系列内置的函数用于筛选和操作这些session.输入命令的位置在websession管理面板的下方（通过快捷键alt+q可以focus到命令行）.<br>Fiddler内置的命令有如下几种：</p>
<h6 id="1-select命令。"><a href="#1-select命令。" class="headerlink" title="1. select命令。"></a>1. select命令。</h6><p>选择所有相应类型（指content-type）为指定类型的HTTP请求，如选择图片，使用命令<code>select image</code>.而<code>select css</code>则可以选择所有相应类型为css的请求，<code>select html</code>则选择所有响应为HTML的请求（怎么样，是不是跟SQL语句很像？）。如图是执行<code>select image</code>之后的结果：</p>
<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%299.png" alt=""><br></div>

<h6 id="2-allbut命令。"><a href="#2-allbut命令。" class="headerlink" title="2. allbut命令。"></a>2. allbut命令。</h6><p>allbut命令用于选择所有响应类型不是给定类型的HTTP请求。如allbut image用于选择所有相应类型不是图片的session(HTTP请求)，该命令还有一个别名keeponly.需要注意的是，keeponly和allbut命令是将不是该类型的session删除，留下的都是该类型的响应。因此，如果你执行allbut xxxx（不存在的类型），实际上类似与执行cls命令（删除所有的session, ctrl+x快捷键也是这个作用）</p>
<h6 id="3-text命令"><a href="#3-text命令" class="headerlink" title="3. ?text命令"></a>3. ?text命令</h6><p>选择所有 URL 匹配问号后的字符的全部 session</p>
<h6 id="4-gt-size-和-lt-size命令"><a href="#4-gt-size-和-lt-size命令" class="headerlink" title="4. &gt;size 和 &lt;size命令"></a>4. &gt;size 和 &lt;size命令</h6><p>选择响应大小大于某个大小（单位是b）或者小于某个大小的所有HTTP请求</p>
<h6 id="5-status命令"><a href="#5-status命令" class="headerlink" title="5. =status命令"></a>5. =status命令</h6><p>选择响应状态等于给定状态的所有HTTP请求。<br><br>例如，选择所有状态为200的HTTP请求：=200<br></p>
<h6 id="6-host命令"><a href="#6-host命令" class="headerlink" title="6. @host命令"></a>6. @host命令</h6><p>选择包含指定 HOST 的全部 HTTP请求。例如：@csdn.net<br><br>选择所有host包含csdn.net的请求<br></p>
<h6 id="7-Bpafter，-Bps-bpv-bpm-bpu"><a href="#7-Bpafter，-Bps-bpv-bpm-bpu" class="headerlink" title="7. Bpafter， Bps, bpv, bpm, bpu"></a>7. Bpafter， Bps, bpv, bpm, bpu</h6><p>这几个命令主要用于批量设置断点：<br><br>Bpafter xxx: 中断 URL 包含指定字符的全部 session 响应<br><br>Bps xxx: 中断 HTTP 响应状态为指定字符的全部 session 响应。<br><br>Bpv xxx: 中断指定请求方式的全部 session 响应<br><br>Bpm xxx: 中断指定请求方式的全部 session 响应。等同于bpv xxx<br><br>Bpu xxx:与bpafter类似。<br><br>当这些命令没有加参数时，会清空所有设置了断点的HTTP请求。<br></p>
<hr>
<h4 id="四、Fiddler抓包分析"><a href="#四、Fiddler抓包分析" class="headerlink" title="四、Fiddler抓包分析"></a>四、Fiddler抓包分析</h4><p>　 　抓包是Fiddler的最基本的应用，在Fiddler的web session界面捕获到HTTP请求。各字段的详细说明已经解释过，这里不再说明。需要注意的是#号列中的图标，每种图标代表不同的相应类型，具体的类型包括：</p>
<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%2910.png" alt=""><br></div><br>另外，注意请求的host字段。可以看到有来自多个www.csdn.net的子域名的响应，说明在大型网站的架构中，大多需要多个子域名，这些子域名可能是单独用于缓存静态资源的，也可能是专门负责媒体资源的，或者是专门负责数据统计的（如pingback）。<br><em>右键单击其中的一条请求。可以选择的操作有：save(保存请求的报文信息，可以是请求报文，可以是响应报文)。</em><br><em>如果想要重新发送某些请求，可以选中这些请求，然后点击工具栏中的reply.就可以重新发送选中的这些请求。</em><br><strong>左键点击单条HTTP请求，可以在右侧的tab面板中看到如下信息：</strong><br><br><strong>(1). Statistic。</strong><br>关于HTTP请求的性能和其他数据分析，使用Statistics页签，用户可以通过选择多个会话来得来这几个会话的总的信息统计，比如多个请求和传输的字节数。选择第一个请求和最后一个请求，可获得整个页面加载所消耗的总体时间。从条形图表中还可以分别出哪些请求耗时最多，从而对页面的访问进行访问速度优化。<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%2911.png" alt=""><br></div>

<p><strong>(2). Inspectors。</strong><br>分为上下两个部分，上半部分是请求头部分，下半部分是响应头部分。对于每一部分，提供了多种不同格式查看每个请求和响应的内容。JPG 格式使用 ImageView 就可以看到图片，HTML/JS/CSS 使用 TextView可以看到响应的内容。Raw标签可以查看原始的符合HTTP标准的请求和响应头。Auth则可以查看授权Proxy-Authorization和Authorization的相关信息。Cookies标签可以看到请求的cookie和响应的set-cookie头信息。</p>
<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%2912.png" alt=""><br></div>

<ul>
<li>Http Request Header<h6 id="Cache-头域"><a href="#Cache-头域" class="headerlink" title="Cache 头域"></a>Cache 头域</h6>If-Modified-Since作用：把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端 就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMT<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%2913.png" alt=""><br></div><br>If-None-Match作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用 本地缓存文件。否则将返回200状态和新的资源和Etag.  使用这样的机制将提高网站的性能例如: If-None-Match: “03f2b33c0bfcc1:0”<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%2914.png" alt=""><br></div><br>Pragma作用：防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样。Pargma只有一个用法，例如：Pragma: no-cache.<br>注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control。Cache-Control作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下</li>
</ul>
<p>Cache-Control:Public   可以被任何缓存所缓存（）</p>
<p>Cache-Control:Private     内容只缓存到私有缓存中</p>
<p>Cache-Control:no-cache  所有内容都不会被缓存</p>
<h4 id="Client-头域"><a href="#Client-头域" class="headerlink" title="Client 头域"></a>Client 头域</h4><p> Accept: text/html代表浏览器可以接受服务器回发的类型为 text/html  也就是我们常说的html文档,如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)。</p>
<p> Accept: <em>/</em>  代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)。</p>
<p> Accept-Encoding：作用：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。</p>
<p>Accept-Language作用： 浏览器申明自己接收的语言。 </p>
<p>User-Agent作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览 器和其它属性告诉服务器。</p>
<p>Accept-Charset作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案）</p>
<h6 id="Cookie-Login-头域"><a href="#Cookie-Login-头域" class="headerlink" title="Cookie/Login 头域"></a>Cookie/Login 头域</h6><p>Cookie:作用：最重要的header, 将cookie的值发送给HTTP 服务器</p>
<h6 id="Entity头域"><a href="#Entity头域" class="headerlink" title="Entity头域"></a>Entity头域</h6><p>Content-Length作用：发送给HTTP服务器数据的长度。</p>
<p>Content-Type: application/x-www-form-urlencoded</p>
<h6 id="Miscellaneous-头域"><a href="#Miscellaneous-头域" class="headerlink" title="Miscellaneous 头域"></a>Miscellaneous 头域</h6><p>Referer:作用：提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。</p>
<h6 id="Transport-头域"><a href="#Transport-头域" class="headerlink" title="Transport 头域"></a>Transport 头域</h6><p>Connection</p>
<p>例如：Connection: keep-alive   当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接</p>
<p>例如：Connection: close  代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。</p>
<p>Host（发送请求时，该报头域是必需的）作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。例如: 我们在浏览器中输入：<code>http://www.guet.edu.cn/index.html</code>。浏览器发送的请求消息中，就会包含Host请求报头域，如下：<code>Host：http://www.guet.edu.cn</code>此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号</p>
<p><strong>(3). AutoResponder。</strong><br>Fiddler比较重要且比较强大的功能之一。可用于拦截某一请求，并重定向到本地的资源，或者使用Fiddler的内置响应。可用于调试服务器端代码而无需修改服务器端的代码和配置，因为拦截和重定向后，实际上访问的是本地的文件或者得到的是Fiddler的内置响应。当勾选EnableRules并设置相应的规则后（本例中的规则是将<code>http://www.cnblogs.com/HYanqing/p/5294968.html</code>的请求拦截到本地的文件）,如下图所示:</p>
<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%2915.png" alt=""><br></div><br>然后在浏览器中访问<code>http://www.cnblogs.com/HYanqing/p/5294968.html</code>，得到的结果实际为本地的网页。说明请求已经成功被拦截到本地.当然也可以使用Fiddler的内置响应。因此如果要调试服务器的某个脚本文件，可以将该脚本拦截到本地，在本地修改完脚本之后，再修改服务器端的内容，这可以保证，尽量在真实的环境下去调试，从而最大限度的减少bug发生的可能性。<br><br>不仅是单个url，Fiddler支持多种url匹配的方式：<br><br>I. 字符匹配<br><br>如 example可以匹配 <code>http://www.example.com</code>和<code>http://example.com.cn</code><br><br>II. 完全匹配<br><br>以EXACT开头表示完全匹配，如上边的例子<br><br>EXACT:<code>http://www.cnblogs.com/HYanqing/p/5294968.html</code><br><br>III. 正则表达式匹配<br><br>以regex: 开头，使用正则表达式来匹配URL.如：<code>regex:(?insx).*\.(css|js|php)$</code>  表示匹配所有以css,js,php结尾的请求url<br><br><strong>(4). Composer。（模拟请求）</strong><br>老版本的fiddler中叫request-builder.顾名思义，可以构建相应的请求，有两种常用的方式构建请求:<br><br>(1)Parsed 输入请求的url之后executed即可，也可以修改相应的头信息（如添加常用的accept, host, referrer, cookie，cache-control等头部）后execute.这个功能的常见应用是：“刷票”（不是火车票！！），如刷新页面的访问量。<br><br>(2)Raw。使用HTTP头部信息构建http请求。与上类似。不多叙述<br><br><strong>(5). Filter。</strong><br>Fiddler另一个比较强大的功能。Fiddler提供了多维度的过滤规则，足以满足日常开发调试的需求。<br><br>过滤规则有：<br><br>a. host和zone过滤。可以过滤只显示intranet或则internet的HTTP请求。也可以选择特定域名的HTTP请求。<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%2916.png" alt=""><br></div><br>b. client process:可以捕获指定进程的请求。这对于调试单个应用的请求很有帮助。<br><br><strong>五、Fiddler中设置断点修改Request</strong><br>　 　Fiddler最强大的功能莫过于设置断点了，设置好断点后，你可以修改httpRequest的任何信息包括host,cookie或者表单中的数据。设置断点有两种方法：<br><br>第一种：打开Fiddler 点击Rules-&gt; Automatic Breakpoint  -&gt;Before Requests(这种方法会中断所有的会话)<br><br>如何消除命令呢？  点击Rules-&gt; Automatic Breakpoint  -&gt;Disabled<br><br>第二种:  在命令行中输入命令:  bpu www.baidu.com   (这种方法只会中断www.baidu.com)<br><br>如何消除命令呢？  在命令行中输入命令 bpu<br><br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%2917.jpg" alt=""><br></div><br>看个实例，模拟麦子学院的登录，在火狐中打开麦子学院的登录页面，输入错误的用户名和密码，用Fiddler中断会话，修改成正确的用户名密码。这样就能成功登录：<br><br>1. 用火狐打开麦子学院的登录界面  <code>http://www.maiziedu.com/</code><br><br>2. 打开Fiddler,  在命令行中输入bpu <code>http://www.maiziedu.com/</code><br><br>3. 输入错误的用户名和密码，点击登录<br><br>4. Fiddler 能中断这次会话，选择被中断的会话，点击Inspectors tab下的WebForms tab 修改用户名密码，然后点击Run to Completion 如下图所示:<br><br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%2918.png" alt=""><br></div><br>5. 结果是正确地登录了麦子学院<br><br><strong>六、Fiddler中设置断点修改Response</strong><br>当然Fiddler中也能修改Response：<br><br>第一种：打开Fiddler 点击Rules-&gt; Automatic Breakpoint  -&gt;After Response  (这种方法会中断所有的会话)<br><br>如何消除命令呢？  点击Rules-&gt; Automatic Breakpoint  -&gt;Disabled<br><br>第二种:  在命令行中输入命令:  bpuafter www.baidu.com   (这种方法只会中断www.baidu.com)<br><br>如何消除命令呢？  在命令行中输入命令 bpuafter<br><br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%2919.jpg" alt=""><br></div>

<hr>
<h4 id="七、Watcher-安全扫描工具，第三方扩展"><a href="#七、Watcher-安全扫描工具，第三方扩展" class="headerlink" title="七、Watcher(安全扫描工具，第三方扩展)"></a>七、Watcher(安全扫描工具，第三方扩展)</h4><p>　 　Watcher是一个实时的，被动分析基于HTTP协议的Web应用程序的安全工具(Fiddler插件)。所谓被动分析就是指它不会对现有系统产生任何破坏。Watcher可以被安全的用于分布式网络，共享式网络和专用宿主网络。Watcher能够自动检查这些问题：cookie设置、SSL配置、信息泄露等。另外，Watcher是一个非常好的HTTP协议调试工具，不过，它的HTTP调试功能是以Fiddler插件方式工作的。总之，Watcher是一个很好的渗透测试工具，有助于渗透测试人员的渗透测试工作。</p>
<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%2920.png" alt=""><br></div>

<hr>
<h4 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h4><ul>
<li><code>http://www.cnblogs.com/HYanqing/p/5294968.html</code></li>
<li><code>http://blog.csdn.net/ohmygirl/article/details/17846199</code></li>
<li><code>http://blog.csdn.net/ohmygirl/article/details/17849983</code></li>
<li><code>http://www.imooc.com/course/note/id/37?sort=last&amp;page=1</code></li>
<li><code>http://www.freebuf.com/sectool/6770.html</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、什么是Fiddler？&quot;&gt;&lt;a href=&quot;#一、什么是Fiddler？&quot; class=&quot;headerlink&quot; title=&quot;一、什么是Fiddler？&quot;&gt;&lt;/a&gt;一、什么是Fiddler？&lt;/h4&gt;&lt;p&gt;　 　1.Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一。它能够记录客户端和服务器之间的所有HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。既然是代理，也就是说：客户端的所有请求都要先经过Fiddler，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过Fiddler然后发送到客户端，基于这个原因，Fiddler支持所有可以设置http代理为 127.0.0.1:8888 的浏览器和应用程序。&lt;br&gt;使用了Fiddler之后，web客户端和服务器的请求如下所示:&lt;/p&gt;
&lt;div align=center&gt;&lt;br&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%291.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;　 　2.Fiddler 作为系统代理，当启用Fiddler时，IE的PROXY设定会变成 127.0.0.1:8888，因此如果你的浏览器在开启fiddler之后没有设置相应的代理，则fiddler是无法捕获到HTTP请求的。如下是启动Fiddler之后，IE浏览器的代理设置：&lt;br&gt;&lt;div align=center&gt;&lt;br&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95%28Fiddler%292.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Http抓包与调试" scheme="http://harmansecurity.cn/tags/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
      <category term="Fiddler" scheme="http://harmansecurity.cn/tags/Fiddler/"/>
    
      <category term="浏览器代理" scheme="http://harmansecurity.cn/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%A3%E7%90%86/"/>
    
      <category term="拦截请求或响应" scheme="http://harmansecurity.cn/tags/%E6%8B%A6%E6%88%AA%E8%AF%B7%E6%B1%82%E6%88%96%E5%93%8D%E5%BA%94/"/>
    
      <category term="抓包和重放" scheme="http://harmansecurity.cn/tags/%E6%8A%93%E5%8C%85%E5%92%8C%E9%87%8D%E6%94%BE/"/>
    
  </entry>
  
  <entry>
    <title>Http抓包与调试(Firefox插件)</title>
    <link href="http://harmansecurity.cn/2017/01/19/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95(Firefox%E6%8F%92%E4%BB%B6)/"/>
    <id>http://harmansecurity.cn/2017/01/19/Http抓包与调试(Firefox插件)/</id>
    <published>2017-01-19T08:22:55.000Z</published>
    <updated>2017-01-19T12:45:56.850Z</updated>
    
    <content type="html"><![CDATA[<p>　 　这边主要介绍火狐的几款插件工具分别是Firebug、TamperData、LiveHttpHeaders、Hackbar和ModifyHeaders，它们可以用来测试和发掘Web应用程序中的跨站漏洞。</p>
<hr>
<h4 id="1-Firebug-抓包与各种调试"><a href="#1-Firebug-抓包与各种调试" class="headerlink" title="1.Firebug(抓包与各种调试)"></a>1.Firebug(抓包与各种调试)</h4><p>　 　Firebug是Firefox浏览器的一个扩展插件，可以动态修改html代码、探索DOM结构、监视网络请求和响应、调试和监测任何页面的CSS、HTML和JavaScript等等。</p>
<h5 id="1-安装城成功后按F12启动Firebug"><a href="#1-安装城成功后按F12启动Firebug" class="headerlink" title="1)安装城成功后按F12启动Firebug"></a>1)安装城成功后按F12启动Firebug</h5><p>　 　打开Firebug后，看到六个标签按钮分别是（控制台、HTML查看器、CSS查看器、脚本调试器、DOM查看器、网络状况监视器）。</p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%951.png" alt=""></p>
<h5 id="2-控制台"><a href="#2-控制台" class="headerlink" title="2)控制台"></a>2)控制台</h5><p>　 　控制台能够显示当前页面中的JavaScript错误以及警告，并提示出错的文件和行号，使用控制台可以测试一段代码或者函数的执行时间。启用控制台，在窗口的底部能看到命令行输入，以“&gt;”开头，在这里输入JavaScript代码后按Enter键即可执行。<br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%952.png" alt=""><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%953.png" alt=""><br><a id="more"></a></p>
<h5 id="3-动态修改HTML元素"><a href="#3-动态修改HTML元素" class="headerlink" title="3)动态修改HTML元素"></a>3)动态修改HTML元素</h5><p>　 　Frebug可以显示脚本输出的最终源代码，而html查看器只能显示页面本身的源代码。单击查看页面元素按钮，当光标停留在某个元素上时，浏览器会高亮显示对应元素，可以对页面文本节点进行修改，其修改结果马上回反映到浏览器窗口。<br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%954.png" alt=""></p>
<h5 id="4-查看网络状况"><a href="#4-查看网络状况" class="headerlink" title="4)查看网络状况"></a>4)查看网络状况</h5><p>　 　将Frebug的当前标签切换到“网络”，该标签用来监控网络流量。如果通过XMLHttpRequest对象向服务器端发出一个请求，Firebug会记录该请求的GET或者POST内容，以及回应的头信息和内容。Firebug也能将页面中的CSS、JavaScript以及网页中引用的图片载入所消耗的时间以矩状图显示出来，通过右键就可以复制文件地址、HTTP请求头的信息和响应头信息等等。以登录麦子学院网站为例，惊奇的发现它的账号和密码都是明文传输。:)<br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%955.png" alt=""><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%956.png" alt=""><br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%957.png" alt=""></p>
<h5 id="5-DOM查看器"><a href="#5-DOM查看器" class="headerlink" title="5)DOM查看器"></a>5)DOM查看器</h5><p>　 　DOM包含了大量的对象以及函数，事件，通过使用Firebug可以检查当前打开程序的各个部分。<br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%958.png" alt=""></p>
<hr>
<h4 id="2-Tamper-Data-拦截修改"><a href="#2-Tamper-Data-拦截修改" class="headerlink" title="2.Tamper Data(拦截修改)"></a>2.Tamper Data(拦截修改)</h4><p>　 　当测试Web应用程序的安全性的时候，经常会需要对HTTP流量进行分析和动态的修改，这时就需要用到这款工具。安装成功后，在Firefox的工具栏打开，随后在浏览网页的时候发出的每一个Http请求及其对应的响应都会被Tamper Data记录下来。</p>
<h5 id="1-Tamper-Data界面主要是由三部分组成"><a href="#1-Tamper-Data界面主要是由三部分组成" class="headerlink" title="1)Tamper Data界面主要是由三部分组成"></a>1)Tamper Data界面主要是由三部分组成</h5><ul>
<li>第一部分：（上方）HTTP请求概要信息</li>
<li>第二部分：（左下方）显示出对应的HTTP请求的头部信息</li>
<li>第三部分：（右下方）显示出对应的HTTP响应</li>
</ul>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%959.png" alt=""></p>
<h5 id="2-查看细节、源码信息以及网页打开时间"><a href="#2-查看细节、源码信息以及网页打开时间" class="headerlink" title="2)查看细节、源码信息以及网页打开时间"></a>2)查看细节、源码信息以及网页打开时间</h5><p>　 　在主窗口的第一部分单击鼠标右键，此时可以查看细节、源代码信息，单击【GraphAll】按钮，会以图形的方式直观地显示每个页面元素及其打开它们所花的时间。</p>
<h5 id="3-Http请求截取"><a href="#3-Http请求截取" class="headerlink" title="3)Http请求截取"></a>3)Http请求截取</h5><p>　 　在Tamper Data中选择StartTamper菜单项，便开启了对HTTP请求的截取，此时浏览器发出的每一个请求，TamperData都会截取。在开启该功能后单击网页上的任意超链接，便可以看到浏览器弹出一个对话框，然后单击【Tamper】按钮，会弹出一个“TamperPopup”窗口，这个窗口显示了HTTP请求的各种头信息，可以在此随意修改或者添加其他合法的HTTP请求头部字段或POST参数。</p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%9510.png" alt=""></p>
<hr>
<h4 id="3-Live-HTTP-Headers-重放功能"><a href="#3-Live-HTTP-Headers-重放功能" class="headerlink" title="3.Live HTTP Headers(重放功能)"></a>3.Live HTTP Headers(重放功能)</h4><p>　 　Live HTTP Headers是一款用来分析HTTP流量的Firefox扩展插件，直接在火狐浏览器里面搜索即可安装。</p>
<ul>
<li>窗口底部有一个“capture”复选框，选中后可以使LIVE HTTP Headers 停止向下滚动，以便对已经产生的通信流量进行分析<br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%9511.png" alt=""></li>
<li>在主窗口选择其中一段请求，然后单击窗口底部的“Replay”按钮会弹出窗口，可对请求进行各种修改，修改后再次单击“replay”可重放请求。<br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%9512.png" alt=""></li>
</ul>
<hr>
<h4 id="4-Hackbar-编码解码-POST提交"><a href="#4-Hackbar-编码解码-POST提交" class="headerlink" title="4.Hackbar(编码解码/POST提交)"></a>4.Hackbar(编码解码/POST提交)</h4><p>　 　HackBar是firefox浏览器上的一个插件,安装方法跟之前的几个插件一样。HackBar其实是一个小工具包，包含一些黑客常用的工具。比如SQL injection,XSS,加密等!功能很多可以下载下来去尝试一下。</p>
<ul>
<li>load url是将地址栏中的网络复制到hackbar中</li>
<li>在sql注入中有一个联合查询，比如字段数是11要是手工的话我们打出union select 1,2,3,4,5,6,7,8,9,10,11这样感觉有点麻烦。通过hackbar的sql选项里面的unionselectstatement在其中输入字段数，hackbar会自动的帮助我们输入那一大串文字。</li>
<li>我们可以对url进行各种编码操作，我们可以在endoding选项下进行url、16进制、base64进行编码解码，可以在xss选项下进行html实体编码，在sql选项下进行空格编码。</li>
<li>在encryption选项中我们可以进行md5,sha1，sha256，rot13加密，单击里面的选项，在弹出的对话框中输入要加密的数据。<br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%9513.png" alt=""></li>
</ul>
<hr>
<h4 id="5-Modify-Headers-修改头部"><a href="#5-Modify-Headers-修改头部" class="headerlink" title="5.Modify Headers(修改头部)"></a>5.Modify Headers(修改头部)</h4><p>　 　这个插件的主要作用是对Firefox的HTTP request headers进行添加、修改和过滤等操作。当我们访问网站的时候，某些网站服务器会对访问网站的浏览器Header信息进行判断，然后决定用什么方式把网站内容呈现给浏览器。服务器也会根据浏览器的header中包含的其他信息（譬如浏览器所在的IP地址）判断是否要讲某一特定的信息呈现给浏览器。</p>
<ul>
<li>选择Add，右边的HeaderName,HeaderValue和DescriptiveComment等字段都会变得可编辑。由于我们要模拟不同地域的IP对网站进行访问(伪造IP地址)，所以HeaderName字段中，我们填入<code>X-Forwarded-For</code>。Header value中，填入你要模拟的地域IP地址，然后在Descriptive comment中填上备注就好。</li>
<li>User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。修改User-Agent来模拟用iPhone访问网站。<br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%9514.png" alt=""></li>
<li>伪造IP地址和修改了User Agent，看一下访问百度的请求头信息发生了什么变化。<br><img src="http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%9515.png" alt=""></li>
</ul>
<hr>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　 　这边主要介绍火狐的几款插件工具分别是Firebug、TamperData、LiveHttpHeaders、Hackbar和ModifyHeaders，它们可以用来测试和发掘Web应用程序中的跨站漏洞。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;1-Firebug-抓包与各种调试&quot;&gt;&lt;a href=&quot;#1-Firebug-抓包与各种调试&quot; class=&quot;headerlink&quot; title=&quot;1.Firebug(抓包与各种调试)&quot;&gt;&lt;/a&gt;1.Firebug(抓包与各种调试)&lt;/h4&gt;&lt;p&gt;　 　Firebug是Firefox浏览器的一个扩展插件，可以动态修改html代码、探索DOM结构、监视网络请求和响应、调试和监测任何页面的CSS、HTML和JavaScript等等。&lt;/p&gt;
&lt;h5 id=&quot;1-安装城成功后按F12启动Firebug&quot;&gt;&lt;a href=&quot;#1-安装城成功后按F12启动Firebug&quot; class=&quot;headerlink&quot; title=&quot;1)安装城成功后按F12启动Firebug&quot;&gt;&lt;/a&gt;1)安装城成功后按F12启动Firebug&lt;/h5&gt;&lt;p&gt;　 　打开Firebug后，看到六个标签按钮分别是（控制台、HTML查看器、CSS查看器、脚本调试器、DOM查看器、网络状况监视器）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%951.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h5 id=&quot;2-控制台&quot;&gt;&lt;a href=&quot;#2-控制台&quot; class=&quot;headerlink&quot; title=&quot;2)控制台&quot;&gt;&lt;/a&gt;2)控制台&lt;/h5&gt;&lt;p&gt;　 　控制台能够显示当前页面中的JavaScript错误以及警告，并提示出错的文件和行号，使用控制台可以测试一段代码或者函数的执行时间。启用控制台，在窗口的底部能看到命令行输入，以“&amp;gt;”开头，在这里输入JavaScript代码后按Enter键即可执行。&lt;br&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%952.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%953.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="Http抓包与调试" scheme="http://harmansecurity.cn/tags/Http%E6%8A%93%E5%8C%85%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    
      <category term="Firebug" scheme="http://harmansecurity.cn/tags/Firebug/"/>
    
      <category term="Tamper Data" scheme="http://harmansecurity.cn/tags/Tamper-Data/"/>
    
      <category term="LiveHttpHeaders" scheme="http://harmansecurity.cn/tags/LiveHttpHeaders/"/>
    
      <category term="Hackbar" scheme="http://harmansecurity.cn/tags/Hackbar/"/>
    
      <category term="Modify Headers" scheme="http://harmansecurity.cn/tags/Modify-Headers/"/>
    
  </entry>
  
  <entry>
    <title>PBC库的常用函数解释</title>
    <link href="http://harmansecurity.cn/2017/01/18/PBC%E5%BA%93%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%A7%A3%E9%87%8A/"/>
    <id>http://harmansecurity.cn/2017/01/18/PBC库的常用函数解释/</id>
    <published>2017-01-18T10:59:57.000Z</published>
    <updated>2017-01-18T11:01:33.657Z</updated>
    
    <content type="html"><![CDATA[<p>　 　PBC库使用G1、G2和GT分别表示双线性映射:<code>e:G1xG2-&gt;GT</code>中的G1、G2和GT，他们的阶都为r。Zr表示模r的整数环。配对运算输入两个元素，一个元素来自群G1，另一个元素来自群G2，输出结果是GT中的一个元素。G1和G2也可以是同一个群，即是一个对称配对，这种情况下它们的元素可以相互混淆使用。</p>
<hr>
<h4 id="1-配对的初始化方式"><a href="#1-配对的初始化方式" class="headerlink" title="1.配对的初始化方式"></a>1.配对的初始化方式</h4><h5 id="1-以标准的方式初始化配对"><a href="#1-以标准的方式初始化配对" class="headerlink" title="1) 以标准的方式初始化配对"></a>1) 以标准的方式初始化配对</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pairing_t</span> pairing;<span class="comment">//声明一个配对类型的变量pairing</span></div><div class="line">pairing_init_inp_str(pairing,<span class="built_in">stdin</span>);<span class="comment">//参数stdin表示配对的输入参数方式为标准输入</span></div></pre></td></tr></table></figure>
<h5 id="2-指定类型的方式初始化配对"><a href="#2-指定类型的方式初始化配对" class="headerlink" title="2) 指定类型的方式初始化配对"></a>2) 指定类型的方式初始化配对</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">a_param_input(pairing);<span class="comment">//将配对变量pairing初始化为类型A的配对</span></div><div class="line">d_param_input(pairing);<span class="comment">//将配对变量pairing初始化为类型D的配对</span></div><div class="line">f_param_input(pairing);<span class="comment">//将配对变量pairing初始化为类型F的配对</span></div><div class="line">pairing_clear(pairing);<span class="comment">//调用该函数释放pairing占用的资源</span></div></pre></td></tr></table></figure>
<hr>
<h4 id="2-元素的初始化"><a href="#2-元素的初始化" class="headerlink" title="2.元素的初始化"></a>2.元素的初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_init</span><span class="params">(<span class="keyword">element_t</span> e,field_ptr f)</span></span>;<span class="comment">//将元素变量e初始化为代数结构f中的元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_init_G1</span><span class="params">(<span class="keyword">element_t</span> e,<span class="keyword">pairing_t</span> pairing)</span></span>;<span class="comment">//将元素变量e初始化为群G1中的元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_init_G2</span><span class="params">(<span class="keyword">element_t</span> e,<span class="keyword">pairing_t</span> pairing)</span></span>;<span class="comment">//将元素变量e初始化为群G2中的元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_init_GT</span><span class="params">(<span class="keyword">element_t</span> e,<span class="keyword">pairing_t</span> pairing)</span></span>;<span class="comment">//将元素变量e初始化为群GT中的元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_init_Zr</span><span class="params">(<span class="keyword">element_t</span> e,<span class="keyword">pairing_t</span> pairing)</span></span>;<span class="comment">//将元素变量e初始化为群Zr中的元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_init_same_as</span><span class="params">(<span class="keyword">element_t</span> e,<span class="keyword">element_t</span> e2)</span></span>;<span class="comment">//将元素变量e初始化为元素变量e2所在的代数结构中的元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_clear</span><span class="params">(<span class="keyword">element_t</span> e)</span></span>;<span class="comment">//清楚元素变量e并释放其所占用的资源</span></div></pre></td></tr></table></figure>
<hr>
<a id="more"></a>
<h4 id="3-运算函数"><a href="#3-运算函数" class="headerlink" title="3.运算函数"></a>3.运算函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_add</span><span class="params">(<span class="keyword">element_t</span> n,<span class="keyword">element_t</span> a,<span class="keyword">element_t</span> b)</span></span>;<span class="comment">//输入a和b，输出n=a+b</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_sub</span><span class="params">(<span class="keyword">element_t</span> n,<span class="keyword">element_t</span> a,<span class="keyword">element_t</span> b)</span></span>;<span class="comment">//输入a和b，输出n=a-b</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_mul</span><span class="params">(<span class="keyword">element_t</span> n,<span class="keyword">element_t</span> a,<span class="keyword">element_t</span> b)</span></span>;<span class="comment">//输入a和b，输出n=axb</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_mul_si</span><span class="params">(<span class="keyword">element_t</span> n,<span class="keyword">element_t</span> a,<span class="keyword">signed</span> <span class="keyword">long</span> <span class="keyword">int</span> z)</span></span>;<span class="comment">//输入a和z，输出n=axz,z是一个长整型数据</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_mul_zn</span><span class="params">(<span class="keyword">element_t</span> n,<span class="keyword">element_t</span> a,<span class="keyword">element_t</span> z)</span></span>;<span class="comment">//输入a和z，输出n=axz,z是整数环中的一个元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_div</span><span class="params">(<span class="keyword">element_t</span> n,<span class="keyword">element_t</span> a,<span class="keyword">element_t</span> b)</span></span>;<span class="comment">//输入a和b，输出n=a/b</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_double</span><span class="params">(<span class="keyword">element_t</span> n,<span class="keyword">element_t</span> a)</span></span>;<span class="comment">//输入a，输出n=a+a</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_halve</span><span class="params">(<span class="keyword">element_t</span> n,<span class="keyword">element_t</span> a)</span></span>;<span class="comment">//输入a，输出n=a/2</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_square</span><span class="params">(<span class="keyword">element_t</span> n,<span class="keyword">element_t</span> a)</span></span>;<span class="comment">//输入a，输出n=a^2</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_neg</span><span class="params">(<span class="keyword">element_t</span> n,<span class="keyword">element_t</span> a)</span></span>;<span class="comment">//输入a，输出n=-a</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_invert</span><span class="params">(<span class="keyword">element_t</span> n,<span class="keyword">element_t</span> a)</span></span>;<span class="comment">//输入a，输出a的逆元n</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_pow_mpz</span><span class="params">(<span class="keyword">element_t</span> x,<span class="keyword">element_t</span> a,<span class="keyword">mpz_t</span> n)</span></span>;<span class="comment">//输入a和n，输出x=a^n</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_pow_zn</span><span class="params">(<span class="keyword">element_t</span> x,<span class="keyword">element_t</span> a,<span class="keyword">element_t</span> n)</span></span>;<span class="comment">//输入a和n，输出x=a^n，n是整数环中的元素</span></div><div class="line"><span class="comment">//输入a1,a2和n1,n2，输出x=a1^n1xa2^n2</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_pow2_mpz</span><span class="params">(<span class="keyword">element_t</span> x,<span class="keyword">element_t</span> a1,<span class="keyword">mpz_t</span> n1,<span class="keyword">element_t</span> a2,<span class="keyword">mpz_t</span> n2)</span></span>;</div><div class="line"><span class="comment">//输入a1,a2和n1,n2，输出x=a1^n1xa2^n2,n1,n2是整数环中的元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_pow2_zn</span><span class="params">(<span class="keyword">element_t</span> x,<span class="keyword">element_t</span> a1,<span class="keyword">element_t</span> n1,<span class="keyword">element_t</span> a2,<span class="keyword">element_t</span> n2)</span></span>;</div></pre></td></tr></table></figure>
<hr>
<h4 id="4-其它函数"><a href="#4-其它函数" class="headerlink" title="4.其它函数"></a>4.其它函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">element_length_in_bytes</span><span class="params">(<span class="keyword">element_t</span> e)</span></span>;<span class="comment">//获得元素变量e的字节数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_random</span><span class="params">(<span class="keyword">element_t</span> e)</span></span>;<span class="comment">//函数从这个代数结构中均匀随机选择一个元素并赋值给e</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">element_cmp</span><span class="params">(<span class="keyword">element_t</span> a,<span class="keyword">element_t</span> b)</span></span>;<span class="comment">//若变量a和b相等，则函数返回0否则返回1</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_to_mpz</span><span class="params">(<span class="keyword">mpz_t</span> z,<span class="keyword">element_t</span> e)</span></span>;<span class="comment">//将元素e转换为一个GMP整数并存储在mpz_t类型的变量z中</span></div><div class="line"><span class="comment">//PBC库中没有提供计算Hash值的函数，这里只是以获得的Hash值作为输入，从中截取一部分表示域中的某个元素</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">element_from_hash</span><span class="params">(<span class="keyword">element_t</span> e,<span class="keyword">void</span> * data,<span class="keyword">int</span> len)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">element_printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * format,...)</span></span>;<span class="comment">//格式化打印元素值</span></div></pre></td></tr></table></figure>
<hr>
<p><em>以上列举了PBC库中的一些常用函数及其代表的意思，如有特殊需求可查阅PBC官方文档。</em></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　 　PBC库使用G1、G2和GT分别表示双线性映射:&lt;code&gt;e:G1xG2-&amp;gt;GT&lt;/code&gt;中的G1、G2和GT，他们的阶都为r。Zr表示模r的整数环。配对运算输入两个元素，一个元素来自群G1，另一个元素来自群G2，输出结果是GT中的一个元素。G1和G2也可以是同一个群，即是一个对称配对，这种情况下它们的元素可以相互混淆使用。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;1-配对的初始化方式&quot;&gt;&lt;a href=&quot;#1-配对的初始化方式&quot; class=&quot;headerlink&quot; title=&quot;1.配对的初始化方式&quot;&gt;&lt;/a&gt;1.配对的初始化方式&lt;/h4&gt;&lt;h5 id=&quot;1-以标准的方式初始化配对&quot;&gt;&lt;a href=&quot;#1-以标准的方式初始化配对&quot; class=&quot;headerlink&quot; title=&quot;1) 以标准的方式初始化配对&quot;&gt;&lt;/a&gt;1) 以标准的方式初始化配对&lt;/h5&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;pairing_t&lt;/span&gt; pairing;&lt;span class=&quot;comment&quot;&gt;//声明一个配对类型的变量pairing&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;pairing_init_inp_str(pairing,&lt;span class=&quot;built_in&quot;&gt;stdin&lt;/span&gt;);&lt;span class=&quot;comment&quot;&gt;//参数stdin表示配对的输入参数方式为标准输入&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;2-指定类型的方式初始化配对&quot;&gt;&lt;a href=&quot;#2-指定类型的方式初始化配对&quot; class=&quot;headerlink&quot; title=&quot;2) 指定类型的方式初始化配对&quot;&gt;&lt;/a&gt;2) 指定类型的方式初始化配对&lt;/h5&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;a_param_input(pairing);&lt;span class=&quot;comment&quot;&gt;//将配对变量pairing初始化为类型A的配对&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;d_param_input(pairing);&lt;span class=&quot;comment&quot;&gt;//将配对变量pairing初始化为类型D的配对&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;f_param_input(pairing);&lt;span class=&quot;comment&quot;&gt;//将配对变量pairing初始化为类型F的配对&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;pairing_clear(pairing);&lt;span class=&quot;comment&quot;&gt;//调用该函数释放pairing占用的资源&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h4 id=&quot;2-元素的初始化&quot;&gt;&lt;a href=&quot;#2-元素的初始化&quot; class=&quot;headerlink&quot; title=&quot;2.元素的初始化&quot;&gt;&lt;/a&gt;2.元素的初始化&lt;/h4&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;element_init&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;element_t&lt;/span&gt; e,field_ptr f)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//将元素变量e初始化为代数结构f中的元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;element_init_G1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;element_t&lt;/span&gt; e,&lt;span class=&quot;keyword&quot;&gt;pairing_t&lt;/span&gt; pairing)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//将元素变量e初始化为群G1中的元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;element_init_G2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;element_t&lt;/span&gt; e,&lt;span class=&quot;keyword&quot;&gt;pairing_t&lt;/span&gt; pairing)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//将元素变量e初始化为群G2中的元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;element_init_GT&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;element_t&lt;/span&gt; e,&lt;span class=&quot;keyword&quot;&gt;pairing_t&lt;/span&gt; pairing)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//将元素变量e初始化为群GT中的元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;element_init_Zr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;element_t&lt;/span&gt; e,&lt;span class=&quot;keyword&quot;&gt;pairing_t&lt;/span&gt; pairing)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//将元素变量e初始化为群Zr中的元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;element_init_same_as&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;element_t&lt;/span&gt; e,&lt;span class=&quot;keyword&quot;&gt;element_t&lt;/span&gt; e2)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//将元素变量e初始化为元素变量e2所在的代数结构中的元素&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;element_clear&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;element_t&lt;/span&gt; e)&lt;/span&gt;&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//清楚元素变量e并释放其所占用的资源&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
    
      <category term="PBC" scheme="http://harmansecurity.cn/tags/PBC/"/>
    
      <category term="密码学" scheme="http://harmansecurity.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="双线性配对" scheme="http://harmansecurity.cn/tags/%E5%8F%8C%E7%BA%BF%E6%80%A7%E9%85%8D%E5%AF%B9/"/>
    
  </entry>
  
  <entry>
    <title>VC6.0插件安装</title>
    <link href="http://harmansecurity.cn/2017/01/17/VC6.0%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>http://harmansecurity.cn/2017/01/17/VC6.0插件安装/</id>
    <published>2017-01-17T06:49:04.000Z</published>
    <updated>2017-01-17T15:33:44.823Z</updated>
    
    <content type="html"><![CDATA[<p>　 　因为PBC源码库的一些函数不是很全，导致用VS写了几个程序只好放弃，而支持VC6.0的PBC库比较全，绕了一圈所以只好转战VC++6.0。VC++6.0是一款很老的工具，不是很人性化，对于我这个深度完美主义者肯定是不能接受的，想方设法使它更适合开发，所以安装了一些插件，使开发效率更高。</p>
<p>我主要安装的插件是:<br>1.Visual studio Boosteer;(源码窗口管理)</p>
<ul>
<li>下载地址:<code>http://pan.baidu.com/s/1pJAZApP</code>.</li>
<li>功能:方便查看源码，一页里面可以打开多个C文件。</li>
</ul>
<p>2.Visual assist Options;(强烈推荐)</p>
<ul>
<li>下载地址:<code>http://pan.baidu.com/s/1dDh7Mtb</code>.</li>
<li>功能:自动识别各种关键字，系统函数，成员变量，自动给出输入提示，自动更正大小写错误，自动标示错误等等。</li>
</ul>
<p>3.为了解决VC++6.0不能添加和打开文件的功能安装了FileTool。</p>
<ul>
<li>下载地址:<code>http://download.csdn.net/detail/ttfy1234/9696351</code>.</li>
<li>功能:VC6.0在添加和打开文件时经常会崩掉，这个插件就是为了解决这个问题。  </li>
</ul>
<p>4.VC6LineNumberAddin;</p>
<ul>
<li>下载地址:<code>http://pan.baidu.com/s/1dD8CfGd</code></li>
<li>功能:VC6.0不自带行号，不方便阅读查找，这个是行号插件。</li>
</ul>
<a id="more"></a>
<p>5.Comment Wizard;</p>
<ul>
<li>下载地址:<code>http://www.cppblog.com/fwxjj/</code>.</li>
<li>功能:Visual C++插件，提供了VC源代码注解标准化与自动化功能。在它的帮助下，您可快速创建标头文件信息注解，文件中模块注解， C++处理方式，以及Ｃ语言功能与历史校正功能注解等等。</li>
</ul>
<p>6.WndTabs+3.20 实现窗口tab效果。</p>
<ul>
<li>下载地址:<code>http://www.wndtabs.com/</code>.</li>
<li>功能:WndTabs主要是在编辑窗口中显示了所有已经打开的文件，在VC中能够更方便的操作这些文件，比如修改文件属性，copy文件路径、文件名等,与第一个VS Booster的功能相近。</li>
</ul>
<p>参考的资料:</p>
<ul>
<li><code>http://blog.csdn.net/cooljun618/article/details/6866798</code></li>
<li><code>http://bbs.csdn.net/topics/390776572</code></li>
</ul>
<p>　 　一个人性化的环境搭好了,下面就是导入项目，官网给的支持VC的PBC源码直接打开有点问题，这边我直接把调通好的源码放在GitHub上面，有需要的人可以去下载，地址是:<code>https://github.com/harmansecurity/PBC-0.4.7-vc6.0</code>.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　 　因为PBC源码库的一些函数不是很全，导致用VS写了几个程序只好放弃，而支持VC6.0的PBC库比较全，绕了一圈所以只好转战VC++6.0。VC++6.0是一款很老的工具，不是很人性化，对于我这个深度完美主义者肯定是不能接受的，想方设法使它更适合开发，所以安装了一些插件，使开发效率更高。&lt;/p&gt;
&lt;p&gt;我主要安装的插件是:&lt;br&gt;1.Visual studio Boosteer;(源码窗口管理)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载地址:&lt;code&gt;http://pan.baidu.com/s/1pJAZApP&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;功能:方便查看源码，一页里面可以打开多个C文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.Visual assist Options;(强烈推荐)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载地址:&lt;code&gt;http://pan.baidu.com/s/1dDh7Mtb&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;功能:自动识别各种关键字，系统函数，成员变量，自动给出输入提示，自动更正大小写错误，自动标示错误等等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.为了解决VC++6.0不能添加和打开文件的功能安装了FileTool。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载地址:&lt;code&gt;http://download.csdn.net/detail/ttfy1234/9696351&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;功能:VC6.0在添加和打开文件时经常会崩掉，这个插件就是为了解决这个问题。  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.VC6LineNumberAddin;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载地址:&lt;code&gt;http://pan.baidu.com/s/1dD8CfGd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;功能:VC6.0不自带行号，不方便阅读查找，这个是行号插件。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="PBC" scheme="http://harmansecurity.cn/tags/PBC/"/>
    
      <category term="密码学" scheme="http://harmansecurity.cn/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
      <category term="VC6.0" scheme="http://harmansecurity.cn/tags/VC6-0/"/>
    
  </entry>
  
  <entry>
    <title>这半年为什么止步不前？</title>
    <link href="http://harmansecurity.cn/2017/01/15/2016%E6%80%BB%E7%BB%93/"/>
    <id>http://harmansecurity.cn/2017/01/15/2016总结/</id>
    <published>2017-01-15T14:42:06.000Z</published>
    <updated>2017-01-16T14:49:55.381Z</updated>
    
    <content type="html"><![CDATA[<!--<img src="/diaryImages/diary-1.jpg" width = "700" height = "400"/>-->
<p><img src="http://ojto7c1rw.bkt.clouddn.com/diary-1.jpg" alt=""><br>　　时间过得很快，读研已半年，这半年来我一直都没好好想过这个问题，这半年我到底做了什么？我试着给自己答案——积累、沉淀，但是却有种莫名的心虚。</p>
<p>　　回顾2016年下半年的历程。七月份，在中科院信工所的物联网安全研发中心实习。去之前，本以为是朝九晚五的上班场景，心里还是忐忑的，结果与我想的截然相反，这里都是研究生，学习氛围很浓厚。那段日子应该就是我研究生阶段的预备期，或许是因为仰慕那些学姐学长基础扎实，编码能力强，为了缩短差距，我坚持每天早晨八点打卡，每晚坚持跑步回去到宿舍已基本十二点，从未给过自己一天的休息时间。当时我的任务是“如何检测内存异常访问”，因为项目的需求，需要了解Linux内核，期间泛读了《Python核心编程》、《鸟哥的Linux私房菜》、《Linux内核完全注释》(强烈推荐)，这三本书可以当做字典来用，没有必要全部读完。也重温了《计算机操作系统》、《计算机组成原理》、《深入理解计算机系统》。在这次实习中，最大的感受就是理论知识的缺乏，大学里面的基础课程在日后还是有很大作用的，于是决定利用接下来的三年时间多积累沉淀，多看些书。<br><a id="more"></a><br>　　入学的那段时间还是比较空闲的，我的计划是先看两本自己研究领域的书籍，虽然导师这边是偏理论，但其实自己对应用还是很热衷的，所以决定再看两本WEB安全的入门书籍。所看的密码学书：《图解密码技术》、《深入浅出密码学》、《基于配对的密码学》；WEB安全相关的书：《WEB安全前端黑客技术解密》、《XSS跨站脚本》(未读完)、《SQL注入攻击与防御》(未读)，此外对余弦发布的技能表做了相应的对照学习。</p>
<p>　　写到这里，也差不多能知道问题出在哪了：在理论上没有多大的进展，仍处于连门都没入的阶段，程序写的不多，没有学习太多的新技术，这就是莫名心虚的原因。最初的想法是先偏理论，不管是否选择继续走学术这条路都要发论文，研一暑假再决定最终是否工作。可能是心急了，要是很多东西一下子就能见成果，那就没多大意义了。或许临近期末的原因，躁动不安，扰乱了情绪，胡思乱想。  —2016.1.5 by LiangHui</p>
<hr>
<p>　　最近也在思考，当初为什么会有读博的想法？“因为之前做的一些东西，只知道如何去实现而不知道机制和原理，想在博士期间好好深入研究。”通过这半年的了解,很多其实并不是当初所想的那样，博士是在一个很小的方向上进行研究并能作出自己的突破。如果读现在的方向的博士达不到当初想要的效果，所以必须明确到底想要什么！接下来的一年将会把重心放在web安全技术上，利用空余的时间多读点书，多去实践。早做决定，早做打算。 —2016.1.15</p>
]]></content>
    
    <summary type="html">
    
      &lt;!--&lt;img src=&quot;/diaryImages/diary-1.jpg&quot; width = &quot;700&quot; height = &quot;400&quot;/&gt;--&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/diary-1.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;　　时间过得很快，读研已半年，这半年来我一直都没好好想过这个问题，这半年我到底做了什么？我试着给自己答案——积累、沉淀，但是却有种莫名的心虚。&lt;/p&gt;
&lt;p&gt;　　回顾2016年下半年的历程。七月份，在中科院信工所的物联网安全研发中心实习。去之前，本以为是朝九晚五的上班场景，心里还是忐忑的，结果与我想的截然相反，这里都是研究生，学习氛围很浓厚。那段日子应该就是我研究生阶段的预备期，或许是因为仰慕那些学姐学长基础扎实，编码能力强，为了缩短差距，我坚持每天早晨八点打卡，每晚坚持跑步回去到宿舍已基本十二点，从未给过自己一天的休息时间。当时我的任务是“如何检测内存异常访问”，因为项目的需求，需要了解Linux内核，期间泛读了《Python核心编程》、《鸟哥的Linux私房菜》、《Linux内核完全注释》(强烈推荐)，这三本书可以当做字典来用，没有必要全部读完。也重温了《计算机操作系统》、《计算机组成原理》、《深入理解计算机系统》。在这次实习中，最大的感受就是理论知识的缺乏，大学里面的基础课程在日后还是有很大作用的，于是决定利用接下来的三年时间多积累沉淀，多看些书。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://harmansecurity.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="总结" scheme="http://harmansecurity.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
</feed>
