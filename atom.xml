<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Harman&#39;s Homepage</title>
  <subtitle>Standing on the shoulders of giants.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://harmansecurity.cn/"/>
  <updated>2017-05-24T15:27:50.313Z</updated>
  <id>http://harmansecurity.cn/</id>
  
  <author>
    <name>Harman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解Java类加载器</title>
    <link href="http://harmansecurity.cn/2017/05/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>http://harmansecurity.cn/2017/05/24/深入理解Java类加载器/</id>
    <published>2017-05-24T14:11:21.000Z</published>
    <updated>2017-05-24T15:27:50.313Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-类的加载过程"><a href="#1-类的加载过程" class="headerlink" title="1. 类的加载过程"></a>1. 类的加载过程</h4><p>　 　JVM将类加载过程分为三个步骤：装载（Load），链接（Link）和初始化(Initialize)链接又分为三个步骤：</p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A81.jpg" alt=""></p>
<ul>
<li>装载：查找并加载类的二进制数据；</li>
<li><p>链接：</p>
<p>  验证：确保被加载类的正确性；</p>
<p>  准备：为类的静态变量分配内存，并将其初始化为默认值；</p>
<p>  解析：把类中的符号引用转换为直接引用；</p>
</li>
<li><p>初始化：为类的静态变量赋予正确的初始值；</p>
</li>
</ul>
<h4 id="2-类的初始化"><a href="#2-类的初始化" class="headerlink" title="2. 类的初始化"></a>2. 类的初始化</h4><p>类什么时候才被初始化：</p>
<ul>
<li>1）创建类的实例，也就是new一个对象</li>
<li>2）访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>3）调用类的静态方法</li>
<li>4）反射（Class.forName(“com.lyj.load”)）</li>
<li>5）初始化一个类的子类（会首先初始化子类的父类）</li>
<li>6）JVM启动时标明的启动类，即文件名和类名相同的那个类</li>
</ul>
<p>只有这6中情况才会导致类的类的初始化。</p>
<p>类的初始化步骤：</p>
<ul>
<li><p>1）如果这个类还没有被加载和链接，那先进行加载和链接</p>
</li>
<li><p>2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）</p>
</li>
<li><p>3)加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。</p>
</li>
</ul>
<a id="more"></a>
<h4 id="3-类的加载"><a href="#3-类的加载" class="headerlink" title="3.类的加载"></a>3.类的加载</h4><p>　 　类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象。如下图：</p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A82.jpg" alt=""></p>
<p>　 　类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<p>加载类的方式有以下几种：</p>
<ul>
<li>1）从本地系统直接加载</li>
<li>2）通过网络下载.class文件</li>
<li>3）从zip，jar等归档文件中加载.class文件</li>
<li>4）从专有数据库中提取.class文件</li>
<li>5）将Java源文件动态编译为.class文件（服务器）</li>
</ul>
<h4 id="4-加载器"><a href="#4-加载器" class="headerlink" title="4.加载器"></a>4.加载器</h4><p>JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A84.png" alt=""></p>
<ul>
<li>1）Bootstrap ClassLoader：负责加载<code>$JAVA_HOME中jre/lib/rt.jar</code>里所有的class，由C++实现，不是ClassLoader子类</li>
<li>2）Extension ClassLoader：负责加载java平台中扩展功能的一些jar包，包括<code>$JAVA_HOME中jre/lib/*.jar</code>或<code>-Djava.ext.dirs</code>指定目录下的jar包</li>
<li>3）App ClassLoader：负责记载classpath中指定的jar包及目录中class</li>
<li>4）Custom ClassLoader：属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</li>
</ul>
<p>　 　类加载器也是Java类，因为Java类的类加载器本身也是要被类加载器加载的，显然必须有第一个类加载器不是Java类，这个正是<strong>BootStrap,使用C/C++代码写的，已经封装到JVM内核中了，而ExtClassLoader和AppClassLoader是Java类。</strong></p>
<p>这边是另一张类加载器的属性结构图：</p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A85.jpg" alt=""></p>
<p>Java虚拟机中的所有类加载器采用具有父子关系的树形结构进行组织，在实例化每个类加载器对象的时候，需要为其指定一个父级类加载器对象或者默认采用系统类加载器为其父级类加载。</p>
<h4 id="5、类加载器的委托机制"><a href="#5、类加载器的委托机制" class="headerlink" title="5、类加载器的委托机制"></a>5、类加载器的委托机制</h4><p>当Java虚拟机要加载第一个类的时候，到底派出哪个类加载器去加载呢？</p>
<ul>
<li><p>(1). 首先当前线程的类加载器去加载线程中的第一个类(当前线程的类加载器：Thread类中有一个get/setContextClassLoader(ClassLoader cl);方法，可以获取/指定本线程中的类加载器)</p>
</li>
<li><p>(2). 如果类A中引用了类B,Java虚拟机将使用加载类A的类加载器来加载类B</p>
</li>
<li><p>(3). 还可以直接调用ClassLoader.loadClass(String className)方法来指定某个类加载器去加载某个类</p>
</li>
</ul>
<p>　 　每个类加载器加载类时，又先委托给其上级类加载器当所有祖宗类加载器没有加载到类，回到发起者类加载器，还加载不了，则会抛出ClassNotFoundException,不是再去找发起者类加载器的儿子，因为没有getChild()方法。例如：如上图所示： MyClassLoader-&gt;AppClassLoader-&gt;Ext-&gt;ClassLoader-&gt;BootStrap.<strong>自定定义的MyClassLoader1首先会先委托给AppClassLoader,AppClassLoader会委托给ExtClassLoader,ExtClassLoader会委托给BootStrap，这时候BootStrap就去加载，如果加载成功，就结束了。如果加载失败，就交给ExtClassLoader去加载，如果ExtClassLoader加载成功了，就结束了，如果加载失败就交给AppClassLoader加载，如果加载成功，就结束了，如果加载失败，就交给自定义的MyClassLoader1类加载器加载，如果加载失败，就报ClassNotFoundException异常，结束。</strong></p>
<h4 id="6、类加载器的可见性机制"><a href="#6、类加载器的可见性机制" class="headerlink" title="6、类加载器的可见性机制"></a>6、类加载器的可见性机制</h4><p>　 　根据可见性机制，子类加载器可以看到父类加载器加载的类，而反之则不行。所以下面的例子中，当Abc.class已经被Application类加载器加载过了，然后如果想要使用Extension类加载器加载这个类，将会抛出java.lang.ClassNotFoundException异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"> </div><div class="line"><span class="keyword">import</span> java.util.logging.Level;</div><div class="line"><span class="keyword">import</span> java.util.logging.Logger;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Java program to demonstrate How ClassLoader works in Java,</div><div class="line"> * in particular about visibility principle of ClassLoader.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Javin Paul</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;          </div><div class="line">            <span class="comment">//printing ClassLoader of this class</span></div><div class="line">            System.out.println(<span class="string">"ClassLoaderTest.getClass().getClassLoader() : "</span></div><div class="line">                                 + ClassLoaderTest.class.getClassLoader());</div><div class="line"></div><div class="line">            <span class="comment">//trying to explicitly load this class again using Extension class loader</span></div><div class="line">            Class.forName(<span class="string">"test.ClassLoaderTest"</span>, <span class="keyword">true</span></div><div class="line">                            ,  ClassLoaderTest.class.getClassLoader().getParent());</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</div><div class="line">            Logger.getLogger(ClassLoaderTest.class.getName()).log(Level.SEVERE, <span class="keyword">null</span>, ex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ClassLoaderTest.getClass().getClassLoader() : sun.misc.Launcher$AppClassLoader@<span class="number">601</span>bb1</div><div class="line"><span class="number">16</span>/<span class="number">08</span>/<span class="number">2012</span> <span class="number">2</span>:<span class="number">43</span>:<span class="number">48</span> AM test.ClassLoaderTest main</div><div class="line">SEVERE: <span class="keyword">null</span></div><div class="line">java.lang.ClassNotFoundException: test.ClassLoaderTest</div><div class="line">        at java.net.URLClassLoader$<span class="number">1</span>.run(URLClassLoader.java:<span class="number">202</span>)</div><div class="line">        at java.security.AccessController.doPrivileged(Native Method)</div><div class="line">        at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">190</span>)</div><div class="line">        at sun.misc.Launcher$ExtClassLoader.findClass(Launcher.java:<span class="number">229</span>)</div><div class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">306</span>)</div><div class="line">        at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">247</span>)</div><div class="line">        at java.lang.Class.forName0(Native Method)</div><div class="line">        at java.lang.Class.forName(Class.java:<span class="number">247</span>)</div><div class="line">        at test.ClassLoaderTest.main(ClassLoaderTest.java:<span class="number">29</span>)</div></pre></td></tr></table></figure>
<h4 id="7、类加载器的单一性机制"><a href="#7、类加载器的单一性机制" class="headerlink" title="7、类加载器的单一性机制"></a>7、类加载器的单一性机制</h4><p>　 　根据这个机制，父加载器加载过的类不能被子加载器加载第二次。虽然重写违反委托和单一性机制的类加载器是可能的，但这样做并不可取。你写自己的类加载器的时候应该严格遵守这三条机制。</p>
<h4 id="8、参考文献"><a href="#8、参考文献" class="headerlink" title="8、参考文献"></a>8、参考文献</h4><ul>
<li><code>http://blog.csdn.net/gjanyanlig/article/details/6818655/</code></li>
<li><code>http://blog.csdn.net/jiangwei0910410003/article/details/17733153</code></li>
<li><code>http://www.importnew.com/6581.html</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-类的加载过程&quot;&gt;&lt;a href=&quot;#1-类的加载过程&quot; class=&quot;headerlink&quot; title=&quot;1. 类的加载过程&quot;&gt;&lt;/a&gt;1. 类的加载过程&lt;/h4&gt;&lt;p&gt;　 　JVM将类加载过程分为三个步骤：装载（Load），链接（Link）和初始化(Initialize)链接又分为三个步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A81.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;装载：查找并加载类的二进制数据；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;链接：&lt;/p&gt;
&lt;p&gt;  验证：确保被加载类的正确性；&lt;/p&gt;
&lt;p&gt;  准备：为类的静态变量分配内存，并将其初始化为默认值；&lt;/p&gt;
&lt;p&gt;  解析：把类中的符号引用转换为直接引用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;初始化：为类的静态变量赋予正确的初始值；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2-类的初始化&quot;&gt;&lt;a href=&quot;#2-类的初始化&quot; class=&quot;headerlink&quot; title=&quot;2. 类的初始化&quot;&gt;&lt;/a&gt;2. 类的初始化&lt;/h4&gt;&lt;p&gt;类什么时候才被初始化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1）创建类的实例，也就是new一个对象&lt;/li&gt;
&lt;li&gt;2）访问某个类或接口的静态变量，或者对该静态变量赋值&lt;/li&gt;
&lt;li&gt;3）调用类的静态方法&lt;/li&gt;
&lt;li&gt;4）反射（Class.forName(“com.lyj.load”)）&lt;/li&gt;
&lt;li&gt;5）初始化一个类的子类（会首先初始化子类的父类）&lt;/li&gt;
&lt;li&gt;6）JVM启动时标明的启动类，即文件名和类名相同的那个类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有这6中情况才会导致类的类的初始化。&lt;/p&gt;
&lt;p&gt;类的初始化步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1）如果这个类还没有被加载和链接，那先进行加载和链接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3)加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="类加载器" scheme="http://harmansecurity.cn/tags/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java泛型</title>
    <link href="http://harmansecurity.cn/2017/05/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://harmansecurity.cn/2017/05/24/深入理解Java泛型/</id>
    <published>2017-05-24T12:46:21.000Z</published>
    <updated>2017-05-24T13:55:40.116Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-泛型概念的提出"><a href="#一-泛型概念的提出" class="headerlink" title="一. 泛型概念的提出"></a>一. 泛型概念的提出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List list = <span class="keyword">new</span> ArrayList();</div><div class="line">        list.add(<span class="string">"qqyumidi"</span>);</div><div class="line">        list.add(<span class="string">"corn"</span>);</div><div class="line">        list.add(<span class="number">100</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</div><div class="line">            String name = (String) list.get(i); <span class="comment">// 1</span></div><div class="line">            System.out.println(<span class="string">"name:"</span> + name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　 　定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。</p>
<p>在如上的编码过程中，我们发现主要存在两个问题：</p>
<ul>
<li>当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。</li>
<li>因此，//1处取出集合元素时需要人为的强制类型转化到具体目标类型，且很容易出现“java.lang.ClassCastException”异常。</li>
</ul>
<p><strong>那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。</strong></p>
<a id="more"></a>
<h4 id="二-什么是泛型"><a href="#二-什么是泛型" class="headerlink" title="二.什么是泛型"></a>二.什么是泛型</h4><p>　 　<strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">        List list = new ArrayList();</div><div class="line">        list.add("qqyumidi");</div><div class="line">        list.add("corn");</div><div class="line">        list.add(100);</div><div class="line">        */</div><div class="line"></div><div class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">        list.add(<span class="string">"qqyumidi"</span>);</div><div class="line">        list.add(<span class="string">"corn"</span>);</div><div class="line">        <span class="comment">//list.add(100);   // 1  提示编译错误</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</div><div class="line">            String name = list.get(i); <span class="comment">// 2</span></div><div class="line">            System.out.println(<span class="string">"name:"</span> + name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　 　采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List<string>，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。</string></p>
<p>　 　结合上面的泛型定义，我们知道在List<string>中，String是类型实参，也就是说，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）。下面就来看看List接口的的具体定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    Object[] toArray();</div><div class="line"></div><div class="line">    &lt;T&gt; T[] toArray(T[] a);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></string></p>
<p>　 　我们可以看到，在List接口中采用泛型化定义之后，<e>中的E表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。<br>自然的，ArrayList作为List接口的实现类，其定义形式是：</e></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        rangeCheck(index);</div><div class="line">        checkForComodification();</div><div class="line">        <span class="keyword">return</span> ArrayList.<span class="keyword">this</span>.elementData(offset + index);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//...省略掉其他具体的定义过程</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此，我们从源代码角度明白了为什么//1处加入Integer类型对象编译错误，且//2处get()到的类型直接就是String类型了。</p>
<h4 id="三、自定义泛型接口、泛型类和泛型方法"><a href="#三、自定义泛型接口、泛型类和泛型方法" class="headerlink" title="三、自定义泛型接口、泛型类和泛型方法"></a>三、自定义泛型接口、泛型类和泛型方法</h4><p>　 　从上面的内容中，大家已经明白了泛型的具体运作过程。也知道了接口、类和方法也都可以使用泛型去定义，以及相应的使用。是的，在具体使用时，可以分为泛型接口、泛型类和泛型方法。</p>
<p>　 　自定义泛型接口、泛型类和泛型方法与上述Java源码中的List、ArrayList类似。如下，我们看一个最简单的泛型类和方法定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Box&lt;String&gt; name = <span class="keyword">new</span> Box&lt;String&gt;(<span class="string">"corn"</span>);</div><div class="line">        System.out.println(<span class="string">"name:"</span> + name.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> T data;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　 　在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。<strong>那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;String&gt; name = <span class="keyword">new</span> Box&lt;String&gt;(<span class="string">"corn"</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"name class:"</span> + name.getClass());      <span class="comment">// com.qqyumidi.Box</span></div><div class="line">        System.out.println(<span class="string">"age class:"</span> + age.getClass());        <span class="comment">// com.qqyumidi.Box</span></div><div class="line">        System.out.println(name.getClass() == age.getClass());    <span class="comment">// true</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　 　由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。</p>
<p>　 　究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p>
<p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h4 id="四、类型通配符"><a href="#四、类型通配符" class="headerlink" title="四、类型通配符"></a>四、类型通配符</h4><p>　 　接着上面的结论，我们知道，Box<number>和Box<integer>实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于Box<number>和Box<integer>是否可以看成具有父子关系的泛型类型呢？为了弄清这个问题，我们继续看下下面这个例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;Number&gt; name = <span class="keyword">new</span> Box&lt;Number&gt;(<span class="number">99</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line"></div><div class="line">        getData(name);</div><div class="line">        </div><div class="line">        <span class="comment">//The method getData(Box&lt;Number&gt;) in the type GenericTest is </span></div><div class="line">        <span class="comment">//not applicable for the arguments (Box&lt;Integer&gt;)</span></div><div class="line">        getData(age);   <span class="comment">// 1</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;Number&gt; data)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></integer></number></integer></number></p>
<p>　 　我们发现，在代码//1处出现了错误提示信息：The method getData(Box<number>) in the t ype GenericTest is not applicable for the arguments (Box<integer>)。显然，通过提示信息，我们知道Box<number>在逻辑上不能视为Box<integer>的父类。那么，原因何在呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;Integer&gt; a = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line">        Box&lt;Number&gt; b = a;  <span class="comment">// 1</span></div><div class="line">        Box&lt;Float&gt; f = <span class="keyword">new</span> Box&lt;Float&gt;(<span class="number">3.14f</span>);</div><div class="line">        b.setData(f);        <span class="comment">// 2</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;Number&gt; data)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="keyword">private</span> T data;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Box</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">        setData(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> data;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.data = data;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></integer></number></integer></number></p>
<p>　 　这个例子中，显然//1和//2处肯定会出现错误提示的。在此我们可以使用反证法来进行说明。</p>
<p>　 　假设Box<number>在逻辑上可以视为Box<integer>的父类，那么//1和//2处将不会有错误提示了，那么问题就出来了，通过getData()方法取出数据时到底是什么类型呢？Integer? Float? 还是Number？且由于在编程过程中的顺序不可控性，导致在必要的时候必须要进行类型判断，且进行强制类型转换。显然，这与泛型的理念矛盾，因此，在逻辑上Box<number>不能视为Box<integer>的父类。</integer></number></integer></number></p>
<p>　 　好，那我们回过头来继续看“类型通配符”中的第一个例子，我们知道其具体的错误提示的深层次原因了。那么如何解决呢？总部能再定义一个新的函数吧。这和Java中的多态理念显然是违背的，因此，我们需要一个在逻辑上可以用来表示同时是Box<integer>和Box<number>的父类的一个引用类型，由此，类型通配符应运而生。</number></integer></p>
<p>　 　<strong>类型通配符一般是使用 ? 代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且Box&lt;?&gt;在逻辑上是Box<integer>、Box<number>…等所有Box&lt;具体类型实参&gt;的父类。由此，我们依然可以定义泛型方法，来完成此类需求。</number></integer></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;String&gt; name = <span class="keyword">new</span> Box&lt;String&gt;(<span class="string">"corn"</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line">        Box&lt;Number&gt; number = <span class="keyword">new</span> Box&lt;Number&gt;(<span class="number">314</span>);</div><div class="line"></div><div class="line">        getData(name);</div><div class="line">        getData(age);</div><div class="line">        getData(number);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;?&gt; data)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　 　有时候，我们还可能听到类型通配符上限和类型通配符下限。具体有是怎么样的呢？</p>
<p>　 　在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;String&gt; name = <span class="keyword">new</span> Box&lt;String&gt;(<span class="string">"corn"</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line">        Box&lt;Number&gt; number = <span class="keyword">new</span> Box&lt;Number&gt;(<span class="number">314</span>);</div><div class="line"></div><div class="line">        getData(name);</div><div class="line">        getData(age);</div><div class="line">        getData(number);</div><div class="line">        </div><div class="line">        <span class="comment">//getUpperNumberData(name); // 1</span></div><div class="line">        getUpperNumberData(age);    <span class="comment">// 2</span></div><div class="line">        getUpperNumberData(number); <span class="comment">// 3</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;?&gt; data)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUpperNumberData</span><span class="params">(Box&lt;? extends Number&gt; data)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>　 　此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。</p>
<p>　 　<strong>类型通配符上限通过形如Box&lt;? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt;? super Number&gt;形式，其含义与类型通配符上限正好相反。</strong></p>
<h4 id="五、通过反射获得泛型的实际类型参数"><a href="#五、通过反射获得泛型的实际类型参数" class="headerlink" title="五、通过反射获得泛型的实际类型参数"></a>五、通过反射获得泛型的实际类型参数</h4><p>　 　java 的泛型，只是编译时作为类型检查，一旦编译完成，泛型就会被擦除，在运行期间是得不到泛型的信息的，包括它的类型参数。有时候我们需要用到泛型的类型参数，反射看起来是取不到的，因反射在运行期间执行，但那时已无泛型的信息。一些构架却办到了，那么它们是怎么实现的呢？请看下面代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.*;  </div><div class="line"><span class="keyword">import</span> java.util.*;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        Method applyMethod=Test.class.getMethod(<span class="string">"applyVector"</span>, Vector.class);  </div><div class="line">        Type[] types=applyMethod.getGenericParameterTypes();  </div><div class="line">        System.out.println(types[<span class="number">0</span>].toString());  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyVector</span><span class="params">(Vector&lt;Date&gt; v1)</span></span>&#123;  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　 　看到了，实际上是通过获得方法，再取得方法的类型参数，这样泛型的实际类型参数就出来了。上面代码输出：java.util.Vector<java.util.date>，如果不只一个参数，要具体的类型参数呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.lang.reflect.*;  </div><div class="line"><span class="keyword">import</span> java.util.*;  </div><div class="line">  </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;  </div><div class="line">        Method applyMethod=Test.class.getMethod(<span class="string">"applyVector"</span>, Vector.class);  </div><div class="line">        Type[] types=applyMethod.getGenericParameterTypes();  </div><div class="line">        ParameterizedType pType=(ParameterizedType)types[<span class="number">0</span>];  </div><div class="line">        System.out.println(pType.getActualTypeArguments()[<span class="number">0</span>]);  </div><div class="line">        System.out.println(pType.getRawType());  </div><div class="line">  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applyVector</span><span class="params">(Vector&lt;Date&gt; v1)</span></span>&#123;  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//输出：</span></div><div class="line"><span class="comment">//class java.util.Date</span></div><div class="line"><span class="comment">//class java.util.Vector</span></div></pre></td></tr></table></figure></java.util.date></p>
<h4 id="三、参考文献"><a href="#三、参考文献" class="headerlink" title="三、参考文献"></a>三、参考文献</h4><ul>
<li><code>http://www.cnblogs.com/lwbqqyumidi/p/3837629.html</code></li>
<li><code>http://jisonami.iteye.com/blog/2282650</code></li>
<li><code>http://blog.csdn.net/hq333/article/details/7455328</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一-泛型概念的提出&quot;&gt;&lt;a href=&quot;#一-泛型概念的提出&quot; class=&quot;headerlink&quot; title=&quot;一. 泛型概念的提出&quot;&gt;&lt;/a&gt;一. 泛型概念的提出&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GenericTest&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        List list = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;qqyumidi&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;string&quot;&gt;&quot;corn&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        list.add(&lt;span class=&quot;number&quot;&gt;100&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; list.size(); i++) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            String name = (String) list.get(i); &lt;span class=&quot;comment&quot;&gt;// 1&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;name:&quot;&lt;/span&gt; + name);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;　 　定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。&lt;/p&gt;
&lt;p&gt;在如上的编码过程中，我们发现主要存在两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。&lt;/li&gt;
&lt;li&gt;因此，//1处取出集合元素时需要人为的强制类型转化到具体目标类型，且很容易出现“java.lang.ClassCastException”异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="泛型" scheme="http://harmansecurity.cn/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java注解</title>
    <link href="http://harmansecurity.cn/2017/05/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E6%B3%A8%E8%A7%A3/"/>
    <id>http://harmansecurity.cn/2017/05/24/深入理解Java注解/</id>
    <published>2017-05-24T11:34:21.000Z</published>
    <updated>2017-05-24T12:23:23.907Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、元注解"><a href="#一、元注解" class="headerlink" title="一、元注解"></a>一、元注解</h4><p>　 　元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：1.@Target,2.@Retention,3.@Documented,4.@Inherited。</p>
<p>　 　这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。</p>
<h5 id="1-Target"><a href="#1-Target" class="headerlink" title="1.@Target"></a>1.@Target</h5><p>　 　@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。</p>
<p>　 　<strong>作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</strong></p>
<p><strong>取值(ElementType)有：</strong></p>
<p>1.CONSTRUCTOR:用于描述构造器</p>
<p>2.FIELD:用于描述域</p>
<p>3.LOCAL_VARIABLE:用于描述局部变量</p>
<p>4.METHOD:用于描述方法</p>
<p>5.PACKAGE:用于描述包</p>
<p>6.PARAMETER:用于描述参数</p>
<p>7.TYPE:用于描述类、接口(包括注解类型) 或enum声明</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.TYPE)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Table &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 数据表名称注解，默认值为类名称</div><div class="line">     * <span class="doctag">@return</span></div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">tableName</span><span class="params">()</span> <span class="keyword">default</span> "className"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> NoDBColumn &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="2-Retention"><a href="#2-Retention" class="headerlink" title="2.@Retention"></a>2.@Retention</h5><p>　 　@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。</p>
<p>　 　<strong>作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效）</strong></p>
<p><strong>取值（RetentionPoicy）有：</strong></p>
<p>1.SOURCE:在源文件中有效（即源文件保留）</p>
<p>2.CLASS:在class文件中有效（即class保留）</p>
<p>3.RUNTIME:在运行时有效（即运行时保留）</p>
<p>　 　Retention meta-annotation类型有唯一的value作为成员，它的取值来自java.lang.annotation.RetentionPolicy的枚举类型值。Column注解的的RetentionPolicy的属性值是RUTIME,这样注解处理器可以通过反射，获取到该注解的属性值，从而去做一些运行时的逻辑处理。具体实例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "fieldName"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setFuncName</span><span class="params">()</span> <span class="keyword">default</span> "setField"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFuncName</span><span class="params">()</span> <span class="keyword">default</span> "getField"</span>; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">defaultDBValue</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h5 id="3-Documented"><a href="#3-Documented" class="headerlink" title="3.@Documented"></a>3.@Documented</h5><p>　 　@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "fieldName"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">setFuncName</span><span class="params">()</span> <span class="keyword">default</span> "setField"</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFuncName</span><span class="params">()</span> <span class="keyword">default</span> "getField"</span>; </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">defaultDBValue</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-Inherited"><a href="#4-Inherited" class="headerlink" title="4.@Inherited"></a>4.@Inherited</h5><p>　 　@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</p>
<p>　 　注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。</p>
<p>　 　当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Greeting &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> FontColor&#123; BULE,RED,GREEN&#125;;</div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>;</div><div class="line">    <span class="function">FontColor <span class="title">fontColor</span><span class="params">()</span> <span class="keyword">default</span> FontColor.GREEN</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="二、自定义注解"><a href="#二、自定义注解" class="headerlink" title="二、自定义注解"></a>二、自定义注解</h4><p>　 　使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。</p>
<p>　 　<strong>定义注解格式：public @interface 注解名 {定义体}</strong></p>
<p>注解参数的可支持数据类型：</p>
<ul>
<li>所有基本数据类型（int,float,boolean,byte,double,char,long,short)</li>
<li>String类型</li>
<li>Class类型</li>
<li>enum类型</li>
<li>Annotation类型</li>
<li>以上所有类型的数组</li>
</ul>
<p><strong>Annotation类型里面的参数该怎么设定:</strong></p>
<p>第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型；　 　</p>
<p>第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String;　　</p>
<p>第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号.</p>
<h5 id="1-自定义注解接口"><a href="#1-自定义注解接口" class="headerlink" title="1.自定义注解接口"></a>1.自定义注解接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.java.annotation;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</div><div class="line"><span class="keyword">import</span> java.lang.annotation.Target;</div><div class="line"></div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</div><div class="line"><span class="meta">@Inherited</span></div><div class="line"><span class="meta">@Documented</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Annotation_my &#123;</div><div class="line">    </div><div class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "张三"</span>;<span class="comment">//defalt 表示默认值</span></div><div class="line">    </div><div class="line">    <span class="function">String <span class="title">say</span><span class="params">()</span> <span class="keyword">default</span> "hello world"</span>;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 21</span>;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-定义接口"><a href="#2-定义接口" class="headerlink" title="2.定义接口"></a>2.定义接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.java.annotation;</div><div class="line"></div><div class="line"><span class="meta">@Annotation</span>_my <span class="comment">//使用我们刚才定义的注解</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="meta">@Annotation</span><span class="function">_my</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span>;</div><div class="line">    </div><div class="line">    <span class="meta">@Annotation</span><span class="function">_my</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span>;</div><div class="line">    </div><div class="line">    <span class="meta">@Annotation</span><span class="function">_my</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">age</span><span class="params">()</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-写接口的实现类"><a href="#3-写接口的实现类" class="headerlink" title="3.写接口的实现类"></a>3.写接口的实现类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.java.annotation;</div><div class="line"></div><div class="line"><span class="meta">@Annotation</span>_my</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@Annotation</span>_my(name=<span class="string">"流氓公子"</span>) <span class="comment">//赋值给name  默认的为张三</span></div><div class="line"><span class="comment">//在定义注解时没有给定默认值时，在此处必须name赋初值</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@Annotation</span>_my(say=<span class="string">" hello world  ！"</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@Annotation</span>_my(age=<span class="number">20</span>)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">age</span><span class="params">()</span> </span>&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-测试类测试注解-反射调用"><a href="#4-测试类测试注解-反射调用" class="headerlink" title="4.测试类测试注解(反射调用)"></a>4.测试类测试注解(反射调用)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.java.annotation;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span>&#123;</div><div class="line">    Annotation[] annotation = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</div><div class="line">        <span class="keyword">new</span> Text().getAnnotation();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAnnotation</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException</span>&#123;</div><div class="line">        Class&lt;?&gt; stu = Class.forName(<span class="string">"com.java.annotation.Student"</span>);<span class="comment">//静态加载类</span></div><div class="line">        <span class="keyword">boolean</span> isEmpty = stu.isAnnotationPresent(com.java.annotation.Annotation_my.class);<span class="comment">//判断stu是不是使用了我们刚才定义的注解接口if(isEmpty)&#123;</span></div><div class="line">            annotation = stu.getAnnotations();<span class="comment">//获取注解接口中的</span></div><div class="line">            <span class="keyword">for</span>(Annotation a:annotation)&#123;</div><div class="line">                Annotation_my my = (Annotation_my)a;<span class="comment">//强制转换成Annotation_my类型</span></div><div class="line">                System.out.println(stu+<span class="string">":\n"</span>+my.name()+<span class="string">" say: "</span>+my.say()+<span class="string">" my age: "</span>+my.age());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Method[] method = stu.getMethods();<span class="comment">//</span></div><div class="line">        System.out.println(<span class="string">"Method"</span>);</div><div class="line">        <span class="keyword">for</span>(Method m:method)&#123;</div><div class="line">            <span class="keyword">boolean</span> ismEmpty = m.isAnnotationPresent(com.java.annotation.Annotation_my.class);</div><div class="line">            <span class="keyword">if</span>(ismEmpty)&#123;</div><div class="line">                Annotation[] aa = m.getAnnotations();</div><div class="line">                <span class="keyword">for</span>(Annotation a:aa)&#123;</div><div class="line">                    Annotation_my an = (Annotation_my)a;</div><div class="line">                    System.out.println(m+<span class="string">":\n"</span>+an.name()+<span class="string">" say: "</span>+an.say()+<span class="string">" my age: "</span>+an.age());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//get Fields by force</span></div><div class="line">        System.out.println(<span class="string">"get Fileds by force !"</span>);</div><div class="line">        Field[] field = stu.getDeclaredFields();</div><div class="line">        <span class="keyword">for</span>(Field f:field)&#123;</div><div class="line">            f.setAccessible(<span class="keyword">true</span>);</div><div class="line">            System.out.println(f.getName());</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"get methods in interfaces !"</span>);</div><div class="line">        Class&lt;?&gt; interfaces[] = stu.getInterfaces();</div><div class="line">        <span class="keyword">for</span>(Class&lt;?&gt; c:interfaces)&#123;</div><div class="line">            Method[] imethod = c.getMethods();</div><div class="line">            <span class="keyword">for</span>(Method m:imethod)&#123;</div><div class="line">                System.out.println(m.getName());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5-注解添加属性值"><a href="#5-注解添加属性值" class="headerlink" title="5.注解添加属性值"></a>5.注解添加属性值</h5><p>注解类型的属性：MetaAnnotation annotationAttr() default @MetaAnnotation(“xxxx”); </p>
<p>被添加的注解设置属性值：@MyAnnotation(annotationAttr=@MetaAnnotation(“yyy”) )可以认为上面这个@MyAnnotation是MyAnnotaion类的一个实例对象.</p>
<p>同样的道理，可以认为上面这个@MetaAnnotation是MetaAnnotation类的一个实例对象，调用代码如下：</p>
<p>　 　MetaAnnotation ma =  myAnnotation.annotationAttr();</p>
<p>　 　System.out.println(ma.value());<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> mypkg;  </div><div class="line"><span class="keyword">import</span> java.lang.annotation.*;  </div><div class="line"><span class="keyword">import</span> mypkg.EnumDemo4;  </div><div class="line">  </div><div class="line"><span class="meta">@interface</span> MetaAnnotation&#123;  </div><div class="line">      <span class="function">String <span class="title">value</span><span class="params">()</span></span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">//此注解运行到内存时才消除  </span></div><div class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD,ElementType.TYPE&#125;) <span class="comment">//此注解可修饰方法和类  </span></div><div class="line"><span class="meta">@interface</span> MyAnnotation &#123;  </div><div class="line">    <span class="function">String <span class="title">color</span><span class="params">()</span> <span class="keyword">default</span> "blue" </span>;  </div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;  </div><div class="line">    <span class="keyword">int</span>[] arrayAttr() <span class="keyword">default</span> &#123;<span class="number">1</span>&#125;;  </div><div class="line">    EnumDemo4.<span class="function">TrafficLamp <span class="title">lamp</span><span class="params">()</span> <span class="keyword">default</span> EnumDemo4.TrafficLamp.RED</span>;  </div><div class="line">    <span class="function">MetaAnnotation <span class="title">annotationAttr</span><span class="params">()</span> <span class="keyword">default</span> @<span class="title">MetaAnnotation</span><span class="params">( <span class="string">"lhm"</span>)</span></span>;  </div><div class="line">    <span class="function">Class <span class="title">clazz</span><span class="params">()</span> <span class="keyword">default</span> String.class</span>;  </div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="comment">//AnnotationTest2类的注解及属性  </span></div><div class="line"><span class="meta">@MyAnnotation</span>(annotationAttr=<span class="meta">@MetaAnnotation</span>(<span class="string">"flx"</span>),color=<span class="string">"red"</span>,value=<span class="string">"abc"</span>,arrayAttr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest2</span> </span>&#123;  </div><div class="line">  </div><div class="line">    <span class="meta">@MyAnnotation</span>(<span class="string">"xyz"</span>)  <span class="comment">//main方法的注解的属性value="xyz"  </span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </div><div class="line">        <span class="keyword">if</span>(AnnotationTest2.class.isAnnotationPresent(MyAnnotation. <span class="class"><span class="keyword">class</span>))</span>&#123;  </div><div class="line">            MyAnnotation myAnnotation = AnnotationTest2.class .getAnnotation(MyAnnotation. <span class="class"><span class="keyword">class</span>)</span>;  </div><div class="line">            System. out.println(myAnnotation.color());  </div><div class="line">            <span class="comment">//结果：red  </span></div><div class="line">            System. out.println(myAnnotation.arrayAttr().length);  </div><div class="line">            <span class="comment">//结果：3  </span></div><div class="line">            System. out.println(myAnnotation.lamp().nextLamp().name());  </div><div class="line">            <span class="comment">//结果：GREEN  </span></div><div class="line">            System. out.println(myAnnotation.annotationAttr().value());  </div><div class="line">            <span class="comment">//结果：flx  </span></div><div class="line">            System. out.println(myAnnotation.clazz());  </div><div class="line">            <span class="comment">//结果：class java.lang.String  </span></div><div class="line">        &#125;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="三、参考文献"><a href="#三、参考文献" class="headerlink" title="三、参考文献"></a>三、参考文献</h4><ul>
<li><code>http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html</code></li>
<li><strong><code>http://blog.csdn.net/rock_ray/article/details/22334467</code></strong>(全)</li>
<li><code>http://www.cnblogs.com/lzh984294471/p/4959953.html</code></li>
<li><code>http://www.cnblogs.com/cr330326/p/5695474.html</code></li>
<li><code>http://blog.csdn.net/zheng963/article/details/49991303</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、元注解&quot;&gt;&lt;a href=&quot;#一、元注解&quot; class=&quot;headerlink&quot; title=&quot;一、元注解&quot;&gt;&lt;/a&gt;一、元注解&lt;/h4&gt;&lt;p&gt;　 　元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：1.@Target,2.@Retention,3.@Documented,4.@Inherited。&lt;/p&gt;
&lt;p&gt;　 　这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。&lt;/p&gt;
&lt;h5 id=&quot;1-Target&quot;&gt;&lt;a href=&quot;#1-Target&quot; class=&quot;headerlink&quot; title=&quot;1.@Target&quot;&gt;&lt;/a&gt;1.@Target&lt;/h5&gt;&lt;p&gt;　 　@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。&lt;/p&gt;
&lt;p&gt;　 　&lt;strong&gt;作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;取值(ElementType)有：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.CONSTRUCTOR:用于描述构造器&lt;/p&gt;
&lt;p&gt;2.FIELD:用于描述域&lt;/p&gt;
&lt;p&gt;3.LOCAL_VARIABLE:用于描述局部变量&lt;/p&gt;
&lt;p&gt;4.METHOD:用于描述方法&lt;/p&gt;
&lt;p&gt;5.PACKAGE:用于描述包&lt;/p&gt;
&lt;p&gt;6.PARAMETER:用于描述参数&lt;/p&gt;
&lt;p&gt;7.TYPE:用于描述类、接口(包括注解类型) 或enum声明&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; Table &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     * 数据表名称注解，默认值为类名称&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;     */&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;tableName&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; &quot;className&quot;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Target&lt;/span&gt;(ElementType.FIELD)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;meta&quot;&gt;@interface&lt;/span&gt; NoDBColumn &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="注解" scheme="http://harmansecurity.cn/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java反射</title>
    <link href="http://harmansecurity.cn/2017/05/24/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E5%8F%8D%E5%B0%84/"/>
    <id>http://harmansecurity.cn/2017/05/24/深入理解Java反射/</id>
    <published>2017-05-24T06:07:21.000Z</published>
    <updated>2017-05-24T11:33:57.992Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、反射的概念"><a href="#一、反射的概念" class="headerlink" title="一、反射的概念"></a>一、反射的概念</h4><p>　 　反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<h4 id="二、反射提供的功能"><a href="#二、反射提供的功能" class="headerlink" title="二、反射提供的功能"></a>二、反射提供的功能</h4><ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法；</li>
<li>在运行时调用任意一个对象的方法；</li>
<li>生成动态代理。</li>
</ul>
<h4 id="三、反射机制的相关API"><a href="#三、反射机制的相关API" class="headerlink" title="三、反射机制的相关API"></a>三、反射机制的相关API</h4><h5 id="1-通过一个对象获得完整的包名和类名"><a href="#1-通过一个对象获得完整的包名和类名" class="headerlink" title="1.通过一个对象获得完整的包名和类名"></a>1.通过一个对象获得完整的包名和类名</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        TestReflect testReflect = <span class="keyword">new</span> TestReflect();</div><div class="line">        System.out.println(testReflect.getClass().getName());</div><div class="line">        <span class="comment">// 结果 net.xsoftlab.baike.TestReflect</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-获取Class类三种方法"><a href="#2-获取Class类三种方法" class="headerlink" title="2.获取Class类三种方法"></a>2.获取Class类三种方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Class&lt;?&gt; class1 = <span class="keyword">null</span>;</div><div class="line">        Class&lt;?&gt; class2 = <span class="keyword">null</span>;</div><div class="line">        Class&lt;?&gt; class3 = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 一般采用这种形式</span></div><div class="line">        class1 = Class.forName(<span class="string">"net.xsoftlab.baike.TestReflect"</span>);</div><div class="line">        class2 = <span class="keyword">new</span> TestReflect().getClass();<span class="comment">////java语言中任何一个java对象都有getClass 方法</span></div><div class="line">        class3 = TestReflect.class;<span class="comment">//java中每个类型都有class 属性.</span></div><div class="line">        System.out.println(<span class="string">"类名称   "</span> + class1.getName());</div><div class="line">        System.out.println(<span class="string">"类名称   "</span> + class2.getName());</div><div class="line">        System.out.println(<span class="string">"类名称   "</span> + class3.getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h5 id="3-获取一个对象的父类与实现的接口"><a href="#3-获取一个对象的父类与实现的接口" class="headerlink" title="3.获取一个对象的父类与实现的接口"></a>3.获取一个对象的父类与实现的接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2862585049955236662L</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"net.xsoftlab.baike.TestReflect"</span>);</div><div class="line">        <span class="comment">// 取得父类</span></div><div class="line">        Class&lt;?&gt; parentClass = clazz.getSuperclass();</div><div class="line">        System.out.println(<span class="string">"clazz的父类为："</span> + parentClass.getName());</div><div class="line">        <span class="comment">// clazz的父类为： java.lang.Object</span></div><div class="line">        <span class="comment">// 获取所有的接口</span></div><div class="line">        Class&lt;?&gt; intes[] = clazz.getInterfaces();</div><div class="line">        System.out.println(<span class="string">"clazz实现的接口有："</span>);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; intes.length; i++) &#123;</div><div class="line">            System.out.println((i + <span class="number">1</span>) + <span class="string">"："</span> + intes[i].getName());</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// clazz实现的接口有：</span></div><div class="line">        <span class="comment">// 1：java.io.Serializable</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-通过反射机制实例化一个类的对象-获取类中的构造函数"><a href="#4-通过反射机制实例化一个类的对象-获取类中的构造函数" class="headerlink" title="4.通过反射机制实例化一个类的对象(获取类中的构造函数)"></a>4.通过反射机制实例化一个类的对象(获取类中的构造函数)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Class&lt;?&gt; class1 = <span class="keyword">null</span>;</div><div class="line">        class1 = Class.forName(<span class="string">"net.xsoftlab.baike.User"</span>);</div><div class="line">        <span class="comment">// 第一种方法，实例化默认构造方法，调用set赋值</span></div><div class="line">        User user = (User) class1.newInstance();</div><div class="line">        user.setAge(<span class="number">20</span>);</div><div class="line">        user.setName(<span class="string">"Rollen"</span>);</div><div class="line">        System.out.println(user);</div><div class="line">        <span class="comment">// 结果 User [age=20, name=Rollen]</span></div><div class="line">        <span class="comment">// 第二种方法 取得全部的构造函数 使用构造函数赋值</span></div><div class="line">        Constructor&lt;?&gt; cons[] = class1.getConstructors();</div><div class="line">        <span class="comment">// 查看每个构造方法需要的参数</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cons.length; i++) &#123;</div><div class="line">            Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes();</div><div class="line">            System.out.print(<span class="string">"cons["</span> + i + <span class="string">"] ("</span>);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; clazzs.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (j == clazzs.length - <span class="number">1</span>)</div><div class="line">                    System.out.print(clazzs[j].getName());</div><div class="line">                <span class="keyword">else</span></div><div class="line">                    System.out.print(clazzs[j].getName() + <span class="string">","</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println(<span class="string">")"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 结果</span></div><div class="line">        <span class="comment">// cons[0] (java.lang.String)</span></div><div class="line">        <span class="comment">// cons[1] (int,java.lang.String)</span></div><div class="line">        <span class="comment">// cons[2] ()</span></div><div class="line">        user = (User) cons[<span class="number">0</span>].newInstance(<span class="string">"Rollen"</span>);</div><div class="line">        System.out.println(user);</div><div class="line">        <span class="comment">// 结果 User [age=0, name=Rollen]</span></div><div class="line">        user = (User) cons[<span class="number">1</span>].newInstance(<span class="number">20</span>, <span class="string">"Rollen"</span>);</div><div class="line">        System.out.println(user);</div><div class="line">        <span class="comment">// 结果 User [age=20, name=Rollen]</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> age;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"User [age="</span> + age + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5-获取类的全部属性"><a href="#5-获取类的全部属性" class="headerlink" title="5.获取类的全部属性"></a>5.获取类的全部属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2862585049955236662L</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"net.xsoftlab.baike.TestReflect"</span>);</div><div class="line">        System.out.println(<span class="string">"===============本类属性==============="</span>);</div><div class="line">        <span class="comment">// 取得本类的全部属性</span></div><div class="line">        Field[] field = clazz.getDeclaredFields();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; field.length; i++) &#123;</div><div class="line">            <span class="comment">// 权限修饰符</span></div><div class="line">            <span class="keyword">int</span> mo = field[i].getModifiers();</div><div class="line">            String priv = Modifier.toString(mo);</div><div class="line">            <span class="comment">// 属性类型</span></div><div class="line">            Class&lt;?&gt; type = field[i].getType();</div><div class="line">            System.out.println(priv + <span class="string">" "</span> + type.getName() + <span class="string">" "</span> + field[i].getName() + <span class="string">";"</span>);</div><div class="line">        &#125;</div><div class="line">         </div><div class="line">        System.out.println(<span class="string">"==========实现的接口或者父类的属性=========="</span>);</div><div class="line">        <span class="comment">// 取得实现的接口或者父类的属性</span></div><div class="line">        Field[] filed1 = clazz.getFields();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; filed1.length; j++) &#123;</div><div class="line">            <span class="comment">// 权限修饰符</span></div><div class="line">            <span class="keyword">int</span> mo = filed1[j].getModifiers();</div><div class="line">            String priv = Modifier.toString(mo);</div><div class="line">            <span class="comment">// 属性类型</span></div><div class="line">            Class&lt;?&gt; type = filed1[j].getType();</div><div class="line">            System.out.println(priv + <span class="string">" "</span> + type.getName() + <span class="string">" "</span> + filed1[j].getName() + <span class="string">";"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="6-获取类的全部方法"><a href="#6-获取类的全部方法" class="headerlink" title="6.获取类的全部方法"></a>6.获取类的全部方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="keyword">import</span> java.io.Serializable;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2862585049955236662L</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"net.xsoftlab.baike.TestReflect"</span>);</div><div class="line">        Method method[] = clazz.getMethods();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; method.length; ++i) &#123;</div><div class="line">            Class&lt;?&gt; returnType = method[i].getReturnType();</div><div class="line">            Class&lt;?&gt; para[] = method[i].getParameterTypes();</div><div class="line">            <span class="keyword">int</span> temp = method[i].getModifiers();</div><div class="line">            System.out.print(Modifier.toString(temp) + <span class="string">" "</span>);</div><div class="line">            System.out.print(returnType.getName() + <span class="string">"  "</span>);</div><div class="line">            System.out.print(method[i].getName() + <span class="string">" "</span>);</div><div class="line">            System.out.print(<span class="string">"("</span>);</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; para.length; ++j) &#123;</div><div class="line">                System.out.print(para[j].getName() + <span class="string">" "</span> + <span class="string">"arg"</span> + j);</div><div class="line">                <span class="keyword">if</span> (j &lt; para.length - <span class="number">1</span>) &#123;</div><div class="line">                    System.out.print(<span class="string">","</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Class&lt;?&gt; exce[] = method[i].getExceptionTypes();</div><div class="line">            <span class="keyword">if</span> (exce.length &gt; <span class="number">0</span>) &#123;</div><div class="line">                System.out.print(<span class="string">") throws "</span>);</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; exce.length; ++k) &#123;</div><div class="line">                    System.out.print(exce[k].getName() + <span class="string">" "</span>);</div><div class="line">                    <span class="keyword">if</span> (k &lt; exce.length - <span class="number">1</span>) &#123;</div><div class="line">                        System.out.print(<span class="string">","</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                System.out.print(<span class="string">")"</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.println();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="7-通过反射机制调用某个类的方法"><a href="#7-通过反射机制调用某个类的方法" class="headerlink" title="7.通过反射机制调用某个类的方法"></a>7.通过反射机制调用某个类的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Class&lt;?&gt; clazz = Class.forName(<span class="string">"net.xsoftlab.baike.TestReflect"</span>);</div><div class="line">        <span class="comment">// 调用TestReflect类中的reflect1方法</span></div><div class="line">        Method method = clazz.getMethod(<span class="string">"reflect1"</span>);</div><div class="line">        method.invoke(clazz.newInstance());</div><div class="line">        <span class="comment">// Java 反射机制 - 调用某个类的方法1.</span></div><div class="line">        <span class="comment">// 调用TestReflect的reflect2方法</span></div><div class="line">        method = clazz.getMethod(<span class="string">"reflect2"</span>, <span class="keyword">int</span>.class, String.class);</div><div class="line">        method.invoke(clazz.newInstance(), <span class="number">20</span>, <span class="string">"张三"</span>);</div><div class="line">        <span class="comment">// Java 反射机制 - 调用某个类的方法2.</span></div><div class="line">        <span class="comment">// age -&gt; 20. name -&gt; 张三</span></div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflect1</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Java 反射机制 - 调用某个类的方法1."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reflect2</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Java 反射机制 - 调用某个类的方法2."</span>);</div><div class="line">        System.out.println(<span class="string">"age -&gt; "</span> + age + <span class="string">". name -&gt; "</span> + name);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="8-反射机制的动态代理"><a href="#8-反射机制的动态代理" class="headerlink" title="8.反射机制的动态代理"></a>8.反射机制的动态代理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取类加载器的方法</span></div><div class="line">TestReflect testReflect = <span class="keyword">new</span> TestReflect();</div><div class="line">        System.out.println(<span class="string">"类加载器  "</span> + testReflect.getClass().getClassLoader().getClass().getName());</div><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</div><div class="line"><span class="comment">//定义项目接口</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 定义真实项目</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name + <span class="string">"  "</span> + age;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">null</span>;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.obj = obj;</div><div class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), <span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        Object temp = method.invoke(<span class="keyword">this</span>.obj, args);</div><div class="line">        <span class="keyword">return</span> temp;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 在java中有三种类类加载器。</div><div class="line"> * </div><div class="line"> * 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。</div><div class="line"> * </div><div class="line"> * 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jrelibext目录中的类</div><div class="line"> * </div><div class="line"> * 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。</div><div class="line"> * </div><div class="line"> * 如果想要完成动态代理，首先需要定义一个InvocationHandler接口的子类，已完成代理的具体操作。</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> xsoftlab.net</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        MyInvocationHandler demo = <span class="keyword">new</span> MyInvocationHandler();</div><div class="line">        Subject sub = (Subject) demo.bind(<span class="keyword">new</span> RealSubject());</div><div class="line">        String info = sub.say(<span class="string">"Rollen"</span>, <span class="number">20</span>);</div><div class="line">        System.out.println(info);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="四、反射机制的应用实例"><a href="#四、反射机制的应用实例" class="headerlink" title="四、反射机制的应用实例"></a>四、反射机制的应用实例</h4><h5 id="1-在泛型为Integer的ArrayList中存放一个String类型的对象"><a href="#1-在泛型为Integer的ArrayList中存放一个String类型的对象" class="headerlink" title="1.在泛型为Integer的ArrayList中存放一个String类型的对象"></a>1.在泛型为Integer的ArrayList中存放一个String类型的对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">        Method method = list.getClass().getMethod(<span class="string">"add"</span>, Object.class);</div><div class="line">        method.invoke(list, <span class="string">"Java反射机制实例。"</span>);</div><div class="line">        System.out.println(list.get(<span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-通过反射取得并修改数组的信息"><a href="#2-通过反射取得并修改数组的信息" class="headerlink" title="2.通过反射取得并修改数组的信息"></a>2.通过反射取得并修改数组的信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Array;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] temp = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</div><div class="line">        Class&lt;?&gt; demo = temp.getClass().getComponentType();</div><div class="line">        System.out.println(<span class="string">"数组类型： "</span> + demo.getName());</div><div class="line">        System.out.println(<span class="string">"数组长度  "</span> + Array.getLength(temp));</div><div class="line">        System.out.println(<span class="string">"数组的第一个元素: "</span> + Array.get(temp, <span class="number">0</span>));</div><div class="line">        Array.set(temp, <span class="number">0</span>, <span class="number">100</span>);</div><div class="line">        System.out.println(<span class="string">"修改之后数组第一个元素为： "</span> + Array.get(temp, <span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-通过反射机制修改数组的大小"><a href="#3-通过反射机制修改数组的大小" class="headerlink" title="3.通过反射机制修改数组的大小"></a>3.通过反射机制修改数组的大小</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Array;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] temp = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</div><div class="line">        <span class="keyword">int</span>[] newTemp = (<span class="keyword">int</span>[]) arrayInc(temp, <span class="number">15</span>);</div><div class="line">        print(newTemp);</div><div class="line">        String[] atr = &#123; <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span> &#125;;</div><div class="line">        String[] str1 = (String[]) arrayInc(atr, <span class="number">8</span>);</div><div class="line">        print(str1);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 修改数组大小</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">arrayInc</span><span class="params">(Object obj, <span class="keyword">int</span> len)</span> </span>&#123;</div><div class="line">        Class&lt;?&gt; arr = obj.getClass().getComponentType();</div><div class="line">        Object newArr = Array.newInstance(arr, len);</div><div class="line">        <span class="keyword">int</span> co = Array.getLength(obj);</div><div class="line">        System.arraycopy(obj, <span class="number">0</span>, newArr, <span class="number">0</span>, co);</div><div class="line">        <span class="keyword">return</span> newArr;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 打印</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">        Class&lt;?&gt; c = obj.getClass();</div><div class="line">        <span class="keyword">if</span> (!c.isArray()) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"数组长度为： "</span> + Array.getLength(obj));</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Array.getLength(obj); i++) &#123;</div><div class="line">            System.out.print(Array.get(obj, i) + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-将反射机制应用于工厂模式"><a href="#4-将反射机制应用于工厂模式" class="headerlink" title="4.将反射机制应用于工厂模式"></a>4.将反射机制应用于工厂模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> net.xsoftlab.baike;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">fruit</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">fruit</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Apple"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">implements</span> <span class="title">fruit</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Orange"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> fruit <span class="title">getInstance</span><span class="params">(String ClassName)</span> </span>&#123;</div><div class="line">        fruit f = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            f = (fruit) Class.forName(ClassName).newInstance();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> f;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 对于普通的工厂模式当我们在添加一个子类的时候，就需要对应的修改工厂类。 当我们添加很多的子类的时候，会很麻烦。</div><div class="line"> * Java 工厂模式可以参考</div><div class="line"> * http://baike.xsoftlab.net/view/java-factory-pattern</div><div class="line"> * </div><div class="line"> * 现在我们利用反射机制实现工厂模式，可以在不修改工厂类的情况下添加任意多个子类。</div><div class="line"> * </div><div class="line"> * 但是有一点仍然很麻烦，就是需要知道完整的包名和类名，这里可以使用properties配置文件来完成。</div><div class="line"> * </div><div class="line"> * java 读取 properties 配置文件 的方法可以参考</div><div class="line"> * http://baike.xsoftlab.net/view/java-read-the-properties-configuration-file</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReflect</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        fruit f = Factory.getInstance(<span class="string">"net.xsoftlab.baike.Apple"</span>);</div><div class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</div><div class="line">            f.eat();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="五、框架的概念及用反射技术开发框架的原理"><a href="#五、框架的概念及用反射技术开发框架的原理" class="headerlink" title="五、框架的概念及用反射技术开发框架的原理"></a>五、框架的概念及用反射技术开发框架的原理</h4><h5 id="1-框架：通过反射调用Java类的一种方式。"><a href="#1-框架：通过反射调用Java类的一种方式。" class="headerlink" title="1.框架：通过反射调用Java类的一种方式。"></a>1.框架：通过反射调用Java类的一种方式。</h5><p>　 　(框架与房子非常类似，使用的用户写的程序写配置文件，就相当于给房子装修)</p>
<p> 　 　如房地产商造房子用户住，门窗和空调等等内部都是由用户自己安装，房子就是框架，用户需使用此框架，安好门窗等放入到房地产商提供的框架中。</p>
<p>　 　框架和工具类的区别：工具类被用户类调用，而框架是调用用户提供的类。</p>
<h5 id="2-框架机器要解决的核心问题"><a href="#2-框架机器要解决的核心问题" class="headerlink" title="2.框架机器要解决的核心问题"></a>2.框架机器要解决的核心问题</h5><p>　 　我们在写框架（造房子的过程）的时候，调用的类（安装的门窗等）还未出现，那么，框架无法知道要被调用的类名，所以在程序中无法直接new其某个类的实例对象，而要用反射来做。</p>
<h5 id="3-简单框架程序的步骤："><a href="#3-简单框架程序的步骤：" class="headerlink" title="3.简单框架程序的步骤："></a>3.简单框架程序的步骤：</h5><p>1）右击项目File命名一个配置文件如：config.properties,然后写入配置信息。如键值对：className=java.util.ArrayList，等号右边的配置键，右边是值。</p>
<p>2）代码实现，加载此文件：</p>
<ul>
<li><p>将文件读取到读取流中，要写出配置文件的绝对路径。</p>
<pre><code>如：InputStream is=new FileInputStream(“配置文件”);
</code></pre></li>
<li><p>用Properties类的load()方法将流中的数据存入集合。</p>
</li>
<li><p>关闭流：关闭的是读取流，因为流中的数据已经加载进内存。</p>
</li>
</ul>
<p>3）通过getProperty()方法获取className，即配置的值，也就是某个类名。</p>
<p>4）用反射的方式，创建对象newInstance()。</p>
<p>5）执行程序主体功能</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"config.properties"</span>);  </div><div class="line">Properties properties = <span class="keyword">new</span> Properties();  </div><div class="line">properties.load(fileInputStream);  </div><div class="line">fileInputStream.close();  </div><div class="line">String className =properties.getProperty(<span class="string">"className"</span>);  </div><div class="line">ArrayList  arrayList = (ArrayList)Class.forName(className).newInstance();</div></pre></td></tr></table></figure>
<h4 id="六、用类加载器的方式管理资源和配置文件"><a href="#六、用类加载器的方式管理资源和配置文件" class="headerlink" title="六、用类加载器的方式管理资源和配置文件"></a>六、用类加载器的方式管理资源和配置文件</h4><h5 id="1-简述：类加载器是将-class的文件加载进内存，也可将普通文件中的信息加载进内存。"><a href="#1-简述：类加载器是将-class的文件加载进内存，也可将普通文件中的信息加载进内存。" class="headerlink" title="1.简述：类加载器是将.class的文件加载进内存，也可将普通文件中的信息加载进内存。"></a>1.简述：类加载器是将.class的文件加载进内存，也可将普通文件中的信息加载进内存。</h5><p>spring这些框架加载配置文件</p>
<h5 id="2-文件的加载问题："><a href="#2-文件的加载问题：" class="headerlink" title="2.文件的加载问题："></a>2.文件的加载问题：</h5><p> 1）eclipse会将源程序中的所有.java文件编译成.class文件，然后放到classPath指定的目录中去。并且会将非.java文件原封不动的复制到.class指定的目录中去。在运行的时候，执行的是.class文件。</p>
<p>2）将配置文件放到.class文件目录中一同打包，类加载器就会一同加载。</p>
<h5 id="3-资源文件的加载：是使用类加载器。"><a href="#3-资源文件的加载：是使用类加载器。" class="headerlink" title="3.资源文件的加载：是使用类加载器。"></a>3.资源文件的加载：是使用类加载器。</h5><p>1）由类加载器ClassLoader来加载进内存，即用getClassLoader()方法获取类加载器，然后用类加载器的getResourceAsStream(String name)方法，将配置文件（资源文件）加载进内存。利用类加载器来加载配置文件，需把配置文件放置的包名一起写上。这种方式只有读取功能。</p>
<p>2）Class类也提供getResourceAsStream方法来加载资源文件，其实它内部就是调用了ClassLoader的方法。这时，配置文件是相对类文件的当前目录的，也就是说用这种方法，配置文件前面可以省略包名。</p>
<p>如：类名.class.getResourceAsStream(“资源文件名”)</p>
<h5 id="4-配置文件的路径问题："><a href="#4-配置文件的路径问题：" class="headerlink" title="4.配置文件的路径问题："></a>4.配置文件的路径问题：</h5><p>1）用绝对路径，通过getRealPath()方法运算出来具体的目录，而不是内部编码出来的。</p>
<p>一般先得到用户自定义的总目录，在加上自己内部的路径。可以通过getRealPath()方法获取文件路径。对配置文件修改是需要要储存到配置文件中，那么就要得到它的绝对路径才行，因此，配置文件要放到程序的内部。</p>
<p>2）name的路径问题：</p>
<ul>
<li>如果配置文件和classPath目录没关系，就必须写上绝对路径，</li>
<li>如果配置文件和classPath目录有关系，即在classPath目录中或在其子目录中（一般是资源文件夹resource），那么就得写相对路径，因为它自己了解自己属于哪个包，是相对于当前包而言的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** </span></div><div class="line">     * 类加载器不但可以加载类，也可以加载配置文件 </div><div class="line">     */  </div><div class="line">    <span class="comment">//在classpath指定的目录下逐一的查找要加载的哪个文件  </span></div><div class="line">    <span class="comment">//  注：com前不能加 / "com/Reflection/config.properties" 表示的是从根目录开始查找，  </span></div><div class="line">InputStream fileInputStream =  ReflectTest.class.getClassLoader().getResourceAsStream(<span class="string">"com/Reflection/config.properties"</span>);  </div><div class="line">  </div><div class="line">Properties properties = <span class="keyword">new</span> Properties();  </div><div class="line">properties.load(fileInputStream);  </div><div class="line">fileInputStream.close();  </div><div class="line">String className =properties.getProperty(<span class="string">"className"</span>);  </div><div class="line">ArrayList   arrayList = (ArrayList)Class.forName(className).newInstance();</div></pre></td></tr></table></figure>
<h4 id="七、Beanutils工具包操作JavaBean"><a href="#七、Beanutils工具包操作JavaBean" class="headerlink" title="七、Beanutils工具包操作JavaBean"></a>七、Beanutils工具包操作JavaBean</h4><h5 id="1-Beanutils工具包设置和读取JavaBean的属性"><a href="#1-Beanutils工具包设置和读取JavaBean的属性" class="headerlink" title="1.Beanutils工具包设置和读取JavaBean的属性"></a>1.Beanutils工具包设置和读取JavaBean的属性</h5><ul>
<li>先把工具包的类导入进来，名字commons-beanutils-current.zip</li>
<li>加jar包</li>
<li>工程右键，Build Path选择Configure Buile Path…选项卡为Libraries,Add External JARs…增加外面的jar包，这种方法是加在自己的目录下，没在工程内部，别人不能用</li>
<li>在工程建立一个lib目录，放所有类库，把jar包拷贝到目录下，点击jar包右键-&gt;Build Path-〉Add to Build Path</li>
<li>还要用到日志开发包，apache提供的日志包：commons-logging.zip</li>
</ul>
<h5 id="2-方法一"><a href="#2-方法一" class="headerlink" title="2.方法一"></a>2.方法一</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Object value=<span class="number">7</span>;<span class="comment">//不为变量没法设  </span></div><div class="line">        setProperties(pt1, prpertyName, value);  </div><div class="line">        <span class="comment">//上边set过属性，现在用工具  </span></div><div class="line">        System.out.println(BeanUtils.getProperty(pt1, <span class="string">"x"</span>).getClass().getName());<span class="comment">//结果的类型  </span></div><div class="line">        <span class="comment">/* </span></div><div class="line">         * x设置的时候是int类型的 </div><div class="line">         * 但在beanUtils里设置的时候要用字符串，返回的也用String </div><div class="line">         * beanUtils可以自动进行类型转换 </div><div class="line">         */  </div><div class="line">        BeanUtils.setProperty(pt1, <span class="string">"x"</span>, <span class="string">"9"</span>);  </div><div class="line">          </div><div class="line">        System.out.println(pt1.getX());</div></pre></td></tr></table></figure>
<h5 id="3-方法二：操作Date对象"><a href="#3-方法二：操作Date对象" class="headerlink" title="3.方法二：操作Date对象"></a>3.方法二：操作Date对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* </span></div><div class="line">        操作Date对象 </div><div class="line">         date类型有个setTime的方法 </div><div class="line">        birthday在ReflectPoint设置的 </div><div class="line">        birthday是复合属性，不是基本属性，属性的类型是对象 </div><div class="line">        把Date当成JavaBean来使用，setTime()当成time </div><div class="line">        这样就等于pt1上边的birthday的time对象赋值了 </div><div class="line">        */  </div><div class="line">        BeanUtils.setProperty(pt1, <span class="string">"birthday.time()"</span>, <span class="string">"111"</span>);  </div><div class="line">        System.out.println(BeanUtils.getProperty(pt1, <span class="string">"birthday.time()"</span>));<span class="comment">//这样的好处是支持属性链</span></div></pre></td></tr></table></figure>
<h5 id="4-方法三：BeanUtils工具不仅操作javaBean还可以操作map，map的key相当于javaBean的属性"><a href="#4-方法三：BeanUtils工具不仅操作javaBean还可以操作map，map的key相当于javaBean的属性" class="headerlink" title="4.方法三：BeanUtils工具不仅操作javaBean还可以操作map，map的key相当于javaBean的属性"></a>4.方法三：BeanUtils工具不仅操作javaBean还可以操作map，map的key相当于javaBean的属性</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Map map=&#123;name:<span class="string">"zxx"</span>,age:<span class="number">18</span>&#125;;  </div><div class="line">BeanUtils.setProperty(map, <span class="string">"name"</span>, <span class="string">"lhm"</span>);</div></pre></td></tr></table></figure>
<h5 id="5-BeanUtils和PropertyUtils的区别-BeanUtils以字符串的形式对java进行操作，PropertyUtils不需要进行转换"><a href="#5-BeanUtils和PropertyUtils的区别-BeanUtils以字符串的形式对java进行操作，PropertyUtils不需要进行转换" class="headerlink" title="5.BeanUtils和PropertyUtils的区别,BeanUtils以字符串的形式对java进行操作，PropertyUtils不需要进行转换"></a>5.BeanUtils和PropertyUtils的区别,BeanUtils以字符串的形式对java进行操作，PropertyUtils不需要进行转换</h5><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//进行类型转换  </div><div class="line">&lt;span style="color:#ff0000;"&gt;BeanUtils&lt;/span&gt;.setProperty(pt1, "birthday.time()", "111");  </div><div class="line">System.out.println(BeanUtils.getProperty(pt1, "birthday.time()"));//这样的好处是支持属性链  </div><div class="line">  </div><div class="line">  </div><div class="line">PropertyUtils.setProperty(pt1, "x", 9);  </div><div class="line">System.out.println(PropertyUtils.getProperty(pt1, "x").getClass().getName());//结果的类型  </div><div class="line">PropertyUtils.setProperty(pt1, "x", 9);  </div><div class="line">//不进行类型转化时  </div><div class="line">System.out.println(PropertyUtils.getProperty(pt1, "x").getClass());</div></pre></td></tr></table></figure>
<h4 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h4><ul>
<li><code>http://blog.csdn.net/liujiahan629629/article/details/18013523</code></li>
<li><code>http://www.cnblogs.com/lzq198754/p/5780331.html</code></li>
<li><code>http://blog.csdn.net/zuoanyinxiang/article/details/50493552</code></li>
<li><code>http://blog.csdn.net/lukyaa/article/details/8771604</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、反射的概念&quot;&gt;&lt;a href=&quot;#一、反射的概念&quot; class=&quot;headerlink&quot; title=&quot;一、反射的概念&quot;&gt;&lt;/a&gt;一、反射的概念&lt;/h4&gt;&lt;p&gt;　 　反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。&lt;/p&gt;
&lt;h4 id=&quot;二、反射提供的功能&quot;&gt;&lt;a href=&quot;#二、反射提供的功能&quot; class=&quot;headerlink&quot; title=&quot;二、反射提供的功能&quot;&gt;&lt;/a&gt;二、反射提供的功能&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在运行时判断任意一个对象所属的类；&lt;/li&gt;
&lt;li&gt;在运行时构造任意一个类的对象；&lt;/li&gt;
&lt;li&gt;在运行时判断任意一个类所具有的成员变量和方法；&lt;/li&gt;
&lt;li&gt;在运行时调用任意一个对象的方法；&lt;/li&gt;
&lt;li&gt;生成动态代理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;三、反射机制的相关API&quot;&gt;&lt;a href=&quot;#三、反射机制的相关API&quot; class=&quot;headerlink&quot; title=&quot;三、反射机制的相关API&quot;&gt;&lt;/a&gt;三、反射机制的相关API&lt;/h4&gt;&lt;h5 id=&quot;1-通过一个对象获得完整的包名和类名&quot;&gt;&lt;a href=&quot;#1-通过一个对象获得完整的包名和类名&quot; class=&quot;headerlink&quot; title=&quot;1.通过一个对象获得完整的包名和类名&quot;&gt;&lt;/a&gt;1.通过一个对象获得完整的包名和类名&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; net.xsoftlab.baike;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestReflect&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        TestReflect testReflect = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TestReflect();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(testReflect.getClass().getName());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 结果 net.xsoftlab.baike.TestReflect&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;2-获取Class类三种方法&quot;&gt;&lt;a href=&quot;#2-获取Class类三种方法&quot; class=&quot;headerlink&quot; title=&quot;2.获取Class类三种方法&quot;&gt;&lt;/a&gt;2.获取Class类三种方法&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; net.xsoftlab.baike;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestReflect&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Class&amp;lt;?&amp;gt; class1 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Class&amp;lt;?&amp;gt; class2 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Class&amp;lt;?&amp;gt; class3 = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 一般采用这种形式&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        class1 = Class.forName(&lt;span class=&quot;string&quot;&gt;&quot;net.xsoftlab.baike.TestReflect&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        class2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; TestReflect().getClass();&lt;span class=&quot;comment&quot;&gt;////java语言中任何一个java对象都有getClass 方法&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        class3 = TestReflect.class;&lt;span class=&quot;comment&quot;&gt;//java中每个类型都有class 属性.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;类名称   &quot;&lt;/span&gt; + class1.getName());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;类名称   &quot;&lt;/span&gt; + class2.getName());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;类名称   &quot;&lt;/span&gt; + class3.getName());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="反射" scheme="http://harmansecurity.cn/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>ARM Linux2.6.37中获取系统调用号</title>
    <link href="http://harmansecurity.cn/2017/05/19/ARM%20Linux2.6.37%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7/"/>
    <id>http://harmansecurity.cn/2017/05/19/ARM Linux2.6.37中获取系统调用号/</id>
    <published>2017-05-19T10:40:11.000Z</published>
    <updated>2017-05-19T11:29:25.177Z</updated>
    
    <content type="html"><![CDATA[<p> 　 　这个过程的实现基本原理是和Linux0.11差别不大的，不过一些汇编指令和系统架构还是有略微却别的，毕竟版本差异较大。Linux0.11主要是在system_call函数中实现获取系统调用号，而ARM Linux2.6.37是在软中断（vector_swi）中获取系统调用号的。下面主要说一下实现的步骤和遇到的问题。</p>
<h4 id="一、实验步骤"><a href="#一、实验步骤" class="headerlink" title="一、实验步骤"></a>一、实验步骤</h4><ul>
<li>1.在linux-2.6.37/arch/arm/kernel文件下找到entry-common.S修改源码，在软中断里面添加实现获取调用号的函数<code>bl get_syscall_num</code>。</li>
</ul>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B71.jpg" alt=""></p>
<a id="more"></a>
<ul>
<li>2.<code>get_scno.c</code>是用来实现<code>get_syscall_num</code>函数的。该文件主要是放在linux-2.6.37/arch/arm/kernel文件下。</li>
</ul>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B72.png" alt=""></p>
<ul>
<li>3.修改linux-2.6.37/arch/arm/kernel文件下的Makefile，如图所示。</li>
</ul>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B73.png" alt=""></p>
<h4 id="二、实验小结"><a href="#二、实验小结" class="headerlink" title="二、实验小结"></a>二、实验小结</h4><p> 　 　如果真正的想修改内核还是需要话功夫去研读源码的，可以先从Linux0.11开始学习。此实验的源码地址是：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/ARMLinux2.6.37%E8%8E%B7%E5%8F%96%E8%B0%83%E7%94%A8%E5%8F%B7</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 　 　这个过程的实现基本原理是和Linux0.11差别不大的，不过一些汇编指令和系统架构还是有略微却别的，毕竟版本差异较大。Linux0.11主要是在system_call函数中实现获取系统调用号，而ARM Linux2.6.37是在软中断（vector_swi）中获取系统调用号的。下面主要说一下实现的步骤和遇到的问题。&lt;/p&gt;
&lt;h4 id=&quot;一、实验步骤&quot;&gt;&lt;a href=&quot;#一、实验步骤&quot; class=&quot;headerlink&quot; title=&quot;一、实验步骤&quot;&gt;&lt;/a&gt;一、实验步骤&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1.在linux-2.6.37/arch/arm/kernel文件下找到entry-common.S修改源码，在软中断里面添加实现获取调用号的函数&lt;code&gt;bl get_syscall_num&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B71.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统调用" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="ARM Linux2.6.37" scheme="http://harmansecurity.cn/tags/ARM-Linux2-6-37/"/>
    
  </entry>
  
  <entry>
    <title>ARM Linux2.6.37系统调用原理</title>
    <link href="http://harmansecurity.cn/2017/05/19/ARM%20Linux2.6.37%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://harmansecurity.cn/2017/05/19/ARM Linux2.6.37系统调用原理/</id>
    <published>2017-05-19T10:40:11.000Z</published>
    <updated>2017-05-19T10:47:32.378Z</updated>
    
    <content type="html"><![CDATA[<p> 　 　系统调用是操作系统提供给用户（应用程序）的一组接口，每个系统调用都有一个对应的系统调用函数来完成相应的工作。用户通过这个接口向操作系统申请服务， 如访问硬件，管理进程等等。但是因为用户程序运行在用户空间，而系统调用运行在内核空间，因此用户程序不能直接调用系统调用函数，我们经常看到的比如 fork、open、write 等等函数实际上并不是真正的系统调用函数，他们都只是c库，在这些函数里将执行一个软中断 swi 指令，产生一个软中断，使CPU 陷入内核态，接着在内核中进行一系列的判断，判断出是哪个系统调用，再转到真正的系统调用函数，完成相应的功能。</p>
<h4 id="一、系统调用原理"><a href="#一、系统调用原理" class="headerlink" title="一、系统调用原理"></a>一、系统调用原理</h4><p><strong>1.entry-armv.S里面有switch软件中断的入口</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%861.png" alt=""></p>
<a id="more"></a>
<p><strong>2.调转到entry-common.S中执行vector_swi软中断指令</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%862.png" alt=""></p>
<h4 id="二、参考资料"><a href="#二、参考资料" class="headerlink" title="二、参考资料"></a>二、参考资料</h4><ul>
<li><code>http://www.linuxidc.com/Linux/2015-04/116546.htm</code></li>
<li><code>http://blog.csdn.net/tommy_wxie/article/details/7610118</code></li>
<li><code>http://blog.csdn.net/myarrow/article/details/7036266</code></li>
<li><code>http://blog.chinaunix.net/uid-28236237-id-3404140.html</code></li>
<li><code>http://blog.csdn.net/liduxun/article/details/48119849</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 　 　系统调用是操作系统提供给用户（应用程序）的一组接口，每个系统调用都有一个对应的系统调用函数来完成相应的工作。用户通过这个接口向操作系统申请服务， 如访问硬件，管理进程等等。但是因为用户程序运行在用户空间，而系统调用运行在内核空间，因此用户程序不能直接调用系统调用函数，我们经常看到的比如 fork、open、write 等等函数实际上并不是真正的系统调用函数，他们都只是c库，在这些函数里将执行一个软中断 swi 指令，产生一个软中断，使CPU 陷入内核态，接着在内核中进行一系列的判断，判断出是哪个系统调用，再转到真正的系统调用函数，完成相应的功能。&lt;/p&gt;
&lt;h4 id=&quot;一、系统调用原理&quot;&gt;&lt;a href=&quot;#一、系统调用原理&quot; class=&quot;headerlink&quot; title=&quot;一、系统调用原理&quot;&gt;&lt;/a&gt;一、系统调用原理&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.entry-armv.S里面有switch软件中断的入口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%861.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统调用" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="ARM Linux2.6.37" scheme="http://harmansecurity.cn/tags/ARM-Linux2-6-37/"/>
    
  </entry>
  
  <entry>
    <title>QEMU安装和调试运行Linux0.11</title>
    <link href="http://harmansecurity.cn/2017/05/19/QEMU%E5%AE%89%E8%A3%85%E5%92%8C%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8CLinux0.11/"/>
    <id>http://harmansecurity.cn/2017/05/19/QEMU安装和调试运行Linux0.11/</id>
    <published>2017-05-19T06:33:12.000Z</published>
    <updated>2017-05-19T06:59:36.396Z</updated>
    
    <content type="html"><![CDATA[<p> 　 　首先遇到的一个问题就是虚拟机装了VMaretools还是得用Ctrl+Alt和Ctrl+G切入切出特别麻烦，而且虚拟机和物理机不能进行复制粘贴。重新安装了VMare tools也没有用，至少能让我复制粘贴，其他倒无所谓啊。试了不少办法都没解决问题，最后发现我虚拟机和物理机不是在一个网段，我物理机的ip是：192.168.115.23。我把我虚拟机的ip也设置成一个网段，命令式：<code>sudo ifconfig eth0 192.168.115.150</code>。</p>
<h4 id="一、QEMU安装"><a href="#一、QEMU安装" class="headerlink" title="一、QEMU安装"></a>一、QEMU安装</h4><ul>
<li><p>1.<code>sudo apt-get install libsdl1.2-dev</code> (安装一些必要的库，并不只是这个，可以根据参考资料的第二个链接)</p>
</li>
<li><p>2.<code>git clone git://git.qemu-project.org/qemu.git</code></p>
</li>
<li><p>3.进入qemu的目录下面：<code>./configure --enable-debug --enable-tcg-interpreter --enable-sdl --enable-gtk --enable-debug-info --enable-kvm --enable-vnc --enable-curses --prefix=/home/wlwaq/qemu</code>（prefix如果不配置默认是usr/local/bin，配置完的话运行就需要加前缀/home/wlwaq/qemu/bin如第六步）</p>
</li>
<li><p>4.<code>sudo make -j4</code></p>
</li>
<li><p>5.<code>sudo make install</code></p>
</li>
</ul>
<a id="more"></a>
<ul>
<li>6.<code>/home/wlwaq/qemu/bin/qemu-system-x86_64  -m 16M -L /home/wlwaq/qemu/pc-bios/ -boot a -fda Image -hda hdc-0.11.img -s -S -sdl -monitor stdio</code>(qemu-system-x86_64 –help可以知道“-s -S -sdl -monitor stdio ”代表什么意思）</li>
</ul>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/QEMU%E5%AE%89%E8%A3%85%E5%92%8C%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8CLinux0.111.png" alt=""></p>
<ul>
<li>7.（qemu）c 就可以启动Linux0.11了<br>如果需要用gdb调试，可见第四个参考资料链接。调试工具有：emacs(相当于gdb的图形化界面) Trace32 insight gdb<br>安装emacs的命令：<code>sudo apt-get install emacs</code>。</li>
</ul>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/QEMU%E5%AE%89%E8%A3%85%E5%92%8C%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8CLinux0.112.png" alt=""></p>
<h4 id="二、参考资料"><a href="#二、参考资料" class="headerlink" title="二、参考资料"></a>二、参考资料</h4><ul>
<li><code>http://blog.chinaunix.net/uid-27117600-id-4148061.html</code></li>
<li><code>http://blog.csdn.net/liwugang43210/article/details/44155143</code></li>
<li><code>http://qemu-project.org/Hosts/Linux</code></li>
<li><code>http://blog.chinaunix.net/uid-26299634-id-4943500.html</code>(主要参考资料)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 　 　首先遇到的一个问题就是虚拟机装了VMaretools还是得用Ctrl+Alt和Ctrl+G切入切出特别麻烦，而且虚拟机和物理机不能进行复制粘贴。重新安装了VMare tools也没有用，至少能让我复制粘贴，其他倒无所谓啊。试了不少办法都没解决问题，最后发现我虚拟机和物理机不是在一个网段，我物理机的ip是：192.168.115.23。我把我虚拟机的ip也设置成一个网段，命令式：&lt;code&gt;sudo ifconfig eth0 192.168.115.150&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;一、QEMU安装&quot;&gt;&lt;a href=&quot;#一、QEMU安装&quot; class=&quot;headerlink&quot; title=&quot;一、QEMU安装&quot;&gt;&lt;/a&gt;一、QEMU安装&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.&lt;code&gt;sudo apt-get install libsdl1.2-dev&lt;/code&gt; (安装一些必要的库，并不只是这个，可以根据参考资料的第二个链接)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.&lt;code&gt;git clone git://git.qemu-project.org/qemu.git&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3.进入qemu的目录下面：&lt;code&gt;./configure --enable-debug --enable-tcg-interpreter --enable-sdl --enable-gtk --enable-debug-info --enable-kvm --enable-vnc --enable-curses --prefix=/home/wlwaq/qemu&lt;/code&gt;（prefix如果不配置默认是usr/local/bin，配置完的话运行就需要加前缀/home/wlwaq/qemu/bin如第六步）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4.&lt;code&gt;sudo make -j4&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;5.&lt;code&gt;sudo make install&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux0.11" scheme="http://harmansecurity.cn/tags/Linux0-11/"/>
    
      <category term="QEMU" scheme="http://harmansecurity.cn/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>Linux0.11系统调用原理</title>
    <link href="http://harmansecurity.cn/2017/05/19/Linux0.11%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://harmansecurity.cn/2017/05/19/Linux0.11系统调用原理/</id>
    <published>2017-05-19T06:20:11.000Z</published>
    <updated>2017-05-19T06:33:21.729Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、系统调用原理"><a href="#一、系统调用原理" class="headerlink" title="一、系统调用原理"></a>一、系统调用原理</h4><p>1.sys_call.s程序的功能描述：在Linux中，用户使用中断调用int 0x80和放在寄存器eax中的功能号来使用内核提供的各种功能服务，这些操作系统提供的功能被称为系统调用功能。通常用户并不是直接使用系统调用中断，而是通过函数库(例如 libc)中提供的接口函数来调用的。例如创建进程的系统调用fork可直接使用函数fork()即可。函数库libc中的fork()函数会实现对中断int 0x80的调用过程并把调用结果返回给用户程序。</p>
<p>由上可知：用户程序-&gt;libc.so-&gt;syscall-&gt;内核提供的各种服务</p>
<p>2.对于所有系统调用的实现函数，内核把他们按照系统调用功能号顺序排列成一张函数指针（地址）表（在include/linux/sys.h文件中）。然后在中断int 0x80的处理过程中根据用户提供的功能号调用对应系统调用函数进行处理。</p>
<a id="more"></a>
<p>3.程序在执行的时候首先会检查eax中的功能号是否有效(在给定的范围内)，如果无效中断返回，有效的话通过一个地址跳转表<code>(sys_call_table)</code>调用相应系统调用的函数。</p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%861.png" alt=""></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%862.png" alt=""></p>
<h4 id="二、参考资料"><a href="#二、参考资料" class="headerlink" title="二、参考资料"></a>二、参考资料</h4><ul>
<li><code>http://blog.csdn.net/sun20082567/article/details/38729561</code></li>
<li><code>http://blog.csdn.net/yhf19881015/article/details/7570354</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、系统调用原理&quot;&gt;&lt;a href=&quot;#一、系统调用原理&quot; class=&quot;headerlink&quot; title=&quot;一、系统调用原理&quot;&gt;&lt;/a&gt;一、系统调用原理&lt;/h4&gt;&lt;p&gt;1.sys_call.s程序的功能描述：在Linux中，用户使用中断调用int 0x80和放在寄存器eax中的功能号来使用内核提供的各种功能服务，这些操作系统提供的功能被称为系统调用功能。通常用户并不是直接使用系统调用中断，而是通过函数库(例如 libc)中提供的接口函数来调用的。例如创建进程的系统调用fork可直接使用函数fork()即可。函数库libc中的fork()函数会实现对中断int 0x80的调用过程并把调用结果返回给用户程序。&lt;/p&gt;
&lt;p&gt;由上可知：用户程序-&amp;gt;libc.so-&amp;gt;syscall-&amp;gt;内核提供的各种服务&lt;/p&gt;
&lt;p&gt;2.对于所有系统调用的实现函数，内核把他们按照系统调用功能号顺序排列成一张函数指针（地址）表（在include/linux/sys.h文件中）。然后在中断int 0x80的处理过程中根据用户提供的功能号调用对应系统调用函数进行处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统调用" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="Linux0.11" scheme="http://harmansecurity.cn/tags/Linux0-11/"/>
    
  </entry>
  
  <entry>
    <title>用户态和内核态</title>
    <link href="http://harmansecurity.cn/2017/05/19/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"/>
    <id>http://harmansecurity.cn/2017/05/19/用户态和内核态/</id>
    <published>2017-05-19T04:32:28.000Z</published>
    <updated>2017-05-19T04:39:28.808Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、用户态和内核态的区别"><a href="#一、用户态和内核态的区别" class="headerlink" title="一、用户态和内核态的区别"></a>一、用户态和内核态的区别</h4><p>　 　当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程 的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。</p>
<p>　 　内核态与用户态是操作系统的两种运行级别, 跟intel cpu没有必然的联系, intel cpu提供Ring0-Ring3三种级别的运行模式，Ring0级别高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部 分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必 须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。</p>
<p>　 　至于说保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据。</p>
<a id="more"></a>
<h4 id="二、用户态和内核态的转换"><a href="#二、用户态和内核态的转换" class="headerlink" title="二、用户态和内核态的转换"></a>二、用户态和内核态的转换</h4><p><strong>用户态切换到内核态的3种方式</strong></p>
<ul>
<li><p>a. 系统调用<br>　 　这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使 用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户 特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
</li>
<li><p>b. 异常<br>　 　当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</li>
<li><p>c. 外围设备的中断<br>　 　当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会 暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到 内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</li>
</ul>
<p>　 　这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p>
<h4 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h4><ul>
<li><code>http://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html</code></li>
<li><code>http://blog.csdn.net/tommy_wxie/article/details/17122923/</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、用户态和内核态的区别&quot;&gt;&lt;a href=&quot;#一、用户态和内核态的区别&quot; class=&quot;headerlink&quot; title=&quot;一、用户态和内核态的区别&quot;&gt;&lt;/a&gt;一、用户态和内核态的区别&lt;/h4&gt;&lt;p&gt;　 　当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程 的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。&lt;/p&gt;
&lt;p&gt;　 　内核态与用户态是操作系统的两种运行级别, 跟intel cpu没有必然的联系, intel cpu提供Ring0-Ring3三种级别的运行模式，Ring0级别高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部 分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必 须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。&lt;/p&gt;
&lt;p&gt;　 　至于说保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="用户态" scheme="http://harmansecurity.cn/tags/%E7%94%A8%E6%88%B7%E6%80%81/"/>
    
      <category term="内核态" scheme="http://harmansecurity.cn/tags/%E5%86%85%E6%A0%B8%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux0.11内核添加系统调用</title>
    <link href="http://harmansecurity.cn/2017/05/19/Linux0.11%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://harmansecurity.cn/2017/05/19/Linux0.11内核添加系统调用/</id>
    <published>2017-05-19T03:18:32.000Z</published>
    <updated>2017-05-19T03:37:12.521Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、实验步骤"><a href="#一、实验步骤" class="headerlink" title="一、实验步骤"></a>一、实验步骤</h4><p><strong>1.首先在linux0.11/lib下添加两个文件：writeeax.c,readeax.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__     !一边是两个下滑线</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line">_syscall0(<span class="keyword">int</span>,writeeax)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__     !一边是两个下滑线</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line">_syscall0(<span class="keyword">int</span>,readeax)</div></pre></td></tr></table></figure>
<p><strong>2.接下来修改linux0.11/include下的unistd.h，添加两个系统调用号</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_writeeax 72   !NR前面2个_，72是比里面最大的调用号大1个数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readeax 73</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeeax</span><span class="params">(<span class="keyword">void</span>)</span></span>;    !在linux/include/unistd.h文件最下面添加</div><div class="line"><span class="function">Int <span class="title">readeax</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>3.接着在linux/include/linux下的sys.h添加</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_writeeax</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_readeax</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">!Sys.h下面的sys_call_table[]里面到末尾按顺序添加：</div><div class="line"></div><div class="line">sys_writeeax,sys_readeax</div></pre></td></tr></table></figure>
<p><strong>4.到linux/kernel下编写一个mysys.c文件实现添加的两个系统调用函数</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A81.png" alt=""></p>
<p><strong>5.修改linux/kernel/Makefile最后面添加mysys.o</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A83.png" alt=""></p>
<p><strong>6.编写测试函数test.c</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A82.png" alt=""></p>
<h4 id="二、实验总结"><a href="#二、实验总结" class="headerlink" title="二、实验总结"></a>二、实验总结</h4><p>　 　在内核里面添加系统调用的基本步骤就是上面这几步，如果需要更深的了解还是需要好好找本内核的书《Linux内核完全剖析》来阅读，了解其中的原理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、实验步骤&quot;&gt;&lt;a href=&quot;#一、实验步骤&quot; class=&quot;headerlink&quot; title=&quot;一、实验步骤&quot;&gt;&lt;/a&gt;一、实验步骤&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.首先在linux0.11/lib下添加两个文件：writeeax.c,readeax.c&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; __LIBRARY__     !一边是两个下滑线&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_syscall0(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;,writeeax)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; __LIBRARY__     !一边是两个下滑线&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_syscall0(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;,readeax)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2.接下来修改linux0.11/include下的unistd.h，添加两个系统调用号&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; __NR_writeeax 72   !NR前面2个_，72是比里面最大的调用号大1个数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; __NR_readeax 73&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;writeeax&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;    !在linux/include/unistd.h文件最下面添加&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Int &lt;span class=&quot;title&quot;&gt;readeax&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="系统调用" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="Linux0.11" scheme="http://harmansecurity.cn/tags/Linux0-11/"/>
    
  </entry>
  
  <entry>
    <title>Linux0.11获取系统调用号</title>
    <link href="http://harmansecurity.cn/2017/05/19/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7/"/>
    <id>http://harmansecurity.cn/2017/05/19/Linux0.11获取系统调用号/</id>
    <published>2017-05-19T03:02:21.000Z</published>
    <updated>2017-05-19T11:28:51.562Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、实验步骤"><a href="#一、实验步骤" class="headerlink" title="一、实验步骤"></a>一、实验步骤</h4><p><strong>1.修改linux0.11/kernel/sys_call.s添加call achieveEax</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B71.png" alt=""></p>
<p><strong>2.在linux0.11/kernel底下添加achieveEax.c文件</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B72.png" alt=""></p>
<a id="more"></a>
<p><strong>3.修改linux0.11/kernel/Makefile添加achieveEax.o</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B73.png" alt=""></p>
<p><strong>4.最后的运行结果</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B74.png" alt=""></p>
<h4 id="二、实验平台"><a href="#二、实验平台" class="headerlink" title="二、实验平台"></a>二、实验平台</h4><ul>
<li>1.实验平台源码：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/hit-oslab-linux-20110823/oslab</code></li>
<li>2.获取调用号源码：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7</code></li>
<li>3.实验平台使用：到“实验楼”搜索“操作系统原理与实践”：<code>https://www.shiyanlou.com/courses/115</code>,将第一个实验做一下就知道该如何使用平台了，这里不再赘述。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、实验步骤&quot;&gt;&lt;a href=&quot;#一、实验步骤&quot; class=&quot;headerlink&quot; title=&quot;一、实验步骤&quot;&gt;&lt;/a&gt;一、实验步骤&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.修改linux0.11/kernel/sys_call.s添加call achieveEax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B71.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.在linux0.11/kernel底下添加achieveEax.c文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B72.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux0.11" scheme="http://harmansecurity.cn/tags/Linux0-11/"/>
    
      <category term="系统调用号" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Bochs运行Linux0.11内核</title>
    <link href="http://harmansecurity.cn/2017/05/19/Bochs%E8%BF%90%E8%A1%8CLinux0.11%E5%86%85%E6%A0%B8/"/>
    <id>http://harmansecurity.cn/2017/05/19/Bochs运行Linux0.11内核/</id>
    <published>2017-05-19T02:36:21.000Z</published>
    <updated>2017-05-19T11:32:08.383Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Bochs安装"><a href="#一、Bochs安装" class="headerlink" title="一、Bochs安装"></a>一、Bochs安装</h4><p><strong>1.手动安装</strong></p>
<p>具体的安装步骤可以参考这篇博客，很详细：<code>http://os.51cto.com/art/201407/446838_all.htm</code></p>
<p>安装过程中遇到的一个小问题：</p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Bochs%E8%BF%90%E8%A1%8CLinux0.11%E5%86%85%E6%A0%B8.png" alt=""></p>
<p>解决方法：我的解决方法与博客里面提到的不一样：打开Makefile文件，找到<code>X_LIBS=</code> 添加“-lpthread” 即 <code>X_LIBS=-lpthread.S</code></p>
<p><strong>2.源安装</strong></p>
<p>安装本身源里面的bochs:<code>sudo apt-get install bochs</code></p>
<a id="more"></a>
<h4 id="二、编译Linux0-11内核"><a href="#二、编译Linux0-11内核" class="headerlink" title="二、编译Linux0.11内核"></a>二、编译Linux0.11内核</h4><ul>
<li>1.进入linux-0.11目录下：make 会提示: make：as86:命令未找到。解决办法是：<code>sudo apt-get install bin86</code></li>
<li>2.因为我是64位的机器所以会报这样的错误：<code>boot/head.s :Error...........</code>。解决方法：在Makefile的as后面加 <code>--32</code>，注意“–”前面有空格；CFLAGS中加-m32，注意这个无空格。</li>
</ul>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>　 　在Linux0.11编译的过程中会遇到很多问题，再加上Ubuntu各版本不同，需要耐心的解决。可编译成功的源码：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/Linux-0.11-master</code>。与bochs集成的Linux0.11编译开发环境：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/linux-0.11-devel-040809</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、Bochs安装&quot;&gt;&lt;a href=&quot;#一、Bochs安装&quot; class=&quot;headerlink&quot; title=&quot;一、Bochs安装&quot;&gt;&lt;/a&gt;一、Bochs安装&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.手动安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体的安装步骤可以参考这篇博客，很详细：&lt;code&gt;http://os.51cto.com/art/201407/446838_all.htm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装过程中遇到的一个小问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/Bochs%E8%BF%90%E8%A1%8CLinux0.11%E5%86%85%E6%A0%B8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;解决方法：我的解决方法与博客里面提到的不一样：打开Makefile文件，找到&lt;code&gt;X_LIBS=&lt;/code&gt; 添加“-lpthread” 即 &lt;code&gt;X_LIBS=-lpthread.S&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.源安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装本身源里面的bochs:&lt;code&gt;sudo apt-get install bochs&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Bochs" scheme="http://harmansecurity.cn/tags/Bochs/"/>
    
      <category term="Linux0.11" scheme="http://harmansecurity.cn/tags/Linux0-11/"/>
    
  </entry>
  
  <entry>
    <title>系统调用hook技术总结</title>
    <link href="http://harmansecurity.cn/2017/05/19/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8Hook%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://harmansecurity.cn/2017/05/19/系统调用Hook技术总结/</id>
    <published>2017-05-19T02:13:21.000Z</published>
    <updated>2017-05-19T11:25:37.538Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、系统调用原理"><a href="#一、系统调用原理" class="headerlink" title="一、系统调用原理"></a>一、系统调用原理</h4><p>　 　Linux中实现系统调用时是利用了i386体系结构中的软中断，通过产生0x80中 断，使程序由用户态进入内核态执行系统调用函数。当系统调用发生时，产生0x80中断，CPU被切换到内核态执行中断向量表IDT对应的0x80中断处理函数，即跳转到了system_call()的入口，system_call()函数检查系统调用号，到系统调用表sys_call_table中找到该 系统调用（号）对应的内核函数入口，接着调用这个内核函数，然后返回。</p>
<p>终端输入：<code>sudo cat /proc/kallsyms | grep sys_call_table</code></p>
<p>终端输出：<code>ffffffff81a001c0 R sys_call_table</code></p>
<p>由上面可发现其中 R 直接显示了这段内存是只读的性质，这就引出了第二步骤“取消页读写保护”。</p>
<p><strong>整理出来的系统调用hook参考链接：</strong>(对hook感兴趣的可以了解下)</p>
<ul>
<li><code>http://www.tuicool.com/articles/nEnm2u</code></li>
<li><code>http://blog.csdn.net/maochengtao/article/details/23598433</code></li>
<li><code>http://blog.csdn.net/force_eagle/article/details/3938150</code></li>
<li><code>http://blog.chinaunix.net/uid-9164976-id-2435342.html</code></li>
<li><code>http://blog.chinaunix.net/uid-7330656-id-2644670.html</code></li>
<li><code>http://www.oschina.net/code/snippet_54100_1509</code></li>
<li><code>http://blog.sina.com.cn/s/blog_a2acdfc70100zqa7.html</code></li>
<li><code>http://blog.csdn.net/sun20082567/article/details/38729561</code></li>
</ul>
<a id="more"></a>
<h4 id="二、相关技术学习-C语言内联汇编的学习"><a href="#二、相关技术学习-C语言内联汇编的学习" class="headerlink" title="二、相关技术学习(C语言内联汇编的学习)"></a>二、相关技术学习(C语言内联汇编的学习)</h4><ul>
<li><code>http://www.nagain.com/activity/article/18/</code></li>
<li><code>http://blog.csdn.net/liuqiaoyu080512/article/details/8457528</code></li>
<li><code>http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</code></li>
</ul>
<h4 id="三、naked函数"><a href="#三、naked函数" class="headerlink" title="三、naked函数"></a>三、naked函数</h4><p>　 　naked函数，即所谓的“裸函数”，对于这种函数，编译器不会生成任何函数入口代码和退出代码。这种函数一般应用在与操作系统内核相关的代码中，如中断处理函数、钩子函数等。 naked 特性仅适用于 x86和ARM，并不用于 x64 。</p>
<p><code>__attribute__((naked)) void  test()</code></p>
<p><strong>参考资料：</strong></p>
<ul>
<li><code>http://blog.atelier39.org/compiler_disasm/94.html</code></li>
<li><code>http://www.cnblogs.com/jiu0821/p/4507281.html</code>  </li>
</ul>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>　 　上面的参考链接对我当时学习系统调用hook技术有很大帮助，这里整理出来分享给大家。</p>
<p>　 　<strong>源码地址是：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/hookdemo</code></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、系统调用原理&quot;&gt;&lt;a href=&quot;#一、系统调用原理&quot; class=&quot;headerlink&quot; title=&quot;一、系统调用原理&quot;&gt;&lt;/a&gt;一、系统调用原理&lt;/h4&gt;&lt;p&gt;　 　Linux中实现系统调用时是利用了i386体系结构中的软中断，通过产生0x80中 断，使程序由用户态进入内核态执行系统调用函数。当系统调用发生时，产生0x80中断，CPU被切换到内核态执行中断向量表IDT对应的0x80中断处理函数，即跳转到了system_call()的入口，system_call()函数检查系统调用号，到系统调用表sys_call_table中找到该 系统调用（号）对应的内核函数入口，接着调用这个内核函数，然后返回。&lt;/p&gt;
&lt;p&gt;终端输入：&lt;code&gt;sudo cat /proc/kallsyms | grep sys_call_table&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;终端输出：&lt;code&gt;ffffffff81a001c0 R sys_call_table&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由上面可发现其中 R 直接显示了这段内存是只读的性质，这就引出了第二步骤“取消页读写保护”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整理出来的系统调用hook参考链接：&lt;/strong&gt;(对hook感兴趣的可以了解下)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://www.tuicool.com/articles/nEnm2u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.csdn.net/maochengtao/article/details/23598433&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.csdn.net/force_eagle/article/details/3938150&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.chinaunix.net/uid-9164976-id-2435342.html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.chinaunix.net/uid-7330656-id-2644670.html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://www.oschina.net/code/snippet_54100_1509&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.sina.com.cn/s/blog_a2acdfc70100zqa7.html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.csdn.net/sun20082567/article/details/38729561&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="系统调用" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="hook" scheme="http://harmansecurity.cn/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>2017年4月小结</title>
    <link href="http://harmansecurity.cn/2017/05/03/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%93/"/>
    <id>http://harmansecurity.cn/2017/05/03/2017年4月小结/</id>
    <published>2017-05-03T13:19:31.000Z</published>
    <updated>2017-05-04T04:48:48.785Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近一直在忙于看书和完成自己制定计划的第二阶段，没时间写博客。刚刚参加完“感动师大”的晚会，内心思绪万千，也对上个月做个小结。三月份的时候，对自己未来想要做什么有了一个大概的认识，制定了接下来要完成的相关计划。</p>
<ul>
<li>第一阶段(2017.3.19-2017.4.10)：Java基础学习(深入),将某马的Java基础视频教程撸了一遍，记满了一个笔记本。对“反射”、“并发”、“多线程”、“IO流”、“序列化”、“集合泛型”等知识点又有了一个新的认识。期间也阅读了&lt;&lt;重构&gt;&gt;以及电子版的&lt;&lt; head first Java &gt;&gt;。原本想对每节基础课都写个博客，只是时间不允许，所以相关知识点都记在了笔记本上，这里直接放图啦啊，字写的有点潦草(⊙o⊙)。<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%931.jpg" alt=""><br></div>

</li>
</ul>
<a id="more"></a>
<ul>
<li>第二阶段(2017.4.10-2017.5.15)：JavaWeb学习+(SpringMvc+MyBatics)，期间看了《代码整洁之道》、《Java多线程编程核心技术》、《深入理解Java虚拟机》(前两章)、《Java核心技术基础知识》并发这一章节。<br>　　<br>　　前两个阶段的学习算是对以前学习的查漏补缺、巩固、总结，长时间不用很多都遗忘了。接下里的学习计划是阅读相关书籍(每个阶段根据计划内容阅读相关书籍)、学习分布式、框架详细研究、做算法题、项目开发。前两个阶段偏重于理论的学习，接下来的计划安排里应该会侧重于实践，把所看的书里面的知识点尽量能在项目中实现，这样体会更深刻。下面是劳动节前夕买的书，利用放假充裕的时间看书，哈哈。<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%932.jpg" alt=""><br></div><br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%933.jpg" alt=""><br></div><br>　　因为阿里、网易在杭州，目标一直都是阿里，所以很想去杭州看看。趁着第一阶段的计划完成，四月的中旬去了趟杭州，玩了西湖、西溪湿地以及河坊街。原来杭州也很挤啊，人好多，总体感觉还行。不怎么喜欢拍照，室友都说我老，这里我厚着脸皮放一张照片为了证明我并不是那么丑，难道是我眼光的问题？<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%934.jpg" alt=""><br></div><br>　　来了师大这么久，很少参加活动，今天被邀请参加“感动师大”，真的是思绪万千，对师大人又有了一个新的认识，身边还是有很多优秀的人值得我们去学习，他们的精神我们也应该拥有。”知其然，知其所以然。”是自己的终极目标。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　最近一直在忙于看书和完成自己制定计划的第二阶段，没时间写博客。刚刚参加完“感动师大”的晚会，内心思绪万千，也对上个月做个小结。三月份的时候，对自己未来想要做什么有了一个大概的认识，制定了接下来要完成的相关计划。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段(2017.3.19-2017.4.10)：Java基础学习(深入),将某马的Java基础视频教程撸了一遍，记满了一个笔记本。对“反射”、“并发”、“多线程”、“IO流”、“序列化”、“集合泛型”等知识点又有了一个新的认识。期间也阅读了&amp;lt;&amp;lt;重构&amp;gt;&amp;gt;以及电子版的&amp;lt;&amp;lt; head first Java &amp;gt;&amp;gt;。原本想对每节基础课都写个博客，只是时间不允许，所以相关知识点都记在了笔记本上，这里直接放图啦啊，字写的有点潦草(⊙o⊙)。&lt;div align=center&gt;&lt;br&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%931.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://harmansecurity.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="小结" scheme="http://harmansecurity.cn/tags/%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(九)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%20/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(九) /</id>
    <published>2017-03-19T14:52:21.000Z</published>
    <updated>2017-03-19T15:18:22.554Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<code>http://bbs.itheima.com/thread-270994-1-1.html</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接：&lt;code&gt;http://bbs.itheima.com/thread-270994-1-1.html&lt;/code&gt;&lt;/p&gt;

    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多态" scheme="http://harmansecurity.cn/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="抽象类" scheme="http://harmansecurity.cn/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
      <category term="接口" scheme="http://harmansecurity.cn/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(八)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(八)/</id>
    <published>2017-03-19T14:45:21.000Z</published>
    <updated>2017-03-19T15:18:12.209Z</updated>
    
    <content type="html"><![CDATA[<h3 id="08-01-面向对象-代码块的概述和分类-了解-面试的时候会问-开发不用或者很少用"><a href="#08-01-面向对象-代码块的概述和分类-了解-面试的时候会问-开发不用或者很少用" class="headerlink" title="08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用)"></a>08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用)</h3><ul>
<li>A:代码块概述<ul>
<li>在Java中，使用{}括起来的代码被称为代码块。</li>
</ul>
</li>
<li>B:代码块分类<ul>
<li>根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。</li>
</ul>
</li>
<li>C:常见代码块的应用<ul>
<li>a:局部代码块 <ul>
<li>在方法中出现；限定变量生命周期，及早释放，提高内存利用率</li>
</ul>
</li>
<li>b:构造代码块 (初始化块)<ul>
<li>在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</li>
</ul>
</li>
<li>c:静态代码块 <ul>
<li>在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。</li>
<li>一般用于加载驱动</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="08-02-面向对象-代码块的面试题-掌握"><a href="#08-02-面向对象-代码块的面试题-掌握" class="headerlink" title="08.02_面向对象(代码块的面试题)(掌握)"></a>08.02_面向对象(代码块的面试题)(掌握)</h3><ul>
<li>A:看程序写结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Student &#123;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;Student 静态代码块&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">		System.out.println(&quot;Student 构造代码块&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Student() &#123;</div><div class="line">		System.out.println(&quot;Student 构造方法&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">class Demo2_Student &#123;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;Demo2_Student静态代码块&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(&quot;我是main方法&quot;);</div><div class="line">		</div><div class="line">		Student s1 = new Student();</div><div class="line">		Student s2 = new Student();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="08-03-面向对象-继承案例演示-掌握"><a href="#08-03-面向对象-继承案例演示-掌握" class="headerlink" title="08.03_面向对象(继承案例演示)(掌握)"></a>08.03_面向对象(继承案例演示)(掌握)</h3><ul>
<li>A:继承(extends)<ul>
<li>让类与类之间产生关系,子父类关系 </li>
</ul>
</li>
<li>B:继承案例演示：<ul>
<li>动物类,猫类,狗类</li>
<li>定义两个属性(颜色,腿的个数)两个功能(吃饭，睡觉)</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>使用继承前</li>
</ul>
</li>
<li>D:案例演示<ul>
<li>使用继承后</li>
</ul>
</li>
</ul>
<h3 id="08-04-面向对象-继承的好处和弊端-掌握"><a href="#08-04-面向对象-继承的好处和弊端-掌握" class="headerlink" title="08.04_面向对象(继承的好处和弊端)(掌握)"></a>08.04_面向对象(继承的好处和弊端)(掌握)</h3><ul>
<li>A:继承的好处<ul>
<li>a:提高了代码的复用性</li>
<li>b:提高了代码的维护性</li>
<li>c:让类与类之间产生了关系，是多态的前提</li>
</ul>
</li>
<li><p>B:继承的弊端</p>
<ul>
<li><p>类的耦合性增强了。</p>
</li>
<li><p>开发的原则：高内聚，低耦合。</p>
</li>
<li>耦合：类与类的关系</li>
<li>内聚：就是自己完成某件事情的能力</li>
</ul>
</li>
</ul>
<h3 id="08-05-面向对象-Java中类的继承特点-掌握"><a href="#08-05-面向对象-Java中类的继承特点-掌握" class="headerlink" title="08.05_面向对象(Java中类的继承特点)(掌握)"></a>08.05_面向对象(Java中类的继承特点)(掌握)</h3><ul>
<li>A:Java中类的继承特点<ul>
<li>a:Java只支持单继承，不支持多继承。(一个儿子只能有一个爹)<ul>
<li>有些语言是支持多继承，格式：extends 类1,类2,…</li>
</ul>
</li>
<li>b:Java支持多层继承(继承体系)</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>Java中类的继承特点<ul>
<li>如果想用这个体系的所有功能用最底层的类创建对象</li>
<li>如果想看这个体系的共性功能,看最顶层的类 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="08-06-面向对象-继承的注意事项和什么时候使用继承-掌握"><a href="#08-06-面向对象-继承的注意事项和什么时候使用继承-掌握" class="headerlink" title="08.06_面向对象(继承的注意事项和什么时候使用继承)(掌握)"></a>08.06_面向对象(继承的注意事项和什么时候使用继承)(掌握)</h3><ul>
<li>A:继承的注意事项<ul>
<li>a:子类只能继承父类所有非私有的成员(成员方法和成员变量)</li>
<li>b:子类不能继承父类的构造方法，但是可以通过super(马上讲)关键字去访问父类构造方法。</li>
<li>c:不要为了部分功能而去继承</li>
<li>项目经理 姓名 工号 工资 奖金</li>
<li>程序员    姓名 工号 工资</li>
</ul>
</li>
<li><p>B:什么时候使用继承</p>
<ul>
<li><p>继承其实体现的是一种关系：”is a”。<br>  Person</p>
<pre><code>Student
Teacher
</code></pre><p>  水果</p>
<pre><code>苹果
香蕉
橘子
</code></pre><p>采用假设法。<br>  如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。</p>
</li>
</ul>
</li>
</ul>
<h3 id="08-07-面向对象-继承中成员变量的关系-掌握"><a href="#08-07-面向对象-继承中成员变量的关系-掌握" class="headerlink" title="08.07_面向对象(继承中成员变量的关系)(掌握)"></a>08.07_面向对象(继承中成员变量的关系)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>a:不同名的变量</li>
<li>b:同名的变量<br>###08.08_面向对象(this和super的区别和应用)(掌握)</li>
</ul>
</li>
<li>A:this和super都代表什么<ul>
<li>this:代表当前对象的引用,谁来调用我,我就代表谁</li>
<li>super:代表当前对象父类的引用</li>
</ul>
</li>
<li>B:this和super的使用区别<ul>
<li>a:调用成员变量<ul>
<li>this.成员变量 调用本类的成员变量,也可以调用父类的成员变量</li>
<li>super.成员变量 调用父类的成员变量</li>
</ul>
</li>
<li>b:调用构造方法<ul>
<li>this(…)    调用本类的构造方法</li>
<li>super(…)    调用父类的构造方法</li>
</ul>
</li>
<li>c:调用成员方法<ul>
<li>this.成员方法 调用本类的成员方法,也可以调用父类的方法</li>
<li>super.成员方法 调用父类的成员方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="08-09-面向对象-继承中构造方法的关系-掌握"><a href="#08-09-面向对象-继承中构造方法的关系-掌握" class="headerlink" title="08.09_面向对象(继承中构造方法的关系)(掌握)"></a>08.09_面向对象(继承中构造方法的关系)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>子类中所有的构造方法默认都会访问父类中空参数的构造方法</li>
</ul>
</li>
<li><p>B:为什么呢?</p>
<ul>
<li>因为子类会继承父类中的数据，可能还会使用父类的数据。</li>
<li><p>所以，子类初始化之前，一定要先完成父类数据的初始化。</p>
</li>
<li><p>其实：</p>
<ul>
<li>每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="08-10-面向对象-继承中构造方法的注意事项-掌握"><a href="#08-10-面向对象-继承中构造方法的注意事项-掌握" class="headerlink" title="08.10_面向对象(继承中构造方法的注意事项)(掌握)"></a>08.10_面向对象(继承中构造方法的注意事项)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>父类没有无参构造方法,子类怎么办?</li>
<li>super解决</li>
<li>this解决</li>
</ul>
</li>
<li>B:注意事项<ul>
<li>super(…)或者this(….)必须出现在构造方法的第一条语句上</li>
</ul>
</li>
</ul>
<h3 id="08-11-面向对象-继承中的面试题-掌握"><a href="#08-11-面向对象-继承中的面试题-掌握" class="headerlink" title="08.11_面向对象(继承中的面试题)(掌握)"></a>08.11_面向对象(继承中的面试题)(掌握)</h3><ul>
<li>A:案例演示</li>
<li><p>看程序写结果1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Fu&#123;</div><div class="line">	public int num = 10;</div><div class="line">	public Fu()&#123;</div><div class="line">		System.out.println(&quot;fu&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Zi extends Fu&#123;</div><div class="line">	public int num = 20;</div><div class="line">	public Zi()&#123;</div><div class="line">		System.out.println(&quot;zi&quot;);</div><div class="line">	&#125;</div><div class="line">	public void show()&#123;</div><div class="line">		int num = 30;</div><div class="line">		System.out.println(num);</div><div class="line">		System.out.println(this.num);</div><div class="line">		System.out.println(super.num);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Test1_Extends &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Zi z = new Zi();</div><div class="line">		z.show();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看程序写结果2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Fu &#123;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;静态代码块Fu&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">		System.out.println(&quot;构造代码块Fu&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Fu() &#123;</div><div class="line">		System.out.println(&quot;构造方法Fu&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">class Zi extends Fu &#123;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;静态代码块Zi&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">		System.out.println(&quot;构造代码块Zi&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Zi() &#123;</div><div class="line">		System.out.println(&quot;构造方法Zi&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">Zi z = new Zi(); 请执行结果。</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="08-12-面向对象-继承中成员方法关系-掌握"><a href="#08-12-面向对象-继承中成员方法关系-掌握" class="headerlink" title="08.12_面向对象(继承中成员方法关系)(掌握)"></a>08.12_面向对象(继承中成员方法关系)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>a:不同名的方法</li>
<li>b:同名的方法</li>
</ul>
</li>
</ul>
<h3 id="08-13-面向对象-方法重写概述及其应用-掌握"><a href="#08-13-面向对象-方法重写概述及其应用-掌握" class="headerlink" title="08.13_面向对象(方法重写概述及其应用)(掌握)"></a>08.13_面向对象(方法重写概述及其应用)(掌握)</h3><ul>
<li>A:什么是方法重写<ul>
<li>重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) </li>
</ul>
</li>
<li>B:方法重写的应用：<ul>
<li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>a:定义一个手机类。</li>
</ul>
</li>
</ul>
<h3 id="08-14-面向对象-方法重写的注意事项-掌握"><a href="#08-14-面向对象-方法重写的注意事项-掌握" class="headerlink" title="08.14_面向对象(方法重写的注意事项)(掌握)"></a>08.14_面向对象(方法重写的注意事项)(掌握)</h3><ul>
<li><p>A:方法重写注意事项</p>
<ul>
<li>a:父类中私有方法不能被重写<ul>
<li>因为父类私有方法子类根本就无法继承</li>
</ul>
</li>
<li>b:子类重写父类方法时，访问权限不能更低<ul>
<li>最好就一致</li>
</ul>
</li>
<li><p>c:父类静态方法，子类也必须通过静态方法进行重写</p>
<ul>
<li>其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态)</li>
</ul>
</li>
<li><p>子类重写父类方法的时候，最好声明一模一样。</p>
</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>方法重写注意事项</li>
</ul>
</li>
</ul>
<h3 id="08-15-面向对象-方法重写的面试题-掌握"><a href="#08-15-面向对象-方法重写的面试题-掌握" class="headerlink" title="08.15_面向对象(方法重写的面试题)(掌握)"></a>08.15_面向对象(方法重写的面试题)(掌握)</h3><ul>
<li><p>A:方法重写的面试题</p>
<ul>
<li>Override和Overload的区别?Overload能改变返回值类型吗?</li>
<li>overload可以改变返回值类型,只看参数列表</li>
<li><p>方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的</p>
</li>
<li><p>方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。</p>
</li>
<li><p>子类对象调用方法的时候：</p>
<ul>
<li>先找子类本身，再找父类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="08-16-面向对象-使用继承前的学生和老师案例-掌握"><a href="#08-16-面向对象-使用继承前的学生和老师案例-掌握" class="headerlink" title="08.16_面向对象(使用继承前的学生和老师案例)(掌握)"></a>08.16_面向对象(使用继承前的学生和老师案例)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>使用继承前的学生和老师案例</li>
<li>属性:姓名,年龄</li>
<li>行为:吃饭</li>
<li>老师有特有的方法:讲课</li>
<li>学生有特有的方法:学习</li>
</ul>
</li>
</ul>
<h3 id="08-17-面向对象-使用继承后的学生和老师案例-掌握"><a href="#08-17-面向对象-使用继承后的学生和老师案例-掌握" class="headerlink" title="08.17_面向对象(使用继承后的学生和老师案例)(掌握)"></a>08.17_面向对象(使用继承后的学生和老师案例)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>使用继承后的学生和老师案例</li>
</ul>
</li>
</ul>
<h3 id="08-18-面向对象-猫狗案例分析-实现及测试-掌握"><a href="#08-18-面向对象-猫狗案例分析-实现及测试-掌握" class="headerlink" title="08.18_面向对象(猫狗案例分析,实现及测试)(掌握)"></a>08.18_面向对象(猫狗案例分析,实现及测试)(掌握)</h3><ul>
<li>A:猫狗案例分析</li>
<li>B:案例演示<ul>
<li>猫狗案例继承版</li>
<li>属性:毛的颜色,腿的个数</li>
<li>行为:吃饭</li>
<li>猫特有行为:抓老鼠catchMouse</li>
<li>狗特有行为:看家lookHome</li>
</ul>
</li>
</ul>
<h3 id="08-19-面向对象-final关键字修饰类-方法以及变量的特点-掌握"><a href="#08-19-面向对象-final关键字修饰类-方法以及变量的特点-掌握" class="headerlink" title="08.19_面向对象(final关键字修饰类,方法以及变量的特点)(掌握)"></a>08.19_面向对象(final关键字修饰类,方法以及变量的特点)(掌握)</h3><ul>
<li>A:final概述</li>
<li>B:final修饰特点<ul>
<li>修饰类，类不能被继承</li>
<li>修饰变量，变量就变成了常量，只能被赋值一次</li>
<li>修饰方法，方法不能被重写</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>final修饰特点</li>
</ul>
</li>
</ul>
<h3 id="08-20-面向对象-final关键字修饰局部变量-掌握"><a href="#08-20-面向对象-final关键字修饰局部变量-掌握" class="headerlink" title="08.20_面向对象(final关键字修饰局部变量)(掌握)"></a>08.20_面向对象(final关键字修饰局部变量)(掌握)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li><p>方法内部或者方法声明上都演示一下(了解)</p>
</li>
<li><p>基本类型，是值不能被改变</p>
</li>
<li>引用类型，是地址值不能被改变,对象中的属性可以改变</li>
</ul>
</li>
</ul>
<h3 id="08-21-面向对象-final修饰变量的初始化时机-掌握"><a href="#08-21-面向对象-final修饰变量的初始化时机-掌握" class="headerlink" title="08.21_面向对象(final修饰变量的初始化时机)(掌握)"></a>08.21_面向对象(final修饰变量的初始化时机)(掌握)</h3><ul>
<li>A:final修饰变量的初始化时机<ul>
<li>显示初始化 </li>
<li>在对象构造完毕前即可</li>
</ul>
</li>
</ul>
<h3 id="08-22-day08总结"><a href="#08-22-day08总结" class="headerlink" title="08.22_day08总结"></a>08.22_day08总结</h3><ul>
<li>把今天的知识点总结一遍。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;08-01-面向对象-代码块的概述和分类-了解-面试的时候会问-开发不用或者很少用&quot;&gt;&lt;a href=&quot;#08-01-面向对象-代码块的概述和分类-了解-面试的时候会问-开发不用或者很少用&quot; class=&quot;headerlink&quot; title=&quot;08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用)&quot;&gt;&lt;/a&gt;08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:代码块概述&lt;ul&gt;
&lt;li&gt;在Java中，使用{}括起来的代码被称为代码块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:代码块分类&lt;ul&gt;
&lt;li&gt;根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C:常见代码块的应用&lt;ul&gt;
&lt;li&gt;a:局部代码块 &lt;ul&gt;
&lt;li&gt;在方法中出现；限定变量生命周期，及早释放，提高内存利用率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;b:构造代码块 (初始化块)&lt;ul&gt;
&lt;li&gt;在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;c:静态代码块 &lt;ul&gt;
&lt;li&gt;在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。&lt;/li&gt;
&lt;li&gt;一般用于加载驱动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="继承" scheme="http://harmansecurity.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(七)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(七)/</id>
    <published>2017-03-19T14:41:21.000Z</published>
    <updated>2017-03-19T15:16:56.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="07-01-面向对象-构造方法Constructor概述和格式-掌握"><a href="#07-01-面向对象-构造方法Constructor概述和格式-掌握" class="headerlink" title="07.01_面向对象(构造方法Constructor概述和格式)(掌握)"></a>07.01_面向对象(构造方法Constructor概述和格式)(掌握)</h3><ul>
<li>A:构造方法概述和作用<ul>
<li>给对象的数据(属性)进行初始化</li>
</ul>
</li>
<li>B:构造方法格式特点<ul>
<li>a:方法名与类名相同(大小也要与类名一致)</li>
<li>b:没有返回值类型，连void都没有</li>
<li>c:没有具体的返回值return;</li>
</ul>
</li>
</ul>
<h3 id="07-02-面向对象-构造方法的重载及注意事项-掌握"><a href="#07-02-面向对象-构造方法的重载及注意事项-掌握" class="headerlink" title="07.02_面向对象(构造方法的重载及注意事项)(掌握)"></a>07.02_面向对象(构造方法的重载及注意事项)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>构造方法的重载</li>
<li>重载:方法名相同,与返回值类型无关(构造方法没有返回值),只看参数列表</li>
</ul>
</li>
<li>B:构造方法注意事项<ul>
<li>a:如果我们没有给出构造方法，系统将自动提供一个无参构造方法。</li>
<li>b:如果我们给出了构造方法，系统将不再提供默认的无参构造方法。<ul>
<li>注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="07-03-面向对象-给成员变量赋值的两种方式的区别"><a href="#07-03-面向对象-给成员变量赋值的两种方式的区别" class="headerlink" title="07.03_面向对象(给成员变量赋值的两种方式的区别)"></a>07.03_面向对象(给成员变量赋值的两种方式的区别)</h3><ul>
<li>A:setXxx()方法<ul>
<li>修改属性值 </li>
</ul>
</li>
<li>B:构造方法<ul>
<li>给对象中属性进行初始化 </li>
</ul>
</li>
</ul>
<h3 id="07-04-面向对象-学生类的代码及测试-掌握"><a href="#07-04-面向对象-学生类的代码及测试-掌握" class="headerlink" title="07.04_面向对象(学生类的代码及测试)(掌握)"></a>07.04_面向对象(学生类的代码及测试)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>学生类：<ul>
<li>成员变量：<ul>
<li>name，age</li>
</ul>
</li>
<li>构造方法：<ul>
<li>无参，带两个参</li>
</ul>
</li>
<li>成员方法：<ul>
<li>getXxx()/setXxx()</li>
<li>show()：输出该类的所有成员变量值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B:给成员变量赋值：</p>
<ul>
<li>a:setXxx()方法</li>
<li>b:构造方法</li>
</ul>
</li>
<li><p>C:输出成员变量值的方式：</p>
<ul>
<li>a:通过getXxx()分别获取然后拼接</li>
<li>b:通过调用show()方法搞定</li>
</ul>
</li>
</ul>
<h3 id="07-05-面向对象-手机类的代码及测试-掌握"><a href="#07-05-面向对象-手机类的代码及测试-掌握" class="headerlink" title="07.05_面向对象(手机类的代码及测试)(掌握)"></a>07.05_面向对象(手机类的代码及测试)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>模仿学生类，完成手机类代码</li>
</ul>
</li>
</ul>
<h3 id="07-06-面向对象-创建一个对象的步骤-掌握"><a href="#07-06-面向对象-创建一个对象的步骤-掌握" class="headerlink" title="07.06_面向对象(创建一个对象的步骤)(掌握)"></a>07.06_面向对象(创建一个对象的步骤)(掌握)</h3><ul>
<li>A:画图演示<ul>
<li>画图说明一个对象的创建过程做了哪些事情?</li>
<li>Student s = new Student();</li>
<li>1,Student.class加载进内存</li>
<li>2,声明一个Student类型引用s</li>
<li>3,在堆内存创建对象,</li>
<li>4,给对象中属性默认初始化值</li>
<li>5,属性进行显示初始化</li>
<li>6,构造方法进栈,对对象中的属性赋值,构造方法弹栈</li>
<li>7,将对象的地址值赋值给s</li>
</ul>
</li>
</ul>
<h3 id="07-07-面向对象-长方形案例练习-掌握"><a href="#07-07-面向对象-长方形案例练习-掌握" class="headerlink" title="07.07_面向对象(长方形案例练习)(掌握)"></a>07.07_面向对象(长方形案例练习)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>需求：<ul>
<li>定义一个长方形类,定义 求周长和面积的方法，</li>
<li>然后定义一个测试类进行测试。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="07-08-面向对象-员工类案例练习-掌握"><a href="#07-08-面向对象-员工类案例练习-掌握" class="headerlink" title="07.08_面向对象(员工类案例练习)(掌握)"></a>07.08_面向对象(员工类案例练习)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>需求：定义一个员工类Employee</li>
<li>自己分析出几个成员，然后给出成员变量<ul>
<li>姓名name,工号id,工资salary </li>
</ul>
</li>
<li>构造方法，<ul>
<li>空参和有参的</li>
</ul>
</li>
<li>getXxx()setXxx()方法，</li>
<li>以及一个显示所有成员信息的方法。并测试。<ul>
<li>work </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="07-09-面向对象-static关键字及内存图-了解"><a href="#07-09-面向对象-static关键字及内存图-了解" class="headerlink" title="07.09_面向对象(static关键字及内存图)(了解)"></a>07.09_面向对象(static关键字及内存图)(了解)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li>通过一个案例引入static关键字。</li>
<li>人类：Person。每个人都有国籍，中国。</li>
</ul>
</li>
<li><p>B:画图演示</p>
<ul>
<li>带有static的内存图</li>
</ul>
</li>
</ul>
<h3 id="07-10-面向对象-static关键字的特点-掌握"><a href="#07-10-面向对象-static关键字的特点-掌握" class="headerlink" title="07.10_面向对象(static关键字的特点)(掌握)"></a>07.10_面向对象(static关键字的特点)(掌握)</h3><ul>
<li>A:static关键字的特点<ul>
<li>a:随着类的加载而加载</li>
<li>b:优先于对象存在</li>
<li>c:被类的所有对象共享<ul>
<li>举例：咱们班级的学生应该共用同一个班级编号。</li>
<li>其实这个特点也是在告诉我们什么时候使用静态?<ul>
<li>如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。</li>
</ul>
</li>
<li>举例：<ul>
<li>饮水机(用静态修饰)</li>
<li>水杯(不能用静态修饰)</li>
<li>共性用静态,特性用非静态</li>
</ul>
</li>
</ul>
</li>
<li>d:可以通过类名调用<ul>
<li>其实它本身也可以通过对象名调用。</li>
<li>推荐使用类名调用。</li>
<li>静态修饰的内容一般我们称其为：与类相关的，类成员</li>
</ul>
</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>static关键字的特点</li>
</ul>
</li>
</ul>
<h3 id="07-11-面向对象-static的注意事项-掌握"><a href="#07-11-面向对象-static的注意事项-掌握" class="headerlink" title="07.11_面向对象(static的注意事项)(掌握)"></a>07.11_面向对象(static的注意事项)(掌握)</h3><ul>
<li>A:static的注意事项<ul>
<li>a:在静态方法中是没有this关键字的<ul>
<li>如何理解呢?<ul>
<li>静态是随着类的加载而加载，this是随着对象的创建而存在。</li>
<li>静态比对象先存在。</li>
</ul>
</li>
</ul>
</li>
<li>b:静态方法只能访问静态的成员变量和静态的成员方法<ul>
<li>静态方法：<ul>
<li>成员变量：只能访问静态变量</li>
<li>成员方法：只能访问静态成员方法</li>
</ul>
</li>
<li>非静态方法：<ul>
<li>成员变量：可以是静态的，也可以是非静态的</li>
<li>成员方法：可是是静态的成员方法，也可以是非静态的成员方法。</li>
</ul>
</li>
<li>简单记：<ul>
<li>静态只能访问静态。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>static的注意事项</li>
</ul>
</li>
</ul>
<h3 id="07-12-面向对象-静态变量和成员变量的区别-掌握"><a href="#07-12-面向对象-静态变量和成员变量的区别-掌握" class="headerlink" title="07.12_面向对象(静态变量和成员变量的区别)(掌握)"></a>07.12_面向对象(静态变量和成员变量的区别)(掌握)</h3><ul>
<li>静态变量也叫类变量  成员变量也叫对象变量</li>
<li>A:所属不同<ul>
<li>静态变量属于类，所以也称为为类变量</li>
<li>成员变量属于对象，所以也称为实例变量(对象变量)</li>
</ul>
</li>
<li>B:内存中位置不同<ul>
<li>静态变量存储于方法区的静态区</li>
<li>成员变量存储于堆内存</li>
</ul>
</li>
<li>C:内存出现时间不同<ul>
<li>静态变量随着类的加载而加载，随着类的消失而消失</li>
<li>成员变量随着对象的创建而存在，随着对象的消失而消失</li>
</ul>
</li>
<li>D:调用不同<ul>
<li>静态变量可以通过类名调用，也可以通过对象调用</li>
<li>成员变量只能通过对 象名调用</li>
</ul>
</li>
</ul>
<h3 id="07-13-面向对象-main方法的格式详细解释-了解"><a href="#07-13-面向对象-main方法的格式详细解释-了解" class="headerlink" title="07.13_面向对象(main方法的格式详细解释)(了解)"></a>07.13_面向对象(main方法的格式详细解释)(了解)</h3><ul>
<li>A:格式<ul>
<li>public static void main(String[] args) {}</li>
</ul>
</li>
<li>B:针对格式的解释<ul>
<li>public 被jvm调用，访问权限足够大。</li>
<li>static 被jvm调用，不用创建对象，直接类名访问</li>
<li>void被jvm调用，不需要给jvm返回值</li>
<li>main 一个通用的名称，虽然不是关键字，但是被jvm识别</li>
<li>String[] args 以前用于接收键盘录入的</li>
</ul>
</li>
<li>C:演示案例<ul>
<li>通过args接收键盘例如数据</li>
</ul>
</li>
</ul>
<h3 id="07-14-面向对象-工具类中使用静态-了解"><a href="#07-14-面向对象-工具类中使用静态-了解" class="headerlink" title="07.14_面向对象(工具类中使用静态)(了解)"></a>07.14_面向对象(工具类中使用静态)(了解)</h3><ul>
<li>A:制作一个工具类<ul>
<li>ArrayTool</li>
<li>1,获取最大值</li>
<li>2,数组的遍历</li>
<li>3,数组的反转</li>
</ul>
</li>
</ul>
<h3 id="07-15-面向对象-说明书的制作过程-了解"><a href="#07-15-面向对象-说明书的制作过程-了解" class="headerlink" title="07.15_面向对象(说明书的制作过程)(了解)"></a>07.15_面向对象(说明书的制作过程)(了解)</h3><ul>
<li>A:对工具类加入文档注释</li>
<li>B:通过javadoc命令生成说明书<ul>
<li>@author(提取作者内容)</li>
<li>@version(提取版本内容)</li>
<li>javadoc -d 指定的文件目录 -author -version ArrayTool.java</li>
<li>@param 参数名称//形式参数的变量名称@return 函数运行完返回的数据</li>
</ul>
</li>
</ul>
<h3 id="07-16-面向对象-如何使用JDK提供的帮助文档-了解"><a href="#07-16-面向对象-如何使用JDK提供的帮助文档-了解" class="headerlink" title="07.16_面向对象(如何使用JDK提供的帮助文档)(了解)"></a>07.16_面向对象(如何使用JDK提供的帮助文档)(了解)</h3><ul>
<li>A:找到文档，打开文档</li>
<li>B:点击显示，找到索引，出现输入框</li>
<li>C:你应该知道你找谁?举例：Scanner</li>
<li>D:看这个类的结构(需不需要导包)<ul>
<li>成员变量    字段</li>
<li>构造方法    构造方法</li>
<li>成员方法    方法</li>
</ul>
</li>
</ul>
<h3 id="07-17-面向对象-学习Math类的随机数功能-了解"><a href="#07-17-面向对象-学习Math类的随机数功能-了解" class="headerlink" title="07.17_面向对象(学习Math类的随机数功能)(了解)"></a>07.17_面向对象(学习Math类的随机数功能)(了解)</h3><ul>
<li>打开JDK提供的帮助文档学习</li>
<li>A:Math类概述<ul>
<li>类包含用于执行基本数学运算的方法</li>
</ul>
</li>
<li>B:Math类特点<ul>
<li>由于Math类在java.lang包下，所以不需要导包。</li>
<li>因为它的成员全部是静态的,所以私有了构造方法</li>
</ul>
</li>
<li>C:获取随机数的方法<ul>
<li>public static double random():返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。</li>
</ul>
</li>
<li>D:我要获取一个1-100之间的随机数，肿么办?<ul>
<li>int number = (int)(Math.random()*100)+1;</li>
</ul>
</li>
</ul>
<h3 id="07-18-面向对象-猜数字小游戏案例-了解"><a href="#07-18-面向对象-猜数字小游戏案例-了解" class="headerlink" title="07.18_面向对象(猜数字小游戏案例)(了解)"></a>07.18_面向对象(猜数字小游戏案例)(了解)</h3><ul>
<li>A:案例演示<ul>
<li>需求：猜数字小游戏(数据在1-100之间)</li>
</ul>
</li>
</ul>
<h3 id="07-19-day07总结"><a href="#07-19-day07总结" class="headerlink" title="07.19_day07总结"></a>07.19_day07总结</h3><p>把今天的知识点总结一遍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;07-01-面向对象-构造方法Constructor概述和格式-掌握&quot;&gt;&lt;a href=&quot;#07-01-面向对象-构造方法Constructor概述和格式-掌握&quot; class=&quot;headerlink&quot; title=&quot;07.01_面向对象(构造方法Constructor概述和格式)(掌握)&quot;&gt;&lt;/a&gt;07.01_面向对象(构造方法Constructor概述和格式)(掌握)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:构造方法概述和作用&lt;ul&gt;
&lt;li&gt;给对象的数据(属性)进行初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:构造方法格式特点&lt;ul&gt;
&lt;li&gt;a:方法名与类名相同(大小也要与类名一致)&lt;/li&gt;
&lt;li&gt;b:没有返回值类型，连void都没有&lt;/li&gt;
&lt;li&gt;c:没有具体的返回值return;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;07-02-面向对象-构造方法的重载及注意事项-掌握&quot;&gt;&lt;a href=&quot;#07-02-面向对象-构造方法的重载及注意事项-掌握&quot; class=&quot;headerlink&quot; title=&quot;07.02_面向对象(构造方法的重载及注意事项)(掌握)&quot;&gt;&lt;/a&gt;07.02_面向对象(构造方法的重载及注意事项)(掌握)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:案例演示&lt;ul&gt;
&lt;li&gt;构造方法的重载&lt;/li&gt;
&lt;li&gt;重载:方法名相同,与返回值类型无关(构造方法没有返回值),只看参数列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:构造方法注意事项&lt;ul&gt;
&lt;li&gt;a:如果我们没有给出构造方法，系统将自动提供一个无参构造方法。&lt;/li&gt;
&lt;li&gt;b:如果我们给出了构造方法，系统将不再提供默认的无参构造方法。&lt;ul&gt;
&lt;li&gt;注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="构造方法" scheme="http://harmansecurity.cn/tags/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    
      <category term="static" scheme="http://harmansecurity.cn/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(六)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(六)/</id>
    <published>2017-03-19T14:40:21.000Z</published>
    <updated>2017-03-19T15:16:09.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="06-01-面向对象-面向对象思想概述-了解"><a href="#06-01-面向对象-面向对象思想概述-了解" class="headerlink" title="06.01_面向对象(面向对象思想概述)(了解)"></a>06.01_面向对象(面向对象思想概述)(了解)</h3><ul>
<li>A:面向过程思想概述<ul>
<li>第一步</li>
<li>第二步 </li>
</ul>
</li>
<li>B:面向对象思想概述<ul>
<li>找对象(第一步,第二步) </li>
</ul>
</li>
<li>C:举例<ul>
<li>买煎饼果子</li>
<li>洗衣服 </li>
</ul>
</li>
<li>D:面向对象思想特点<ul>
<li>a:是一种更符合我们思想习惯的思想</li>
<li>b:可以将复杂的事情简单化</li>
<li>c:将我们从执行者变成了指挥者<ul>
<li>角色发生了转换</li>
</ul>
</li>
</ul>
</li>
<li>E:面向对象开发<ul>
<li>就是不断的创建对象，使用对象，指挥对象做事情。</li>
</ul>
</li>
<li>F:面向对象设计<ul>
<li>其实就是在管理和维护对象之间的关系。</li>
</ul>
</li>
<li>G:面向对象特征<ul>
<li>封装(encapsulation)</li>
<li>继承(inheritance)</li>
<li>多态(polymorphism)</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="06-02-面向对象-类与对象概述-掌握"><a href="#06-02-面向对象-类与对象概述-掌握" class="headerlink" title="06.02_面向对象(类与对象概述)(掌握)"></a>06.02_面向对象(类与对象概述)(掌握)</h3><ul>
<li>A:我们学习编程是为了什么<ul>
<li>为了把我们日常生活中实物用学习语言描述出来</li>
</ul>
</li>
<li>B:我们如何描述现实世界事物<ul>
<li>属性    就是该事物的描述信息(事物身上的名词)</li>
<li>行为    就是该事物能够做什么(事物身上的动词)</li>
</ul>
</li>
<li>C:Java中最基本的单位是类,Java中用class描述事物也是如此<ul>
<li>成员变量    就是事物的属性</li>
<li>成员方法    就是事物的行为</li>
</ul>
</li>
<li>D:定义类其实就是定义类的成员(成员变量和成员方法)<ul>
<li>a:成员变量    和以前定义变量是一样的，只不过位置发生了改变。在类中，方法外。</li>
<li>b:成员方法    和以前定义方法是一样的，只不过把static去掉，后面在详细讲解static的作用。</li>
</ul>
</li>
<li>E:类和对象的概念<ul>
<li>a:类：是一组相关的属性和行为的集合</li>
<li>b:对象：是该类事物的具体体现</li>
<li>c:举例：<ul>
<li>类     学生</li>
<li>对象    具体的某个学生就是一个对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="06-03-面向对象-学生类的定义-掌握"><a href="#06-03-面向对象-学生类的定义-掌握" class="headerlink" title="06.03_面向对象(学生类的定义)(掌握)"></a>06.03_面向对象(学生类的定义)(掌握)</h3><ul>
<li>A:学生事物</li>
<li>B:学生类</li>
<li>C:案例演示<ul>
<li>属性:姓名,年龄,性别</li>
<li>行为:学习,睡觉</li>
</ul>
</li>
</ul>
<h3 id="06-04-面向对象-手机类的定义-掌握"><a href="#06-04-面向对象-手机类的定义-掌握" class="headerlink" title="06.04_面向对象(手机类的定义)(掌握)"></a>06.04_面向对象(手机类的定义)(掌握)</h3><ul>
<li>模仿学生类，让学生自己完成<ul>
<li>属性:品牌(brand)价格(price)</li>
<li>行为:打电话(call),发信息(sendMessage)玩游戏(playGame)</li>
</ul>
</li>
</ul>
<h3 id="06-05-面向对象-学生类的使用-掌握"><a href="#06-05-面向对象-学生类的使用-掌握" class="headerlink" title="06.05_面向对象(学生类的使用)(掌握)"></a>06.05_面向对象(学生类的使用)(掌握)</h3><ul>
<li>A:文件名问题<ul>
<li>在一个java文件中写两个类：一个基本的类，一个测试类。</li>
<li>建议：文件名称和测试类名称一致。</li>
</ul>
</li>
<li>B:如何使用对象?<ul>
<li>创建对象并使用</li>
<li>格式：类名 对象名 = new 类名();</li>
</ul>
</li>
<li>D:如何使用成员变量呢?<ul>
<li>对象名.变量名</li>
</ul>
</li>
<li>E:如何使用成员方法呢?<ul>
<li>对象名.方法名(…)</li>
</ul>
</li>
</ul>
<h3 id="06-06-面向对象-手机类的使用-掌握"><a href="#06-06-面向对象-手机类的使用-掌握" class="headerlink" title="06.06_面向对象(手机类的使用)(掌握)"></a>06.06_面向对象(手机类的使用)(掌握)</h3><ul>
<li>A:学生自己完成<ul>
<li>模仿学生类，让学生自己完成</li>
</ul>
</li>
</ul>
<h3 id="06-07-面向对象-一个对象的内存图-掌握"><a href="#06-07-面向对象-一个对象的内存图-掌握" class="headerlink" title="06.07_面向对象(一个对象的内存图)(掌握)"></a>06.07_面向对象(一个对象的内存图)(掌握)</h3><ul>
<li>A:画图演示<ul>
<li>一个对象</li>
</ul>
</li>
</ul>
<h3 id="06-08-面向对象-二个对象的内存图-了解"><a href="#06-08-面向对象-二个对象的内存图-了解" class="headerlink" title="06.08_面向对象(二个对象的内存图)(了解)"></a>06.08_面向对象(二个对象的内存图)(了解)</h3><ul>
<li>A:画图演示<ul>
<li>二个不同的对象</li>
</ul>
</li>
</ul>
<h3 id="06-09-面向对象-三个引用两个对象的内存图-了解"><a href="#06-09-面向对象-三个引用两个对象的内存图-了解" class="headerlink" title="06.09_面向对象(三个引用两个对象的内存图)(了解)"></a>06.09_面向对象(三个引用两个对象的内存图)(了解)</h3><ul>
<li>A:画图演示<ul>
<li>三个引用，有两个对象的引用指向同一个地址</li>
</ul>
</li>
</ul>
<h3 id="06-10-面向对象-成员变量和局部变量的区别-掌握"><a href="#06-10-面向对象-成员变量和局部变量的区别-掌握" class="headerlink" title="06.10_面向对象(成员变量和局部变量的区别)(掌握)"></a>06.10_面向对象(成员变量和局部变量的区别)(掌握)</h3><ul>
<li>A:在类中的位置不同<ul>
<li>成员变量：在类中方法外</li>
<li>局部变量：在方法定义中或者方法声明上</li>
</ul>
</li>
<li>B:在内存中的位置不同<ul>
<li>成员变量：在堆内存(成员变量属于对象,对象进堆内存)</li>
<li>局部变量：在栈内存(局部变量属于方法,方法进栈内存)</li>
</ul>
</li>
<li>C:生命周期不同<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li>
<li>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li>
</ul>
</li>
<li><p>D:初始化值不同</p>
<ul>
<li>成员变量：有默认初始化值</li>
<li>局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。</li>
<li>基本数据类型变量包括哪些:byte,short,int,long,float,double,boolean,char</li>
<li>引用数据类型变量包括哪些:数组,类,接口,枚举</li>
</ul>
</li>
</ul>
<h3 id="06-11-面向对象-方法的形式参数是类名的时候如何调用-掌握"><a href="#06-11-面向对象-方法的形式参数是类名的时候如何调用-掌握" class="headerlink" title="06.11_面向对象(方法的形式参数是类名的时候如何调用)(掌握)"></a>06.11_面向对象(方法的形式参数是类名的时候如何调用)(掌握)</h3><ul>
<li>A:方法的参数是类名public void print(Student s){}//print(new Student());<ul>
<li>如果你看到了一个方法的形式参数是一个类类型(引用类型)，这里其实需要的是该类的对象。</li>
</ul>
</li>
</ul>
<h3 id="06-12-面向对象-匿名对象的概述和应用-掌握"><a href="#06-12-面向对象-匿名对象的概述和应用-掌握" class="headerlink" title="06.12_面向对象(匿名对象的概述和应用)(掌握)"></a>06.12_面向对象(匿名对象的概述和应用)(掌握)</h3><ul>
<li>A:什么是匿名对象<ul>
<li>没有名字的对象 </li>
</ul>
</li>
<li>B:匿名对象应用场景<ul>
<li>a:调用方法，仅仅只调用一次的时候。<ul>
<li>那么，这种匿名调用有什么好处吗?<ul>
<li>节省代码 </li>
</ul>
</li>
<li>注意：调用多次的时候，不适合。匿名对象调用完毕就是垃圾。可以被垃圾回收器回收。</li>
</ul>
</li>
<li>b:匿名对象可以作为实际参数传递</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>匿名对象应用场景</li>
</ul>
</li>
</ul>
<h3 id="06-13-面向对象-封装的概述-掌握"><a href="#06-13-面向对象-封装的概述-掌握" class="headerlink" title="06.13_面向对象(封装的概述)(掌握)"></a>06.13_面向对象(封装的概述)(掌握)</h3><ul>
<li><p>A:封装概述</p>
<ul>
<li>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</li>
</ul>
</li>
<li><p>B:封装好处</p>
<ul>
<li>隐藏实现细节，提供公共的访问方式</li>
<li>提高了代码的复用性</li>
<li>提高安全性。</li>
</ul>
</li>
<li>C:封装原则<ul>
<li>将不需要对外提供的内容都隐藏起来。</li>
<li>把属性隐藏，提供公共方法对其访问。</li>
</ul>
</li>
</ul>
<h3 id="06-14-面向对象-private关键字的概述和特点-掌握"><a href="#06-14-面向对象-private关键字的概述和特点-掌握" class="headerlink" title="06.14_面向对象(private关键字的概述和特点)(掌握)"></a>06.14_面向对象(private关键字的概述和特点)(掌握)</h3><ul>
<li>A:人类赋值年龄的问题</li>
<li>B:private关键字特点<ul>
<li>a:是一个权限修饰符</li>
<li>b:可以修饰成员变量和成员方法</li>
<li>c:被其修饰的成员只能在本类中被访问</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>封装和private的应用：</li>
<li>A:把成员变量用private修饰</li>
<li>B:提供对应的getXxx()和setXxx()方法</li>
<li>private仅仅是封装的一种体现形式,不能说封装就是私有</li>
</ul>
</li>
</ul>
<h3 id="06-15-面向对象-this关键字的概述和应用-掌握"><a href="#06-15-面向对象-this关键字的概述和应用-掌握" class="headerlink" title="06.15_面向对象(this关键字的概述和应用)(掌握)"></a>06.15_面向对象(this关键字的概述和应用)(掌握)</h3><ul>
<li>A:this关键字特点<ul>
<li>代表当前对象的引用 </li>
</ul>
</li>
<li>B:案例演示<ul>
<li>this的应用场景</li>
<li>用来区分成员变量和局部变量重名</li>
</ul>
</li>
</ul>
<h3 id="06-16-面向对象-手机类代码及其测试-掌握"><a href="#06-16-面向对象-手机类代码及其测试-掌握" class="headerlink" title="06.16_面向对象(手机类代码及其测试)(掌握)"></a>06.16_面向对象(手机类代码及其测试)(掌握)</h3><ul>
<li>A:学生练习<ul>
<li>请把手机类写成一个标准类，然后创建对象测试功能。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2_Phone</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Phone p1 = <span class="keyword">new</span> Phone();</div><div class="line">		p1.setBrand(<span class="string">"三星"</span>);</div><div class="line">		p1.setPrice(<span class="number">5288</span>);</div><div class="line"></div><div class="line">		System.out.println(p1.getBrand() + <span class="string">"..."</span> + p1.getPrice());</div><div class="line">		p1.call();</div><div class="line">		p1.sendMessage();</div><div class="line">		p1.playGame();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">手机类</div><div class="line">	属性:品牌brand,价格price</div><div class="line">	行为:打电话call,发短信sendMessage,玩游戏,playGame</div><div class="line">*/</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;								<span class="comment">//java bean</span></div><div class="line">	<span class="keyword">private</span> String brand;					<span class="comment">//品牌</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> price;						<span class="comment">//价格</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;	<span class="comment">//设置品牌</span></div><div class="line">		<span class="keyword">this</span>.brand = brand;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;				<span class="comment">//获取品牌</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.brand;					<span class="comment">//this.可以省略,你不加系统会默认给你加</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;		<span class="comment">//设置价格</span></div><div class="line">		<span class="keyword">this</span>.price = price;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;					<span class="comment">//获取价格</span></div><div class="line">		<span class="keyword">return</span> price;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;					<span class="comment">//打电话</span></div><div class="line">		System.out.println(<span class="string">"打电话"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;				<span class="comment">//发短信</span></div><div class="line">		System.out.println(<span class="string">"发短信"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;				<span class="comment">//玩游戏</span></div><div class="line">		System.out.println(<span class="string">"玩游戏"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="06-17-day06总结"><a href="#06-17-day06总结" class="headerlink" title="06.17_day06总结"></a>06.17_day06总结</h3><ul>
<li>把今天的知识点总结一遍。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;06-01-面向对象-面向对象思想概述-了解&quot;&gt;&lt;a href=&quot;#06-01-面向对象-面向对象思想概述-了解&quot; class=&quot;headerlink&quot; title=&quot;06.01_面向对象(面向对象思想概述)(了解)&quot;&gt;&lt;/a&gt;06.01_面向对象(面向对象思想概述)(了解)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:面向过程思想概述&lt;ul&gt;
&lt;li&gt;第一步&lt;/li&gt;
&lt;li&gt;第二步 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:面向对象思想概述&lt;ul&gt;
&lt;li&gt;找对象(第一步,第二步) &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C:举例&lt;ul&gt;
&lt;li&gt;买煎饼果子&lt;/li&gt;
&lt;li&gt;洗衣服 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D:面向对象思想特点&lt;ul&gt;
&lt;li&gt;a:是一种更符合我们思想习惯的思想&lt;/li&gt;
&lt;li&gt;b:可以将复杂的事情简单化&lt;/li&gt;
&lt;li&gt;c:将我们从执行者变成了指挥者&lt;ul&gt;
&lt;li&gt;角色发生了转换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;E:面向对象开发&lt;ul&gt;
&lt;li&gt;就是不断的创建对象，使用对象，指挥对象做事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;F:面向对象设计&lt;ul&gt;
&lt;li&gt;其实就是在管理和维护对象之间的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;G:面向对象特征&lt;ul&gt;
&lt;li&gt;封装(encapsulation)&lt;/li&gt;
&lt;li&gt;继承(inheritance)&lt;/li&gt;
&lt;li&gt;多态(polymorphism)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面向对象" scheme="http://harmansecurity.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(五)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(五)/</id>
    <published>2017-03-19T14:39:22.000Z</published>
    <updated>2017-03-19T15:27:14.582Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<code>http://bbs.itheima.com/thread-270882-1-1.html</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接：&lt;code&gt;http://bbs.itheima.com/thread-270882-1-1.html&lt;/code&gt;&lt;/p&gt;

    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="数组操作" scheme="http://harmansecurity.cn/tags/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(四)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(四)/</id>
    <published>2017-03-19T14:38:21.000Z</published>
    <updated>2017-03-19T15:12:13.869Z</updated>
    
    <content type="html"><![CDATA[<h3 id="04-01-Java语言基础-循环结构概述和for语句的格式及其使用"><a href="#04-01-Java语言基础-循环结构概述和for语句的格式及其使用" class="headerlink" title="04.01_Java语言基础(循环结构概述和for语句的格式及其使用)"></a>04.01_Java语言基础(循环结构概述和for语句的格式及其使用)</h3><ul>
<li>A:循环结构的分类<ul>
<li>for,while,do…while </li>
</ul>
</li>
<li>B:循环结构for语句的格式：</li>
<li><pre><code>for(初始化表达式;条件表达式;循环后的操作表达式) {
    循环体;
}
</code></pre></li>
<li>C执行流程：<ul>
<li>a:执行初始化语句</li>
<li>b:执行判断条件语句,看其返回值是true还是false<ul>
<li>如果是true，就继续执行</li>
<li>如果是false，就结束循环</li>
</ul>
</li>
<li>c:执行循环体语句;</li>
<li>d:执行循环后的操作表达式</li>
<li>e:回到B继续。</li>
</ul>
</li>
<li>D:案例演示<ul>
<li>在控制台输出10次”helloworld”</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="04-02-Java语言基础-循环结构for语句的练习之获取数据"><a href="#04-02-Java语言基础-循环结构for语句的练习之获取数据" class="headerlink" title="04.02_Java语言基础(循环结构for语句的练习之获取数据)"></a>04.02_Java语言基础(循环结构for语句的练习之获取数据)</h3><ul>
<li>A:案例演示<ul>
<li>需求：请在控制台输出数据1-10</li>
<li>需求：请在控制台输出数据10-1</li>
</ul>
</li>
<li>B:注意事项<ul>
<li>a:判断条件语句无论简单还是复杂结果是boolean类型。</li>
<li>b:循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。</li>
<li>c:一般来说：有左大括号就没有分号，有分号就没有左大括号</li>
</ul>
</li>
</ul>
<h3 id="04-03-Java语言基础-循环结构for语句的练习之求和思想"><a href="#04-03-Java语言基础-循环结构for语句的练习之求和思想" class="headerlink" title="04.03_Java语言基础(循环结构for语句的练习之求和思想)"></a>04.03_Java语言基础(循环结构for语句的练习之求和思想)</h3><ul>
<li>A:案例演示<ul>
<li>需求：求出1-10之间数据之和</li>
</ul>
</li>
<li>B:学生练习<ul>
<li>需求：求出1-100之间偶数和</li>
<li>需求：求出1-100之间奇数和</li>
</ul>
</li>
</ul>
<h3 id="04-04-Java语言基础-循环结构for语句的练习之水仙花"><a href="#04-04-Java语言基础-循环结构for语句的练习之水仙花" class="headerlink" title="04.04_Java语言基础(循环结构for语句的练习之水仙花)"></a>04.04_Java语言基础(循环结构for语句的练习之水仙花)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li><p>需求：在控制台输出所有的”水仙花数”</p>
</li>
<li><p>所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。</p>
</li>
<li>举例：153就是一个水仙花数。</li>
<li>153 = 1<em>1</em>1 + 5<em>5</em>5 + 3<em>3</em>3 = 1 + 125 + 27 = 153</li>
</ul>
</li>
</ul>
<h3 id="04-05-Java语言基础-循环结构for语句的练习之统计思想"><a href="#04-05-Java语言基础-循环结构for语句的练习之统计思想" class="headerlink" title="04.05_Java语言基础(循环结构for语句的练习之统计思想)"></a>04.05_Java语言基础(循环结构for语句的练习之统计思想)</h3><ul>
<li>A:案例演示<ul>
<li>需求：统计”水仙花数”共有多少个</li>
</ul>
</li>
</ul>
<h3 id="04-06-Java语言基础-循环结构while语句的格式和基本使用"><a href="#04-06-Java语言基础-循环结构while语句的格式和基本使用" class="headerlink" title="04.06_Java语言基础(循环结构while语句的格式和基本使用)"></a>04.06_Java语言基础(循环结构while语句的格式和基本使用)</h3><ul>
<li>A:循环结构while语句的格式：</li>
<li><p>while循环的基本格式：<br>while(判断条件语句) {<br>  循环体语句;<br>}</p>
<p>完整格式：</p>
<p>初始化语句;<br>while(判断条件语句) {<br>   循环体语句;<br>   控制条件语句;<br>}</p>
</li>
<li>B:执行流程：<ul>
<li>a:执行初始化语句</li>
<li>b:执行判断条件语句,看其返回值是true还是false<ul>
<li>如果是true，就继续执行</li>
<li>如果是false，就结束循环</li>
</ul>
</li>
<li>c:执行循环体语句;</li>
<li>d:执行控制条件语句</li>
<li>e:回到B继续。</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>需求：请在控制台输出数据1-10</li>
</ul>
</li>
</ul>
<h3 id="04-07-Java语言基础-循环结构while语句的练习"><a href="#04-07-Java语言基础-循环结构while语句的练习" class="headerlink" title="04.07_Java语言基础(循环结构while语句的练习)"></a>04.07_Java语言基础(循环结构while语句的练习)</h3><ul>
<li>A:求和思想<ul>
<li>求1-100之和</li>
</ul>
</li>
<li>B:统计思想<ul>
<li>统计”水仙花数”共有多少个</li>
</ul>
</li>
</ul>
<h3 id="04-08-Java语言基础-循环结构do…while语句的格式和基本使用"><a href="#04-08-Java语言基础-循环结构do…while语句的格式和基本使用" class="headerlink" title="04.08_Java语言基础(循环结构do…while语句的格式和基本使用)"></a>04.08_Java语言基础(循环结构do…while语句的格式和基本使用)</h3><ul>
<li>A:循环结构do…while语句的格式：</li>
<li><pre><code>do {
    循环体语句;
}while(判断条件语句);

完整格式；
初始化语句;
do {
    循环体语句;
    控制条件语句;
}while(判断条件语句);
</code></pre></li>
<li>B:执行流程：<ul>
<li>a:执行初始化语句</li>
<li>b:执行循环体语句;</li>
<li>c:执行控制条件语句</li>
<li>d:执行判断条件语句,看其返回值是true还是false<ul>
<li>如果是true，就继续执行</li>
<li>如果是false，就结束循环</li>
</ul>
</li>
<li>e:回到b继续。</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>需求：请在控制台输出数据1-10</li>
</ul>
</li>
</ul>
<h3 id="04-09-Java语言基础-循环结构三种循环语句的区别"><a href="#04-09-Java语言基础-循环结构三种循环语句的区别" class="headerlink" title="04.09_Java语言基础(循环结构三种循环语句的区别)"></a>04.09_Java语言基础(循环结构三种循环语句的区别)</h3><ul>
<li>A:案例演示<ul>
<li>三种循环语句的区别:</li>
<li>do…while循环至少执行一次循环体。</li>
<li>而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>for循环和while循环的区别：<ul>
<li>A:如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用谁就用for循环。因为变量及早的从内存中消失，可以提高内存的使用效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="04-10-Java语言基础-循环结构注意事项之死循环"><a href="#04-10-Java语言基础-循环结构注意事项之死循环" class="headerlink" title="04.10_Java语言基础(循环结构注意事项之死循环)"></a>04.10_Java语言基础(循环结构注意事项之死循环)</h3><ul>
<li>A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。</li>
<li>B:两种最简单的死循环格式<ul>
<li>while(true){…}</li>
<li>for(;;){…}</li>
</ul>
</li>
</ul>
<h3 id="04-11-Java语言基础-循环结构循环嵌套输出4行5列的星星"><a href="#04-11-Java语言基础-循环结构循环嵌套输出4行5列的星星" class="headerlink" title="04.11_Java语言基础(循环结构循环嵌套输出4行5列的星星)"></a>04.11_Java语言基础(循环结构循环嵌套输出4行5列的星星)</h3><ul>
<li>A:案例演示<ul>
<li>需求：请输出一个4行5列的星星(*)图案。</li>
<li><pre><code>如图：
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*****</div><div class="line">*****</div><div class="line">*****</div><div class="line">*****</div></pre></td></tr></table></figure>
</code></pre></li>
</ul>
</li>
</ul>
<pre><code>注意：
    `System.out.println(&quot;*&quot;);和System.out.print(&quot;*&quot;);`的区别
</code></pre><ul>
<li>B:结论：<ul>
<li>外循环控制行数，内循环控制列数</li>
</ul>
</li>
</ul>
<h3 id="04-12-Java语言基础-循环结构循环嵌套输出正三角形"><a href="#04-12-Java语言基础-循环结构循环嵌套输出正三角形" class="headerlink" title="04.12_Java语言基础(循环结构循环嵌套输出正三角形)"></a>04.12_Java语言基础(循环结构循环嵌套输出正三角形)</h3><ul>
<li>A:案例演示</li>
<li><pre><code>需求：请输出下列的形状
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*</div><div class="line">**</div><div class="line">***</div><div class="line">****</div><div class="line">*****</div></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<h3 id="04-13-Java语言基础-循环结构九九乘法表"><a href="#04-13-Java语言基础-循环结构九九乘法表" class="headerlink" title="04.13_Java语言基础(循环结构九九乘法表)"></a>04.13_Java语言基础(循环结构九九乘法表)</h3><ul>
<li>A:案例演示<ul>
<li>需求：在控制台输出九九乘法表。</li>
</ul>
</li>
<li>B:代码优化</li>
<li><pre><code>注意：
&apos;\x&apos; x表示任意，\是转义符号,这种做法叫转移字符。

&apos;\t&apos;    tab键的位置
&apos;\r&apos;    回车
&apos;\n&apos;    换行
&apos;\&quot;&apos;
&apos;\&apos;&apos;
</code></pre></li>
</ul>
<h3 id="04-14-Java语言基础-控制跳转语句break语句"><a href="#04-14-Java语言基础-控制跳转语句break语句" class="headerlink" title="04.14_Java语言基础(控制跳转语句break语句)"></a>04.14_Java语言基础(控制跳转语句break语句)</h3><ul>
<li>A:break的使用场景<ul>
<li>只能在switch和循环中 </li>
</ul>
</li>
</ul>
<h3 id="04-15-Java语言基础-控制跳转语句continue语句"><a href="#04-15-Java语言基础-控制跳转语句continue语句" class="headerlink" title="04.15_Java语言基础(控制跳转语句continue语句)"></a>04.15_Java语言基础(控制跳转语句continue语句)</h3><ul>
<li>A:continue的使用场景<ul>
<li>只能在循环中 </li>
</ul>
</li>
</ul>
<h3 id="04-16-Java语言基础-控制跳转语句标号"><a href="#04-16-Java语言基础-控制跳转语句标号" class="headerlink" title="04.16_Java语言基础(控制跳转语句标号)"></a>04.16_Java语言基础(控制跳转语句标号)</h3><ul>
<li>标号:标记某个循环对其控制</li>
<li>标号组成规则:其实就是合法的标识符</li>
</ul>
<h3 id="04-17-Java语言基础-控制调整语句练习"><a href="#04-17-Java语言基础-控制调整语句练习" class="headerlink" title="04.17_Java语言基础(控制调整语句练习)"></a>04.17_Java语言基础(控制调整语句练习)</h3><ul>
<li>A:练习题</li>
<li><pre><code>for(int x=1; x&lt;=10; x++) {
    if(x%3==0) {
        //在此处填写代码
    }
    System.out.println(“Java基础班”);
}

我想在控制台输出2次:“Java基础班“
我想在控制台输出7次:“Java基础班“
我想在控制台输出13次:“Java基础班“    
</code></pre></li>
</ul>
<h3 id="04-18-Java语言基础-控制跳转语句return语句"><a href="#04-18-Java语言基础-控制跳转语句return语句" class="headerlink" title="04.18_Java语言基础(控制跳转语句return语句)"></a>04.18_Java语言基础(控制跳转语句return语句)</h3><ul>
<li>A:return的作用<ul>
<li>返回</li>
<li>其实它的作用不是结束循环的，而是结束方法的。</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>return和break以及continue的区别?</li>
<li>return是结束方法</li>
<li>break是跳出循环</li>
<li>continue是终止本次循环继续下次循环</li>
</ul>
</li>
</ul>
<h3 id="04-19-Java语言基础-方法概述和格式说明"><a href="#04-19-Java语言基础-方法概述和格式说明" class="headerlink" title="04.19_Java语言基础(方法概述和格式说明)"></a>04.19_Java语言基础(方法概述和格式说明)</h3><ul>
<li>A:为什么要有方法<ul>
<li>提高代码的复用性 </li>
</ul>
</li>
<li>B:什么是方法<ul>
<li>完成特定功能的代码块。 </li>
</ul>
</li>
<li>C:方法的格式</li>
<li><pre><code>修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {
    方法体语句;
    return 返回值; 
} 
</code></pre></li>
<li>D:方法的格式说明<ul>
<li>修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。</li>
<li>返回值类型：就是功能结果的数据类型。</li>
<li>方法名：符合命名规则即可。方便我们的调用。</li>
<li>参数：<ul>
<li>实际参数：就是实际参与运算的。</li>
<li>形式参数；就是方法定义上的，用于接收实际参数的。</li>
</ul>
</li>
<li>参数类型：就是参数的数据类型</li>
<li>参数名：就是变量名</li>
<li>方法体语句：就是完成功能的代码。</li>
<li>return：结束方法的。</li>
<li>返回值：就是功能的结果，由return带给调用者。 </li>
</ul>
</li>
</ul>
<h3 id="04-20-Java语言基础-方法之求和案例及其调用"><a href="#04-20-Java语言基础-方法之求和案例及其调用" class="headerlink" title="04.20_Java语言基础(方法之求和案例及其调用)"></a>04.20_Java语言基础(方法之求和案例及其调用)</h3><ul>
<li>A:如何写一个方法<ul>
<li>1,明确返回值类型</li>
<li>2,明确参数列表 </li>
</ul>
</li>
<li>B:案例演示<ul>
<li>需求：求两个数据之和的案例</li>
</ul>
</li>
<li>C:方法调用图解</li>
</ul>
<h3 id="04-21-Java语言基础-方法的注意事项"><a href="#04-21-Java语言基础-方法的注意事项" class="headerlink" title="04.21_Java语言基础(方法的注意事项)"></a>04.21_Java语言基础(方法的注意事项)</h3><ul>
<li>A:方法调用(有具体返回值)<ul>
<li>a:单独调用,一般来说没有意义，所以不推荐。</li>
<li>b:输出调用,但是不够好。因为我们可能需要针对结果进行进一步的操作。</li>
<li>c:赋值调用,推荐方案。</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>a:方法不调用不执行</li>
<li>b:方法与方法是平级关系，不能嵌套定义</li>
<li>c:方法定义的时候参数之间用逗号隔开</li>
<li>d:方法调用的时候不用在传递数据类型</li>
<li>e:如果方法有明确的返回值，一定要有return带回一个值</li>
</ul>
</li>
</ul>
<h3 id="04-22-Java语言基础-方法的练习"><a href="#04-22-Java语言基础-方法的练习" class="headerlink" title="04.22_Java语言基础(方法的练习)"></a>04.22_Java语言基础(方法的练习)</h3><ul>
<li>A:案例演示<ul>
<li>需求：键盘录入两个数据，返回两个数中的较大值</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>需求：键盘录入两个数据，比较两个数是否相等     </li>
</ul>
</li>
</ul>
<h3 id="04-23-Java语言基础-方法之输出星形及其调用"><a href="#04-23-Java语言基础-方法之输出星形及其调用" class="headerlink" title="04.23_Java语言基础(方法之输出星形及其调用)"></a>04.23_Java语言基础(方法之输出星形及其调用)</h3><ul>
<li>A:案例演示<ul>
<li>需求：根据键盘录入的行数和列数，在控制台输出星形</li>
</ul>
</li>
<li>B:方法调用：(无返回值,void)<ul>
<li>单独调用</li>
<li>输出调用(错误)</li>
<li>赋值调用(错误)</li>
</ul>
</li>
</ul>
<h3 id="04-24-Java语言基础-方法的练习"><a href="#04-24-Java语言基础-方法的练习" class="headerlink" title="04.24_Java语言基础(方法的练习)"></a>04.24_Java语言基础(方法的练习)</h3><ul>
<li>A:案例演示<ul>
<li>需求：根据键盘录入的数据输出对应的乘法表</li>
</ul>
</li>
</ul>
<h3 id="04-25-Java语言基础-方法重载概述和基本使用"><a href="#04-25-Java语言基础-方法重载概述和基本使用" class="headerlink" title="04.25_Java语言基础(方法重载概述和基本使用)"></a>04.25_Java语言基础(方法重载概述和基本使用)</h3><ul>
<li>A:方法重载概述<ul>
<li>求和案例<ul>
<li>2个整数</li>
<li>3个整数</li>
<li>4个整数</li>
</ul>
</li>
</ul>
</li>
<li><p>B:方法重载：</p>
<ul>
<li><p>在同一个类中，方法名相同，参数列表不同。与返回值类型无关。</p>
</li>
<li><p>参数列表不同：</p>
<ul>
<li>A:参数个数不同</li>
<li>B:参数类型不同</li>
<li>C:参数的顺序不同(算重载,但是在开发中不用)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="04-26-Java语言基础-方法重载练习比较数据是否相等"><a href="#04-26-Java语言基础-方法重载练习比较数据是否相等" class="headerlink" title="04.26_Java语言基础(方法重载练习比较数据是否相等)"></a>04.26_Java语言基础(方法重载练习比较数据是否相等)</h3><ul>
<li>A:案例演示<ul>
<li>需求：比较两个数据是否相等。</li>
<li>参数类型分别为两个int类型，两个double类型，并在main方法中进行测试</li>
</ul>
</li>
</ul>
<h3 id="04-27-day04总结"><a href="#04-27-day04总结" class="headerlink" title="04.27_day04总结"></a>04.27_day04总结</h3><p>把今天的知识点总结一遍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;04-01-Java语言基础-循环结构概述和for语句的格式及其使用&quot;&gt;&lt;a href=&quot;#04-01-Java语言基础-循环结构概述和for语句的格式及其使用&quot; class=&quot;headerlink&quot; title=&quot;04.01_Java语言基础(循环结构概述和for语句的格式及其使用)&quot;&gt;&lt;/a&gt;04.01_Java语言基础(循环结构概述和for语句的格式及其使用)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:循环结构的分类&lt;ul&gt;
&lt;li&gt;for,while,do…while &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:循环结构for语句的格式：&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;for(初始化表达式;条件表达式;循环后的操作表达式) {
    循环体;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;C执行流程：&lt;ul&gt;
&lt;li&gt;a:执行初始化语句&lt;/li&gt;
&lt;li&gt;b:执行判断条件语句,看其返回值是true还是false&lt;ul&gt;
&lt;li&gt;如果是true，就继续执行&lt;/li&gt;
&lt;li&gt;如果是false，就结束循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;c:执行循环体语句;&lt;/li&gt;
&lt;li&gt;d:执行循环后的操作表达式&lt;/li&gt;
&lt;li&gt;e:回到B继续。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D:案例演示&lt;ul&gt;
&lt;li&gt;在控制台输出10次”helloworld”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="循环结构" scheme="http://harmansecurity.cn/tags/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
