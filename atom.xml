<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Harman&#39;s Homepage</title>
  <subtitle>Standing on the shoulders of giants.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://harmansecurity.cn/"/>
  <updated>2017-05-19T11:29:25.177Z</updated>
  <id>http://harmansecurity.cn/</id>
  
  <author>
    <name>Harman</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ARM Linux2.6.37中获取系统调用号</title>
    <link href="http://harmansecurity.cn/2017/05/19/ARM%20Linux2.6.37%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7/"/>
    <id>http://harmansecurity.cn/2017/05/19/ARM Linux2.6.37中获取系统调用号/</id>
    <published>2017-05-19T10:40:11.000Z</published>
    <updated>2017-05-19T11:29:25.177Z</updated>
    
    <content type="html"><![CDATA[<p> 　 　这个过程的实现基本原理是和Linux0.11差别不大的，不过一些汇编指令和系统架构还是有略微却别的，毕竟版本差异较大。Linux0.11主要是在system_call函数中实现获取系统调用号，而ARM Linux2.6.37是在软中断（vector_swi）中获取系统调用号的。下面主要说一下实现的步骤和遇到的问题。</p>
<h4 id="一、实验步骤"><a href="#一、实验步骤" class="headerlink" title="一、实验步骤"></a>一、实验步骤</h4><ul>
<li>1.在linux-2.6.37/arch/arm/kernel文件下找到entry-common.S修改源码，在软中断里面添加实现获取调用号的函数<code>bl get_syscall_num</code>。</li>
</ul>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B71.jpg" alt=""></p>
<a id="more"></a>
<ul>
<li>2.<code>get_scno.c</code>是用来实现<code>get_syscall_num</code>函数的。该文件主要是放在linux-2.6.37/arch/arm/kernel文件下。</li>
</ul>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B72.png" alt=""></p>
<ul>
<li>3.修改linux-2.6.37/arch/arm/kernel文件下的Makefile，如图所示。</li>
</ul>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B73.png" alt=""></p>
<h4 id="二、实验小结"><a href="#二、实验小结" class="headerlink" title="二、实验小结"></a>二、实验小结</h4><p> 　 　如果真正的想修改内核还是需要话功夫去研读源码的，可以先从Linux0.11开始学习。此实验的源码地址是：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/ARMLinux2.6.37%E8%8E%B7%E5%8F%96%E8%B0%83%E7%94%A8%E5%8F%B7</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 　 　这个过程的实现基本原理是和Linux0.11差别不大的，不过一些汇编指令和系统架构还是有略微却别的，毕竟版本差异较大。Linux0.11主要是在system_call函数中实现获取系统调用号，而ARM Linux2.6.37是在软中断（vector_swi）中获取系统调用号的。下面主要说一下实现的步骤和遇到的问题。&lt;/p&gt;
&lt;h4 id=&quot;一、实验步骤&quot;&gt;&lt;a href=&quot;#一、实验步骤&quot; class=&quot;headerlink&quot; title=&quot;一、实验步骤&quot;&gt;&lt;/a&gt;一、实验步骤&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1.在linux-2.6.37/arch/arm/kernel文件下找到entry-common.S修改源码，在软中断里面添加实现获取调用号的函数&lt;code&gt;bl get_syscall_num&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E4%B8%AD%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B71.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统调用" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="ARM Linux2.6.37" scheme="http://harmansecurity.cn/tags/ARM-Linux2-6-37/"/>
    
  </entry>
  
  <entry>
    <title>ARM Linux2.6.37系统调用原理</title>
    <link href="http://harmansecurity.cn/2017/05/19/ARM%20Linux2.6.37%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://harmansecurity.cn/2017/05/19/ARM Linux2.6.37系统调用原理/</id>
    <published>2017-05-19T10:40:11.000Z</published>
    <updated>2017-05-19T10:47:32.378Z</updated>
    
    <content type="html"><![CDATA[<p> 　 　系统调用是操作系统提供给用户（应用程序）的一组接口，每个系统调用都有一个对应的系统调用函数来完成相应的工作。用户通过这个接口向操作系统申请服务， 如访问硬件，管理进程等等。但是因为用户程序运行在用户空间，而系统调用运行在内核空间，因此用户程序不能直接调用系统调用函数，我们经常看到的比如 fork、open、write 等等函数实际上并不是真正的系统调用函数，他们都只是c库，在这些函数里将执行一个软中断 swi 指令，产生一个软中断，使CPU 陷入内核态，接着在内核中进行一系列的判断，判断出是哪个系统调用，再转到真正的系统调用函数，完成相应的功能。</p>
<h4 id="一、系统调用原理"><a href="#一、系统调用原理" class="headerlink" title="一、系统调用原理"></a>一、系统调用原理</h4><p><strong>1.entry-armv.S里面有switch软件中断的入口</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%861.png" alt=""></p>
<a id="more"></a>
<p><strong>2.调转到entry-common.S中执行vector_swi软中断指令</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%862.png" alt=""></p>
<h4 id="二、参考资料"><a href="#二、参考资料" class="headerlink" title="二、参考资料"></a>二、参考资料</h4><ul>
<li><code>http://www.linuxidc.com/Linux/2015-04/116546.htm</code></li>
<li><code>http://blog.csdn.net/tommy_wxie/article/details/7610118</code></li>
<li><code>http://blog.csdn.net/myarrow/article/details/7036266</code></li>
<li><code>http://blog.chinaunix.net/uid-28236237-id-3404140.html</code></li>
<li><code>http://blog.csdn.net/liduxun/article/details/48119849</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 　 　系统调用是操作系统提供给用户（应用程序）的一组接口，每个系统调用都有一个对应的系统调用函数来完成相应的工作。用户通过这个接口向操作系统申请服务， 如访问硬件，管理进程等等。但是因为用户程序运行在用户空间，而系统调用运行在内核空间，因此用户程序不能直接调用系统调用函数，我们经常看到的比如 fork、open、write 等等函数实际上并不是真正的系统调用函数，他们都只是c库，在这些函数里将执行一个软中断 swi 指令，产生一个软中断，使CPU 陷入内核态，接着在内核中进行一系列的判断，判断出是哪个系统调用，再转到真正的系统调用函数，完成相应的功能。&lt;/p&gt;
&lt;h4 id=&quot;一、系统调用原理&quot;&gt;&lt;a href=&quot;#一、系统调用原理&quot; class=&quot;headerlink&quot; title=&quot;一、系统调用原理&quot;&gt;&lt;/a&gt;一、系统调用原理&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.entry-armv.S里面有switch软件中断的入口&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/ARM%20Linux2.6.37%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%861.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统调用" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="ARM Linux2.6.37" scheme="http://harmansecurity.cn/tags/ARM-Linux2-6-37/"/>
    
  </entry>
  
  <entry>
    <title>QEMU安装和调试运行Linux0.11</title>
    <link href="http://harmansecurity.cn/2017/05/19/QEMU%E5%AE%89%E8%A3%85%E5%92%8C%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8CLinux0.11/"/>
    <id>http://harmansecurity.cn/2017/05/19/QEMU安装和调试运行Linux0.11/</id>
    <published>2017-05-19T06:33:12.000Z</published>
    <updated>2017-05-19T06:59:36.396Z</updated>
    
    <content type="html"><![CDATA[<p> 　 　首先遇到的一个问题就是虚拟机装了VMaretools还是得用Ctrl+Alt和Ctrl+G切入切出特别麻烦，而且虚拟机和物理机不能进行复制粘贴。重新安装了VMare tools也没有用，至少能让我复制粘贴，其他倒无所谓啊。试了不少办法都没解决问题，最后发现我虚拟机和物理机不是在一个网段，我物理机的ip是：192.168.115.23。我把我虚拟机的ip也设置成一个网段，命令式：<code>sudo ifconfig eth0 192.168.115.150</code>。</p>
<h4 id="一、QEMU安装"><a href="#一、QEMU安装" class="headerlink" title="一、QEMU安装"></a>一、QEMU安装</h4><ul>
<li><p>1.<code>sudo apt-get install libsdl1.2-dev</code> (安装一些必要的库，并不只是这个，可以根据参考资料的第二个链接)</p>
</li>
<li><p>2.<code>git clone git://git.qemu-project.org/qemu.git</code></p>
</li>
<li><p>3.进入qemu的目录下面：<code>./configure --enable-debug --enable-tcg-interpreter --enable-sdl --enable-gtk --enable-debug-info --enable-kvm --enable-vnc --enable-curses --prefix=/home/wlwaq/qemu</code>（prefix如果不配置默认是usr/local/bin，配置完的话运行就需要加前缀/home/wlwaq/qemu/bin如第六步）</p>
</li>
<li><p>4.<code>sudo make -j4</code></p>
</li>
<li><p>5.<code>sudo make install</code></p>
</li>
</ul>
<a id="more"></a>
<ul>
<li>6.<code>/home/wlwaq/qemu/bin/qemu-system-x86_64  -m 16M -L /home/wlwaq/qemu/pc-bios/ -boot a -fda Image -hda hdc-0.11.img -s -S -sdl -monitor stdio</code>(qemu-system-x86_64 –help可以知道“-s -S -sdl -monitor stdio ”代表什么意思）</li>
</ul>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/QEMU%E5%AE%89%E8%A3%85%E5%92%8C%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8CLinux0.111.png" alt=""></p>
<ul>
<li>7.（qemu）c 就可以启动Linux0.11了<br>如果需要用gdb调试，可见第四个参考资料链接。调试工具有：emacs(相当于gdb的图形化界面) Trace32 insight gdb<br>安装emacs的命令：<code>sudo apt-get install emacs</code>。</li>
</ul>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/QEMU%E5%AE%89%E8%A3%85%E5%92%8C%E8%B0%83%E8%AF%95%E8%BF%90%E8%A1%8CLinux0.112.png" alt=""></p>
<h4 id="二、参考资料"><a href="#二、参考资料" class="headerlink" title="二、参考资料"></a>二、参考资料</h4><ul>
<li><code>http://blog.chinaunix.net/uid-27117600-id-4148061.html</code></li>
<li><code>http://blog.csdn.net/liwugang43210/article/details/44155143</code></li>
<li><code>http://qemu-project.org/Hosts/Linux</code></li>
<li><code>http://blog.chinaunix.net/uid-26299634-id-4943500.html</code>(主要参考资料)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 　 　首先遇到的一个问题就是虚拟机装了VMaretools还是得用Ctrl+Alt和Ctrl+G切入切出特别麻烦，而且虚拟机和物理机不能进行复制粘贴。重新安装了VMare tools也没有用，至少能让我复制粘贴，其他倒无所谓啊。试了不少办法都没解决问题，最后发现我虚拟机和物理机不是在一个网段，我物理机的ip是：192.168.115.23。我把我虚拟机的ip也设置成一个网段，命令式：&lt;code&gt;sudo ifconfig eth0 192.168.115.150&lt;/code&gt;。&lt;/p&gt;
&lt;h4 id=&quot;一、QEMU安装&quot;&gt;&lt;a href=&quot;#一、QEMU安装&quot; class=&quot;headerlink&quot; title=&quot;一、QEMU安装&quot;&gt;&lt;/a&gt;一、QEMU安装&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1.&lt;code&gt;sudo apt-get install libsdl1.2-dev&lt;/code&gt; (安装一些必要的库，并不只是这个，可以根据参考资料的第二个链接)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2.&lt;code&gt;git clone git://git.qemu-project.org/qemu.git&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3.进入qemu的目录下面：&lt;code&gt;./configure --enable-debug --enable-tcg-interpreter --enable-sdl --enable-gtk --enable-debug-info --enable-kvm --enable-vnc --enable-curses --prefix=/home/wlwaq/qemu&lt;/code&gt;（prefix如果不配置默认是usr/local/bin，配置完的话运行就需要加前缀/home/wlwaq/qemu/bin如第六步）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4.&lt;code&gt;sudo make -j4&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;5.&lt;code&gt;sudo make install&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Linux0.11" scheme="http://harmansecurity.cn/tags/Linux0-11/"/>
    
      <category term="QEMU" scheme="http://harmansecurity.cn/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>Linux0.11系统调用原理</title>
    <link href="http://harmansecurity.cn/2017/05/19/Linux0.11%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://harmansecurity.cn/2017/05/19/Linux0.11系统调用原理/</id>
    <published>2017-05-19T06:20:11.000Z</published>
    <updated>2017-05-19T06:33:21.729Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、系统调用原理"><a href="#一、系统调用原理" class="headerlink" title="一、系统调用原理"></a>一、系统调用原理</h4><p>1.sys_call.s程序的功能描述：在Linux中，用户使用中断调用int 0x80和放在寄存器eax中的功能号来使用内核提供的各种功能服务，这些操作系统提供的功能被称为系统调用功能。通常用户并不是直接使用系统调用中断，而是通过函数库(例如 libc)中提供的接口函数来调用的。例如创建进程的系统调用fork可直接使用函数fork()即可。函数库libc中的fork()函数会实现对中断int 0x80的调用过程并把调用结果返回给用户程序。</p>
<p>由上可知：用户程序-&gt;libc.so-&gt;syscall-&gt;内核提供的各种服务</p>
<p>2.对于所有系统调用的实现函数，内核把他们按照系统调用功能号顺序排列成一张函数指针（地址）表（在include/linux/sys.h文件中）。然后在中断int 0x80的处理过程中根据用户提供的功能号调用对应系统调用函数进行处理。</p>
<a id="more"></a>
<p>3.程序在执行的时候首先会检查eax中的功能号是否有效(在给定的范围内)，如果无效中断返回，有效的话通过一个地址跳转表<code>(sys_call_table)</code>调用相应系统调用的函数。</p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%861.png" alt=""></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%862.png" alt=""></p>
<h4 id="二、参考资料"><a href="#二、参考资料" class="headerlink" title="二、参考资料"></a>二、参考资料</h4><ul>
<li><code>http://blog.csdn.net/sun20082567/article/details/38729561</code></li>
<li><code>http://blog.csdn.net/yhf19881015/article/details/7570354</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、系统调用原理&quot;&gt;&lt;a href=&quot;#一、系统调用原理&quot; class=&quot;headerlink&quot; title=&quot;一、系统调用原理&quot;&gt;&lt;/a&gt;一、系统调用原理&lt;/h4&gt;&lt;p&gt;1.sys_call.s程序的功能描述：在Linux中，用户使用中断调用int 0x80和放在寄存器eax中的功能号来使用内核提供的各种功能服务，这些操作系统提供的功能被称为系统调用功能。通常用户并不是直接使用系统调用中断，而是通过函数库(例如 libc)中提供的接口函数来调用的。例如创建进程的系统调用fork可直接使用函数fork()即可。函数库libc中的fork()函数会实现对中断int 0x80的调用过程并把调用结果返回给用户程序。&lt;/p&gt;
&lt;p&gt;由上可知：用户程序-&amp;gt;libc.so-&amp;gt;syscall-&amp;gt;内核提供的各种服务&lt;/p&gt;
&lt;p&gt;2.对于所有系统调用的实现函数，内核把他们按照系统调用功能号顺序排列成一张函数指针（地址）表（在include/linux/sys.h文件中）。然后在中断int 0x80的处理过程中根据用户提供的功能号调用对应系统调用函数进行处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="系统调用" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="Linux0.11" scheme="http://harmansecurity.cn/tags/Linux0-11/"/>
    
  </entry>
  
  <entry>
    <title>用户态和内核态</title>
    <link href="http://harmansecurity.cn/2017/05/19/%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81/"/>
    <id>http://harmansecurity.cn/2017/05/19/用户态和内核态/</id>
    <published>2017-05-19T04:32:28.000Z</published>
    <updated>2017-05-19T04:39:28.808Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、用户态和内核态的区别"><a href="#一、用户态和内核态的区别" class="headerlink" title="一、用户态和内核态的区别"></a>一、用户态和内核态的区别</h4><p>　 　当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程 的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。</p>
<p>　 　内核态与用户态是操作系统的两种运行级别, 跟intel cpu没有必然的联系, intel cpu提供Ring0-Ring3三种级别的运行模式，Ring0级别高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部 分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必 须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。</p>
<p>　 　至于说保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据。</p>
<a id="more"></a>
<h4 id="二、用户态和内核态的转换"><a href="#二、用户态和内核态的转换" class="headerlink" title="二、用户态和内核态的转换"></a>二、用户态和内核态的转换</h4><p><strong>用户态切换到内核态的3种方式</strong></p>
<ul>
<li><p>a. 系统调用<br>　 　这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使 用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户 特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
</li>
<li><p>b. 异常<br>　 　当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</li>
<li><p>c. 外围设备的中断<br>　 　当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会 暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到 内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</li>
</ul>
<p>　 　这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p>
<h4 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h4><ul>
<li><code>http://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html</code></li>
<li><code>http://blog.csdn.net/tommy_wxie/article/details/17122923/</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、用户态和内核态的区别&quot;&gt;&lt;a href=&quot;#一、用户态和内核态的区别&quot; class=&quot;headerlink&quot; title=&quot;一、用户态和内核态的区别&quot;&gt;&lt;/a&gt;一、用户态和内核态的区别&lt;/h4&gt;&lt;p&gt;　 　当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程 的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。&lt;/p&gt;
&lt;p&gt;　 　内核态与用户态是操作系统的两种运行级别, 跟intel cpu没有必然的联系, intel cpu提供Ring0-Ring3三种级别的运行模式，Ring0级别高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部 分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必 须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。&lt;/p&gt;
&lt;p&gt;　 　至于说保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="用户态" scheme="http://harmansecurity.cn/tags/%E7%94%A8%E6%88%B7%E6%80%81/"/>
    
      <category term="内核态" scheme="http://harmansecurity.cn/tags/%E5%86%85%E6%A0%B8%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Linux0.11内核添加系统调用</title>
    <link href="http://harmansecurity.cn/2017/05/19/Linux0.11%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://harmansecurity.cn/2017/05/19/Linux0.11内核添加系统调用/</id>
    <published>2017-05-19T03:18:32.000Z</published>
    <updated>2017-05-19T03:37:12.521Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、实验步骤"><a href="#一、实验步骤" class="headerlink" title="一、实验步骤"></a>一、实验步骤</h4><p><strong>1.首先在linux0.11/lib下添加两个文件：writeeax.c,readeax.c</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__     !一边是两个下滑线</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line">_syscall0(<span class="keyword">int</span>,writeeax)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __LIBRARY__     !一边是两个下滑线</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line">_syscall0(<span class="keyword">int</span>,readeax)</div></pre></td></tr></table></figure>
<p><strong>2.接下来修改linux0.11/include下的unistd.h，添加两个系统调用号</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_writeeax 72   !NR前面2个_，72是比里面最大的调用号大1个数</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_readeax 73</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeeax</span><span class="params">(<span class="keyword">void</span>)</span></span>;    !在linux/include/unistd.h文件最下面添加</div><div class="line"><span class="function">Int <span class="title">readeax</span><span class="params">(<span class="keyword">void</span>)</span></span>;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>3.接着在linux/include/linux下的sys.h添加</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_writeeax</span><span class="params">()</span></span>;</div><div class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">sys_readeax</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">!Sys.h下面的sys_call_table[]里面到末尾按顺序添加：</div><div class="line"></div><div class="line">sys_writeeax,sys_readeax</div></pre></td></tr></table></figure>
<p><strong>4.到linux/kernel下编写一个mysys.c文件实现添加的两个系统调用函数</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A81.png" alt=""></p>
<p><strong>5.修改linux/kernel/Makefile最后面添加mysys.o</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A83.png" alt=""></p>
<p><strong>6.编写测试函数test.c</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E5%86%85%E6%A0%B8%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A82.png" alt=""></p>
<h4 id="二、实验总结"><a href="#二、实验总结" class="headerlink" title="二、实验总结"></a>二、实验总结</h4><p>　 　在内核里面添加系统调用的基本步骤就是上面这几步，如果需要更深的了解还是需要好好找本内核的书《Linux内核完全剖析》来阅读，了解其中的原理。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、实验步骤&quot;&gt;&lt;a href=&quot;#一、实验步骤&quot; class=&quot;headerlink&quot; title=&quot;一、实验步骤&quot;&gt;&lt;/a&gt;一、实验步骤&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.首先在linux0.11/lib下添加两个文件：writeeax.c,readeax.c&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; __LIBRARY__     !一边是两个下滑线&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_syscall0(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;,writeeax)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; __LIBRARY__     !一边是两个下滑线&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt;&lt;span class=&quot;meta-string&quot;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;_syscall0(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;,readeax)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;2.接下来修改linux0.11/include下的unistd.h，添加两个系统调用号&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; __NR_writeeax 72   !NR前面2个_，72是比里面最大的调用号大1个数&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; __NR_readeax 73&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;writeeax&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;    !在linux/include/unistd.h文件最下面添加&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;Int &lt;span class=&quot;title&quot;&gt;readeax&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="系统调用" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="Linux0.11" scheme="http://harmansecurity.cn/tags/Linux0-11/"/>
    
  </entry>
  
  <entry>
    <title>Linux0.11获取系统调用号</title>
    <link href="http://harmansecurity.cn/2017/05/19/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7/"/>
    <id>http://harmansecurity.cn/2017/05/19/Linux0.11获取系统调用号/</id>
    <published>2017-05-19T03:02:21.000Z</published>
    <updated>2017-05-19T11:28:51.562Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、实验步骤"><a href="#一、实验步骤" class="headerlink" title="一、实验步骤"></a>一、实验步骤</h4><p><strong>1.修改linux0.11/kernel/sys_call.s添加call achieveEax</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B71.png" alt=""></p>
<p><strong>2.在linux0.11/kernel底下添加achieveEax.c文件</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B72.png" alt=""></p>
<a id="more"></a>
<p><strong>3.修改linux0.11/kernel/Makefile添加achieveEax.o</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B73.png" alt=""></p>
<p><strong>4.最后的运行结果</strong></p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B74.png" alt=""></p>
<h4 id="二、实验平台"><a href="#二、实验平台" class="headerlink" title="二、实验平台"></a>二、实验平台</h4><ul>
<li>1.实验平台源码：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/hit-oslab-linux-20110823/oslab</code></li>
<li>2.获取调用号源码：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7</code></li>
<li>3.实验平台使用：到“实验楼”搜索“操作系统原理与实践”：<code>https://www.shiyanlou.com/courses/115</code>,将第一个实验做一下就知道该如何使用平台了，这里不再赘述。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、实验步骤&quot;&gt;&lt;a href=&quot;#一、实验步骤&quot; class=&quot;headerlink&quot; title=&quot;一、实验步骤&quot;&gt;&lt;/a&gt;一、实验步骤&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.修改linux0.11/kernel/sys_call.s添加call achieveEax&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B71.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.在linux0.11/kernel底下添加achieveEax.c文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B72.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Linux0.11" scheme="http://harmansecurity.cn/tags/Linux0-11/"/>
    
      <category term="系统调用号" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7/"/>
    
  </entry>
  
  <entry>
    <title>Bochs运行Linux0.11内核</title>
    <link href="http://harmansecurity.cn/2017/05/19/Bochs%E8%BF%90%E8%A1%8CLinux0.11%E5%86%85%E6%A0%B8/"/>
    <id>http://harmansecurity.cn/2017/05/19/Bochs运行Linux0.11内核/</id>
    <published>2017-05-19T02:36:21.000Z</published>
    <updated>2017-05-19T11:32:08.383Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Bochs安装"><a href="#一、Bochs安装" class="headerlink" title="一、Bochs安装"></a>一、Bochs安装</h4><p><strong>1.手动安装</strong></p>
<p>具体的安装步骤可以参考这篇博客，很详细：<code>http://os.51cto.com/art/201407/446838_all.htm</code></p>
<p>安装过程中遇到的一个小问题：</p>
<p><img src="http://ojto7c1rw.bkt.clouddn.com/Bochs%E8%BF%90%E8%A1%8CLinux0.11%E5%86%85%E6%A0%B8.png" alt=""></p>
<p>解决方法：我的解决方法与博客里面提到的不一样：打开Makefile文件，找到<code>X_LIBS=</code> 添加“-lpthread” 即 <code>X_LIBS=-lpthread.S</code></p>
<p><strong>2.源安装</strong></p>
<p>安装本身源里面的bochs:<code>sudo apt-get install bochs</code></p>
<a id="more"></a>
<h4 id="二、编译Linux0-11内核"><a href="#二、编译Linux0-11内核" class="headerlink" title="二、编译Linux0.11内核"></a>二、编译Linux0.11内核</h4><ul>
<li>1.进入linux-0.11目录下：make 会提示: make：as86:命令未找到。解决办法是：<code>sudo apt-get install bin86</code></li>
<li>2.因为我是64位的机器所以会报这样的错误：<code>boot/head.s :Error...........</code>。解决方法：在Makefile的as后面加 <code>--32</code>，注意“–”前面有空格；CFLAGS中加-m32，注意这个无空格。</li>
</ul>
<h4 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h4><p>　 　在Linux0.11编译的过程中会遇到很多问题，再加上Ubuntu各版本不同，需要耐心的解决。可编译成功的源码：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/Linux-0.11-master</code>。与bochs集成的Linux0.11编译开发环境：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/linux-0.11-devel-040809</code>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、Bochs安装&quot;&gt;&lt;a href=&quot;#一、Bochs安装&quot; class=&quot;headerlink&quot; title=&quot;一、Bochs安装&quot;&gt;&lt;/a&gt;一、Bochs安装&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;1.手动安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体的安装步骤可以参考这篇博客，很详细：&lt;code&gt;http://os.51cto.com/art/201407/446838_all.htm&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;安装过程中遇到的一个小问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/Bochs%E8%BF%90%E8%A1%8CLinux0.11%E5%86%85%E6%A0%B8.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;解决方法：我的解决方法与博客里面提到的不一样：打开Makefile文件，找到&lt;code&gt;X_LIBS=&lt;/code&gt; 添加“-lpthread” 即 &lt;code&gt;X_LIBS=-lpthread.S&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.源安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;安装本身源里面的bochs:&lt;code&gt;sudo apt-get install bochs&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Bochs" scheme="http://harmansecurity.cn/tags/Bochs/"/>
    
      <category term="Linux0.11" scheme="http://harmansecurity.cn/tags/Linux0-11/"/>
    
  </entry>
  
  <entry>
    <title>系统调用hook技术总结</title>
    <link href="http://harmansecurity.cn/2017/05/19/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8Hook%E6%8A%80%E6%9C%AF%E6%80%BB%E7%BB%93/"/>
    <id>http://harmansecurity.cn/2017/05/19/系统调用Hook技术总结/</id>
    <published>2017-05-19T02:13:21.000Z</published>
    <updated>2017-05-19T11:25:37.538Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、系统调用原理"><a href="#一、系统调用原理" class="headerlink" title="一、系统调用原理"></a>一、系统调用原理</h4><p>　 　Linux中实现系统调用时是利用了i386体系结构中的软中断，通过产生0x80中 断，使程序由用户态进入内核态执行系统调用函数。当系统调用发生时，产生0x80中断，CPU被切换到内核态执行中断向量表IDT对应的0x80中断处理函数，即跳转到了system_call()的入口，system_call()函数检查系统调用号，到系统调用表sys_call_table中找到该 系统调用（号）对应的内核函数入口，接着调用这个内核函数，然后返回。</p>
<p>终端输入：<code>sudo cat /proc/kallsyms | grep sys_call_table</code></p>
<p>终端输出：<code>ffffffff81a001c0 R sys_call_table</code></p>
<p>由上面可发现其中 R 直接显示了这段内存是只读的性质，这就引出了第二步骤“取消页读写保护”。</p>
<p><strong>整理出来的系统调用hook参考链接：</strong>(对hook感兴趣的可以了解下)</p>
<ul>
<li><code>http://www.tuicool.com/articles/nEnm2u</code></li>
<li><code>http://blog.csdn.net/maochengtao/article/details/23598433</code></li>
<li><code>http://blog.csdn.net/force_eagle/article/details/3938150</code></li>
<li><code>http://blog.chinaunix.net/uid-9164976-id-2435342.html</code></li>
<li><code>http://blog.chinaunix.net/uid-7330656-id-2644670.html</code></li>
<li><code>http://www.oschina.net/code/snippet_54100_1509</code></li>
<li><code>http://blog.sina.com.cn/s/blog_a2acdfc70100zqa7.html</code></li>
<li><code>http://blog.csdn.net/sun20082567/article/details/38729561</code></li>
</ul>
<a id="more"></a>
<h4 id="二、相关技术学习-C语言内联汇编的学习"><a href="#二、相关技术学习-C语言内联汇编的学习" class="headerlink" title="二、相关技术学习(C语言内联汇编的学习)"></a>二、相关技术学习(C语言内联汇编的学习)</h4><ul>
<li><code>http://www.nagain.com/activity/article/18/</code></li>
<li><code>http://blog.csdn.net/liuqiaoyu080512/article/details/8457528</code></li>
<li><code>http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html</code></li>
</ul>
<h4 id="三、naked函数"><a href="#三、naked函数" class="headerlink" title="三、naked函数"></a>三、naked函数</h4><p>　 　naked函数，即所谓的“裸函数”，对于这种函数，编译器不会生成任何函数入口代码和退出代码。这种函数一般应用在与操作系统内核相关的代码中，如中断处理函数、钩子函数等。 naked 特性仅适用于 x86和ARM，并不用于 x64 。</p>
<p><code>__attribute__((naked)) void  test()</code></p>
<p><strong>参考资料：</strong></p>
<ul>
<li><code>http://blog.atelier39.org/compiler_disasm/94.html</code></li>
<li><code>http://www.cnblogs.com/jiu0821/p/4507281.html</code>  </li>
</ul>
<h4 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h4><p>　 　上面的参考链接对我当时学习系统调用hook技术有很大帮助，这里整理出来分享给大家。</p>
<p>　 　<strong>源码地址是：<code>https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/hookdemo</code></strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一、系统调用原理&quot;&gt;&lt;a href=&quot;#一、系统调用原理&quot; class=&quot;headerlink&quot; title=&quot;一、系统调用原理&quot;&gt;&lt;/a&gt;一、系统调用原理&lt;/h4&gt;&lt;p&gt;　 　Linux中实现系统调用时是利用了i386体系结构中的软中断，通过产生0x80中 断，使程序由用户态进入内核态执行系统调用函数。当系统调用发生时，产生0x80中断，CPU被切换到内核态执行中断向量表IDT对应的0x80中断处理函数，即跳转到了system_call()的入口，system_call()函数检查系统调用号，到系统调用表sys_call_table中找到该 系统调用（号）对应的内核函数入口，接着调用这个内核函数，然后返回。&lt;/p&gt;
&lt;p&gt;终端输入：&lt;code&gt;sudo cat /proc/kallsyms | grep sys_call_table&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;终端输出：&lt;code&gt;ffffffff81a001c0 R sys_call_table&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由上面可发现其中 R 直接显示了这段内存是只读的性质，这就引出了第二步骤“取消页读写保护”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整理出来的系统调用hook参考链接：&lt;/strong&gt;(对hook感兴趣的可以了解下)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;http://www.tuicool.com/articles/nEnm2u&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.csdn.net/maochengtao/article/details/23598433&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.csdn.net/force_eagle/article/details/3938150&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.chinaunix.net/uid-9164976-id-2435342.html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.chinaunix.net/uid-7330656-id-2644670.html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://www.oschina.net/code/snippet_54100_1509&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.sina.com.cn/s/blog_a2acdfc70100zqa7.html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;http://blog.csdn.net/sun20082567/article/details/38729561&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="系统调用" scheme="http://harmansecurity.cn/tags/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    
      <category term="hook" scheme="http://harmansecurity.cn/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>2017年4月小结</title>
    <link href="http://harmansecurity.cn/2017/05/03/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%93/"/>
    <id>http://harmansecurity.cn/2017/05/03/2017年4月小结/</id>
    <published>2017-05-03T13:19:31.000Z</published>
    <updated>2017-05-04T04:48:48.785Z</updated>
    
    <content type="html"><![CDATA[<p>　　最近一直在忙于看书和完成自己制定计划的第二阶段，没时间写博客。刚刚参加完“感动师大”的晚会，内心思绪万千，也对上个月做个小结。三月份的时候，对自己未来想要做什么有了一个大概的认识，制定了接下来要完成的相关计划。</p>
<ul>
<li>第一阶段(2017.3.19-2017.4.10)：Java基础学习(深入),将某马的Java基础视频教程撸了一遍，记满了一个笔记本。对“反射”、“并发”、“多线程”、“IO流”、“序列化”、“集合泛型”等知识点又有了一个新的认识。期间也阅读了&lt;&lt;重构&gt;&gt;以及电子版的&lt;&lt; head first Java &gt;&gt;。原本想对每节基础课都写个博客，只是时间不允许，所以相关知识点都记在了笔记本上，这里直接放图啦啊，字写的有点潦草(⊙o⊙)。<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%931.jpg" alt=""><br></div>

</li>
</ul>
<a id="more"></a>
<ul>
<li>第二阶段(2017.4.10-2017.5.15)：JavaWeb学习+(SpringMvc+MyBatics)，期间看了《代码整洁之道》、《Java多线程编程核心技术》、《深入理解Java虚拟机》(前两章)、《Java核心技术基础知识》并发这一章节。<br>　　<br>　　前两个阶段的学习算是对以前学习的查漏补缺、巩固、总结，长时间不用很多都遗忘了。接下里的学习计划是阅读相关书籍(每个阶段根据计划内容阅读相关书籍)、学习分布式、框架详细研究、做算法题、项目开发。前两个阶段偏重于理论的学习，接下来的计划安排里应该会侧重于实践，把所看的书里面的知识点尽量能在项目中实现，这样体会更深刻。下面是劳动节前夕买的书，利用放假充裕的时间看书，哈哈。<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%932.jpg" alt=""><br></div><br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%933.jpg" alt=""><br></div><br>　　因为阿里、网易在杭州，目标一直都是阿里，所以很想去杭州看看。趁着第一阶段的计划完成，四月的中旬去了趟杭州，玩了西湖、西溪湿地以及河坊街。原来杭州也很挤啊，人好多，总体感觉还行。不怎么喜欢拍照，室友都说我老，这里我厚着脸皮放一张照片为了证明我并不是那么丑，难道是我眼光的问题？<br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%934.jpg" alt=""><br></div><br>　　来了师大这么久，很少参加活动，今天被邀请参加“感动师大”，真的是思绪万千，对师大人又有了一个新的认识，身边还是有很多优秀的人值得我们去学习，他们的精神我们也应该拥有。”知其然，知其所以然。”是自己的终极目标。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　最近一直在忙于看书和完成自己制定计划的第二阶段，没时间写博客。刚刚参加完“感动师大”的晚会，内心思绪万千，也对上个月做个小结。三月份的时候，对自己未来想要做什么有了一个大概的认识，制定了接下来要完成的相关计划。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一阶段(2017.3.19-2017.4.10)：Java基础学习(深入),将某马的Java基础视频教程撸了一遍，记满了一个笔记本。对“反射”、“并发”、“多线程”、“IO流”、“序列化”、“集合泛型”等知识点又有了一个新的认识。期间也阅读了&amp;lt;&amp;lt;重构&amp;gt;&amp;gt;以及电子版的&amp;lt;&amp;lt; head first Java &amp;gt;&amp;gt;。原本想对每节基础课都写个博客，只是时间不允许，所以相关知识点都记在了笔记本上，这里直接放图啦啊，字写的有点潦草(⊙o⊙)。&lt;div align=center&gt;&lt;br&gt;&lt;img src=&quot;http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B44%E6%9C%88%E5%B0%8F%E7%BB%931.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://harmansecurity.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="小结" scheme="http://harmansecurity.cn/tags/%E5%B0%8F%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(九)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B9%9D)%20/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(九) /</id>
    <published>2017-03-19T14:52:21.000Z</published>
    <updated>2017-03-19T15:18:22.554Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<code>http://bbs.itheima.com/thread-270994-1-1.html</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接：&lt;code&gt;http://bbs.itheima.com/thread-270994-1-1.html&lt;/code&gt;&lt;/p&gt;

    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="多态" scheme="http://harmansecurity.cn/tags/%E5%A4%9A%E6%80%81/"/>
    
      <category term="抽象类" scheme="http://harmansecurity.cn/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    
      <category term="接口" scheme="http://harmansecurity.cn/tags/%E6%8E%A5%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(八)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AB)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(八)/</id>
    <published>2017-03-19T14:45:21.000Z</published>
    <updated>2017-03-19T15:18:12.209Z</updated>
    
    <content type="html"><![CDATA[<h3 id="08-01-面向对象-代码块的概述和分类-了解-面试的时候会问-开发不用或者很少用"><a href="#08-01-面向对象-代码块的概述和分类-了解-面试的时候会问-开发不用或者很少用" class="headerlink" title="08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用)"></a>08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用)</h3><ul>
<li>A:代码块概述<ul>
<li>在Java中，使用{}括起来的代码被称为代码块。</li>
</ul>
</li>
<li>B:代码块分类<ul>
<li>根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。</li>
</ul>
</li>
<li>C:常见代码块的应用<ul>
<li>a:局部代码块 <ul>
<li>在方法中出现；限定变量生命周期，及早释放，提高内存利用率</li>
</ul>
</li>
<li>b:构造代码块 (初始化块)<ul>
<li>在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行</li>
</ul>
</li>
<li>c:静态代码块 <ul>
<li>在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。</li>
<li>一般用于加载驱动</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="08-02-面向对象-代码块的面试题-掌握"><a href="#08-02-面向对象-代码块的面试题-掌握" class="headerlink" title="08.02_面向对象(代码块的面试题)(掌握)"></a>08.02_面向对象(代码块的面试题)(掌握)</h3><ul>
<li>A:看程序写结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">class Student &#123;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;Student 静态代码块&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">		System.out.println(&quot;Student 构造代码块&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Student() &#123;</div><div class="line">		System.out.println(&quot;Student 构造方法&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">class Demo2_Student &#123;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;Demo2_Student静态代码块&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		System.out.println(&quot;我是main方法&quot;);</div><div class="line">		</div><div class="line">		Student s1 = new Student();</div><div class="line">		Student s2 = new Student();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="08-03-面向对象-继承案例演示-掌握"><a href="#08-03-面向对象-继承案例演示-掌握" class="headerlink" title="08.03_面向对象(继承案例演示)(掌握)"></a>08.03_面向对象(继承案例演示)(掌握)</h3><ul>
<li>A:继承(extends)<ul>
<li>让类与类之间产生关系,子父类关系 </li>
</ul>
</li>
<li>B:继承案例演示：<ul>
<li>动物类,猫类,狗类</li>
<li>定义两个属性(颜色,腿的个数)两个功能(吃饭，睡觉)</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>使用继承前</li>
</ul>
</li>
<li>D:案例演示<ul>
<li>使用继承后</li>
</ul>
</li>
</ul>
<h3 id="08-04-面向对象-继承的好处和弊端-掌握"><a href="#08-04-面向对象-继承的好处和弊端-掌握" class="headerlink" title="08.04_面向对象(继承的好处和弊端)(掌握)"></a>08.04_面向对象(继承的好处和弊端)(掌握)</h3><ul>
<li>A:继承的好处<ul>
<li>a:提高了代码的复用性</li>
<li>b:提高了代码的维护性</li>
<li>c:让类与类之间产生了关系，是多态的前提</li>
</ul>
</li>
<li><p>B:继承的弊端</p>
<ul>
<li><p>类的耦合性增强了。</p>
</li>
<li><p>开发的原则：高内聚，低耦合。</p>
</li>
<li>耦合：类与类的关系</li>
<li>内聚：就是自己完成某件事情的能力</li>
</ul>
</li>
</ul>
<h3 id="08-05-面向对象-Java中类的继承特点-掌握"><a href="#08-05-面向对象-Java中类的继承特点-掌握" class="headerlink" title="08.05_面向对象(Java中类的继承特点)(掌握)"></a>08.05_面向对象(Java中类的继承特点)(掌握)</h3><ul>
<li>A:Java中类的继承特点<ul>
<li>a:Java只支持单继承，不支持多继承。(一个儿子只能有一个爹)<ul>
<li>有些语言是支持多继承，格式：extends 类1,类2,…</li>
</ul>
</li>
<li>b:Java支持多层继承(继承体系)</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>Java中类的继承特点<ul>
<li>如果想用这个体系的所有功能用最底层的类创建对象</li>
<li>如果想看这个体系的共性功能,看最顶层的类 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="08-06-面向对象-继承的注意事项和什么时候使用继承-掌握"><a href="#08-06-面向对象-继承的注意事项和什么时候使用继承-掌握" class="headerlink" title="08.06_面向对象(继承的注意事项和什么时候使用继承)(掌握)"></a>08.06_面向对象(继承的注意事项和什么时候使用继承)(掌握)</h3><ul>
<li>A:继承的注意事项<ul>
<li>a:子类只能继承父类所有非私有的成员(成员方法和成员变量)</li>
<li>b:子类不能继承父类的构造方法，但是可以通过super(马上讲)关键字去访问父类构造方法。</li>
<li>c:不要为了部分功能而去继承</li>
<li>项目经理 姓名 工号 工资 奖金</li>
<li>程序员    姓名 工号 工资</li>
</ul>
</li>
<li><p>B:什么时候使用继承</p>
<ul>
<li><p>继承其实体现的是一种关系：”is a”。<br>  Person</p>
<pre><code>Student
Teacher
</code></pre><p>  水果</p>
<pre><code>苹果
香蕉
橘子
</code></pre><p>采用假设法。<br>  如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。</p>
</li>
</ul>
</li>
</ul>
<h3 id="08-07-面向对象-继承中成员变量的关系-掌握"><a href="#08-07-面向对象-继承中成员变量的关系-掌握" class="headerlink" title="08.07_面向对象(继承中成员变量的关系)(掌握)"></a>08.07_面向对象(继承中成员变量的关系)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>a:不同名的变量</li>
<li>b:同名的变量<br>###08.08_面向对象(this和super的区别和应用)(掌握)</li>
</ul>
</li>
<li>A:this和super都代表什么<ul>
<li>this:代表当前对象的引用,谁来调用我,我就代表谁</li>
<li>super:代表当前对象父类的引用</li>
</ul>
</li>
<li>B:this和super的使用区别<ul>
<li>a:调用成员变量<ul>
<li>this.成员变量 调用本类的成员变量,也可以调用父类的成员变量</li>
<li>super.成员变量 调用父类的成员变量</li>
</ul>
</li>
<li>b:调用构造方法<ul>
<li>this(…)    调用本类的构造方法</li>
<li>super(…)    调用父类的构造方法</li>
</ul>
</li>
<li>c:调用成员方法<ul>
<li>this.成员方法 调用本类的成员方法,也可以调用父类的方法</li>
<li>super.成员方法 调用父类的成员方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="08-09-面向对象-继承中构造方法的关系-掌握"><a href="#08-09-面向对象-继承中构造方法的关系-掌握" class="headerlink" title="08.09_面向对象(继承中构造方法的关系)(掌握)"></a>08.09_面向对象(继承中构造方法的关系)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>子类中所有的构造方法默认都会访问父类中空参数的构造方法</li>
</ul>
</li>
<li><p>B:为什么呢?</p>
<ul>
<li>因为子类会继承父类中的数据，可能还会使用父类的数据。</li>
<li><p>所以，子类初始化之前，一定要先完成父类数据的初始化。</p>
</li>
<li><p>其实：</p>
<ul>
<li>每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="08-10-面向对象-继承中构造方法的注意事项-掌握"><a href="#08-10-面向对象-继承中构造方法的注意事项-掌握" class="headerlink" title="08.10_面向对象(继承中构造方法的注意事项)(掌握)"></a>08.10_面向对象(继承中构造方法的注意事项)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>父类没有无参构造方法,子类怎么办?</li>
<li>super解决</li>
<li>this解决</li>
</ul>
</li>
<li>B:注意事项<ul>
<li>super(…)或者this(….)必须出现在构造方法的第一条语句上</li>
</ul>
</li>
</ul>
<h3 id="08-11-面向对象-继承中的面试题-掌握"><a href="#08-11-面向对象-继承中的面试题-掌握" class="headerlink" title="08.11_面向对象(继承中的面试题)(掌握)"></a>08.11_面向对象(继承中的面试题)(掌握)</h3><ul>
<li>A:案例演示</li>
<li><p>看程序写结果1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">class Fu&#123;</div><div class="line">	public int num = 10;</div><div class="line">	public Fu()&#123;</div><div class="line">		System.out.println(&quot;fu&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Zi extends Fu&#123;</div><div class="line">	public int num = 20;</div><div class="line">	public Zi()&#123;</div><div class="line">		System.out.println(&quot;zi&quot;);</div><div class="line">	&#125;</div><div class="line">	public void show()&#123;</div><div class="line">		int num = 30;</div><div class="line">		System.out.println(num);</div><div class="line">		System.out.println(this.num);</div><div class="line">		System.out.println(super.num);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">class Test1_Extends &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Zi z = new Zi();</div><div class="line">		z.show();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看程序写结果2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">class Fu &#123;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;静态代码块Fu&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">		System.out.println(&quot;构造代码块Fu&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Fu() &#123;</div><div class="line">		System.out.println(&quot;构造方法Fu&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">class Zi extends Fu &#123;</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;静态代码块Zi&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	&#123;</div><div class="line">		System.out.println(&quot;构造代码块Zi&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public Zi() &#123;</div><div class="line">		System.out.println(&quot;构造方法Zi&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">	</div><div class="line">Zi z = new Zi(); 请执行结果。</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="08-12-面向对象-继承中成员方法关系-掌握"><a href="#08-12-面向对象-继承中成员方法关系-掌握" class="headerlink" title="08.12_面向对象(继承中成员方法关系)(掌握)"></a>08.12_面向对象(继承中成员方法关系)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>a:不同名的方法</li>
<li>b:同名的方法</li>
</ul>
</li>
</ul>
<h3 id="08-13-面向对象-方法重写概述及其应用-掌握"><a href="#08-13-面向对象-方法重写概述及其应用-掌握" class="headerlink" title="08.13_面向对象(方法重写概述及其应用)(掌握)"></a>08.13_面向对象(方法重写概述及其应用)(掌握)</h3><ul>
<li>A:什么是方法重写<ul>
<li>重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) </li>
</ul>
</li>
<li>B:方法重写的应用：<ul>
<li>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>a:定义一个手机类。</li>
</ul>
</li>
</ul>
<h3 id="08-14-面向对象-方法重写的注意事项-掌握"><a href="#08-14-面向对象-方法重写的注意事项-掌握" class="headerlink" title="08.14_面向对象(方法重写的注意事项)(掌握)"></a>08.14_面向对象(方法重写的注意事项)(掌握)</h3><ul>
<li><p>A:方法重写注意事项</p>
<ul>
<li>a:父类中私有方法不能被重写<ul>
<li>因为父类私有方法子类根本就无法继承</li>
</ul>
</li>
<li>b:子类重写父类方法时，访问权限不能更低<ul>
<li>最好就一致</li>
</ul>
</li>
<li><p>c:父类静态方法，子类也必须通过静态方法进行重写</p>
<ul>
<li>其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态)</li>
</ul>
</li>
<li><p>子类重写父类方法的时候，最好声明一模一样。</p>
</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>方法重写注意事项</li>
</ul>
</li>
</ul>
<h3 id="08-15-面向对象-方法重写的面试题-掌握"><a href="#08-15-面向对象-方法重写的面试题-掌握" class="headerlink" title="08.15_面向对象(方法重写的面试题)(掌握)"></a>08.15_面向对象(方法重写的面试题)(掌握)</h3><ul>
<li><p>A:方法重写的面试题</p>
<ul>
<li>Override和Overload的区别?Overload能改变返回值类型吗?</li>
<li>overload可以改变返回值类型,只看参数列表</li>
<li><p>方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的</p>
</li>
<li><p>方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。</p>
</li>
<li><p>子类对象调用方法的时候：</p>
<ul>
<li>先找子类本身，再找父类。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="08-16-面向对象-使用继承前的学生和老师案例-掌握"><a href="#08-16-面向对象-使用继承前的学生和老师案例-掌握" class="headerlink" title="08.16_面向对象(使用继承前的学生和老师案例)(掌握)"></a>08.16_面向对象(使用继承前的学生和老师案例)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>使用继承前的学生和老师案例</li>
<li>属性:姓名,年龄</li>
<li>行为:吃饭</li>
<li>老师有特有的方法:讲课</li>
<li>学生有特有的方法:学习</li>
</ul>
</li>
</ul>
<h3 id="08-17-面向对象-使用继承后的学生和老师案例-掌握"><a href="#08-17-面向对象-使用继承后的学生和老师案例-掌握" class="headerlink" title="08.17_面向对象(使用继承后的学生和老师案例)(掌握)"></a>08.17_面向对象(使用继承后的学生和老师案例)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>使用继承后的学生和老师案例</li>
</ul>
</li>
</ul>
<h3 id="08-18-面向对象-猫狗案例分析-实现及测试-掌握"><a href="#08-18-面向对象-猫狗案例分析-实现及测试-掌握" class="headerlink" title="08.18_面向对象(猫狗案例分析,实现及测试)(掌握)"></a>08.18_面向对象(猫狗案例分析,实现及测试)(掌握)</h3><ul>
<li>A:猫狗案例分析</li>
<li>B:案例演示<ul>
<li>猫狗案例继承版</li>
<li>属性:毛的颜色,腿的个数</li>
<li>行为:吃饭</li>
<li>猫特有行为:抓老鼠catchMouse</li>
<li>狗特有行为:看家lookHome</li>
</ul>
</li>
</ul>
<h3 id="08-19-面向对象-final关键字修饰类-方法以及变量的特点-掌握"><a href="#08-19-面向对象-final关键字修饰类-方法以及变量的特点-掌握" class="headerlink" title="08.19_面向对象(final关键字修饰类,方法以及变量的特点)(掌握)"></a>08.19_面向对象(final关键字修饰类,方法以及变量的特点)(掌握)</h3><ul>
<li>A:final概述</li>
<li>B:final修饰特点<ul>
<li>修饰类，类不能被继承</li>
<li>修饰变量，变量就变成了常量，只能被赋值一次</li>
<li>修饰方法，方法不能被重写</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>final修饰特点</li>
</ul>
</li>
</ul>
<h3 id="08-20-面向对象-final关键字修饰局部变量-掌握"><a href="#08-20-面向对象-final关键字修饰局部变量-掌握" class="headerlink" title="08.20_面向对象(final关键字修饰局部变量)(掌握)"></a>08.20_面向对象(final关键字修饰局部变量)(掌握)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li><p>方法内部或者方法声明上都演示一下(了解)</p>
</li>
<li><p>基本类型，是值不能被改变</p>
</li>
<li>引用类型，是地址值不能被改变,对象中的属性可以改变</li>
</ul>
</li>
</ul>
<h3 id="08-21-面向对象-final修饰变量的初始化时机-掌握"><a href="#08-21-面向对象-final修饰变量的初始化时机-掌握" class="headerlink" title="08.21_面向对象(final修饰变量的初始化时机)(掌握)"></a>08.21_面向对象(final修饰变量的初始化时机)(掌握)</h3><ul>
<li>A:final修饰变量的初始化时机<ul>
<li>显示初始化 </li>
<li>在对象构造完毕前即可</li>
</ul>
</li>
</ul>
<h3 id="08-22-day08总结"><a href="#08-22-day08总结" class="headerlink" title="08.22_day08总结"></a>08.22_day08总结</h3><ul>
<li>把今天的知识点总结一遍。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;08-01-面向对象-代码块的概述和分类-了解-面试的时候会问-开发不用或者很少用&quot;&gt;&lt;a href=&quot;#08-01-面向对象-代码块的概述和分类-了解-面试的时候会问-开发不用或者很少用&quot; class=&quot;headerlink&quot; title=&quot;08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用)&quot;&gt;&lt;/a&gt;08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:代码块概述&lt;ul&gt;
&lt;li&gt;在Java中，使用{}括起来的代码被称为代码块。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:代码块分类&lt;ul&gt;
&lt;li&gt;根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C:常见代码块的应用&lt;ul&gt;
&lt;li&gt;a:局部代码块 &lt;ul&gt;
&lt;li&gt;在方法中出现；限定变量生命周期，及早释放，提高内存利用率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;b:构造代码块 (初始化块)&lt;ul&gt;
&lt;li&gt;在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;c:静态代码块 &lt;ul&gt;
&lt;li&gt;在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。&lt;/li&gt;
&lt;li&gt;一般用于加载驱动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="继承" scheme="http://harmansecurity.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(七)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%83)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(七)/</id>
    <published>2017-03-19T14:41:21.000Z</published>
    <updated>2017-03-19T15:16:56.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="07-01-面向对象-构造方法Constructor概述和格式-掌握"><a href="#07-01-面向对象-构造方法Constructor概述和格式-掌握" class="headerlink" title="07.01_面向对象(构造方法Constructor概述和格式)(掌握)"></a>07.01_面向对象(构造方法Constructor概述和格式)(掌握)</h3><ul>
<li>A:构造方法概述和作用<ul>
<li>给对象的数据(属性)进行初始化</li>
</ul>
</li>
<li>B:构造方法格式特点<ul>
<li>a:方法名与类名相同(大小也要与类名一致)</li>
<li>b:没有返回值类型，连void都没有</li>
<li>c:没有具体的返回值return;</li>
</ul>
</li>
</ul>
<h3 id="07-02-面向对象-构造方法的重载及注意事项-掌握"><a href="#07-02-面向对象-构造方法的重载及注意事项-掌握" class="headerlink" title="07.02_面向对象(构造方法的重载及注意事项)(掌握)"></a>07.02_面向对象(构造方法的重载及注意事项)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>构造方法的重载</li>
<li>重载:方法名相同,与返回值类型无关(构造方法没有返回值),只看参数列表</li>
</ul>
</li>
<li>B:构造方法注意事项<ul>
<li>a:如果我们没有给出构造方法，系统将自动提供一个无参构造方法。</li>
<li>b:如果我们给出了构造方法，系统将不再提供默认的无参构造方法。<ul>
<li>注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="07-03-面向对象-给成员变量赋值的两种方式的区别"><a href="#07-03-面向对象-给成员变量赋值的两种方式的区别" class="headerlink" title="07.03_面向对象(给成员变量赋值的两种方式的区别)"></a>07.03_面向对象(给成员变量赋值的两种方式的区别)</h3><ul>
<li>A:setXxx()方法<ul>
<li>修改属性值 </li>
</ul>
</li>
<li>B:构造方法<ul>
<li>给对象中属性进行初始化 </li>
</ul>
</li>
</ul>
<h3 id="07-04-面向对象-学生类的代码及测试-掌握"><a href="#07-04-面向对象-学生类的代码及测试-掌握" class="headerlink" title="07.04_面向对象(学生类的代码及测试)(掌握)"></a>07.04_面向对象(学生类的代码及测试)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>学生类：<ul>
<li>成员变量：<ul>
<li>name，age</li>
</ul>
</li>
<li>构造方法：<ul>
<li>无参，带两个参</li>
</ul>
</li>
<li>成员方法：<ul>
<li>getXxx()/setXxx()</li>
<li>show()：输出该类的所有成员变量值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>B:给成员变量赋值：</p>
<ul>
<li>a:setXxx()方法</li>
<li>b:构造方法</li>
</ul>
</li>
<li><p>C:输出成员变量值的方式：</p>
<ul>
<li>a:通过getXxx()分别获取然后拼接</li>
<li>b:通过调用show()方法搞定</li>
</ul>
</li>
</ul>
<h3 id="07-05-面向对象-手机类的代码及测试-掌握"><a href="#07-05-面向对象-手机类的代码及测试-掌握" class="headerlink" title="07.05_面向对象(手机类的代码及测试)(掌握)"></a>07.05_面向对象(手机类的代码及测试)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>模仿学生类，完成手机类代码</li>
</ul>
</li>
</ul>
<h3 id="07-06-面向对象-创建一个对象的步骤-掌握"><a href="#07-06-面向对象-创建一个对象的步骤-掌握" class="headerlink" title="07.06_面向对象(创建一个对象的步骤)(掌握)"></a>07.06_面向对象(创建一个对象的步骤)(掌握)</h3><ul>
<li>A:画图演示<ul>
<li>画图说明一个对象的创建过程做了哪些事情?</li>
<li>Student s = new Student();</li>
<li>1,Student.class加载进内存</li>
<li>2,声明一个Student类型引用s</li>
<li>3,在堆内存创建对象,</li>
<li>4,给对象中属性默认初始化值</li>
<li>5,属性进行显示初始化</li>
<li>6,构造方法进栈,对对象中的属性赋值,构造方法弹栈</li>
<li>7,将对象的地址值赋值给s</li>
</ul>
</li>
</ul>
<h3 id="07-07-面向对象-长方形案例练习-掌握"><a href="#07-07-面向对象-长方形案例练习-掌握" class="headerlink" title="07.07_面向对象(长方形案例练习)(掌握)"></a>07.07_面向对象(长方形案例练习)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>需求：<ul>
<li>定义一个长方形类,定义 求周长和面积的方法，</li>
<li>然后定义一个测试类进行测试。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="07-08-面向对象-员工类案例练习-掌握"><a href="#07-08-面向对象-员工类案例练习-掌握" class="headerlink" title="07.08_面向对象(员工类案例练习)(掌握)"></a>07.08_面向对象(员工类案例练习)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>需求：定义一个员工类Employee</li>
<li>自己分析出几个成员，然后给出成员变量<ul>
<li>姓名name,工号id,工资salary </li>
</ul>
</li>
<li>构造方法，<ul>
<li>空参和有参的</li>
</ul>
</li>
<li>getXxx()setXxx()方法，</li>
<li>以及一个显示所有成员信息的方法。并测试。<ul>
<li>work </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="07-09-面向对象-static关键字及内存图-了解"><a href="#07-09-面向对象-static关键字及内存图-了解" class="headerlink" title="07.09_面向对象(static关键字及内存图)(了解)"></a>07.09_面向对象(static关键字及内存图)(了解)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li>通过一个案例引入static关键字。</li>
<li>人类：Person。每个人都有国籍，中国。</li>
</ul>
</li>
<li><p>B:画图演示</p>
<ul>
<li>带有static的内存图</li>
</ul>
</li>
</ul>
<h3 id="07-10-面向对象-static关键字的特点-掌握"><a href="#07-10-面向对象-static关键字的特点-掌握" class="headerlink" title="07.10_面向对象(static关键字的特点)(掌握)"></a>07.10_面向对象(static关键字的特点)(掌握)</h3><ul>
<li>A:static关键字的特点<ul>
<li>a:随着类的加载而加载</li>
<li>b:优先于对象存在</li>
<li>c:被类的所有对象共享<ul>
<li>举例：咱们班级的学生应该共用同一个班级编号。</li>
<li>其实这个特点也是在告诉我们什么时候使用静态?<ul>
<li>如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。</li>
</ul>
</li>
<li>举例：<ul>
<li>饮水机(用静态修饰)</li>
<li>水杯(不能用静态修饰)</li>
<li>共性用静态,特性用非静态</li>
</ul>
</li>
</ul>
</li>
<li>d:可以通过类名调用<ul>
<li>其实它本身也可以通过对象名调用。</li>
<li>推荐使用类名调用。</li>
<li>静态修饰的内容一般我们称其为：与类相关的，类成员</li>
</ul>
</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>static关键字的特点</li>
</ul>
</li>
</ul>
<h3 id="07-11-面向对象-static的注意事项-掌握"><a href="#07-11-面向对象-static的注意事项-掌握" class="headerlink" title="07.11_面向对象(static的注意事项)(掌握)"></a>07.11_面向对象(static的注意事项)(掌握)</h3><ul>
<li>A:static的注意事项<ul>
<li>a:在静态方法中是没有this关键字的<ul>
<li>如何理解呢?<ul>
<li>静态是随着类的加载而加载，this是随着对象的创建而存在。</li>
<li>静态比对象先存在。</li>
</ul>
</li>
</ul>
</li>
<li>b:静态方法只能访问静态的成员变量和静态的成员方法<ul>
<li>静态方法：<ul>
<li>成员变量：只能访问静态变量</li>
<li>成员方法：只能访问静态成员方法</li>
</ul>
</li>
<li>非静态方法：<ul>
<li>成员变量：可以是静态的，也可以是非静态的</li>
<li>成员方法：可是是静态的成员方法，也可以是非静态的成员方法。</li>
</ul>
</li>
<li>简单记：<ul>
<li>静态只能访问静态。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>static的注意事项</li>
</ul>
</li>
</ul>
<h3 id="07-12-面向对象-静态变量和成员变量的区别-掌握"><a href="#07-12-面向对象-静态变量和成员变量的区别-掌握" class="headerlink" title="07.12_面向对象(静态变量和成员变量的区别)(掌握)"></a>07.12_面向对象(静态变量和成员变量的区别)(掌握)</h3><ul>
<li>静态变量也叫类变量  成员变量也叫对象变量</li>
<li>A:所属不同<ul>
<li>静态变量属于类，所以也称为为类变量</li>
<li>成员变量属于对象，所以也称为实例变量(对象变量)</li>
</ul>
</li>
<li>B:内存中位置不同<ul>
<li>静态变量存储于方法区的静态区</li>
<li>成员变量存储于堆内存</li>
</ul>
</li>
<li>C:内存出现时间不同<ul>
<li>静态变量随着类的加载而加载，随着类的消失而消失</li>
<li>成员变量随着对象的创建而存在，随着对象的消失而消失</li>
</ul>
</li>
<li>D:调用不同<ul>
<li>静态变量可以通过类名调用，也可以通过对象调用</li>
<li>成员变量只能通过对 象名调用</li>
</ul>
</li>
</ul>
<h3 id="07-13-面向对象-main方法的格式详细解释-了解"><a href="#07-13-面向对象-main方法的格式详细解释-了解" class="headerlink" title="07.13_面向对象(main方法的格式详细解释)(了解)"></a>07.13_面向对象(main方法的格式详细解释)(了解)</h3><ul>
<li>A:格式<ul>
<li>public static void main(String[] args) {}</li>
</ul>
</li>
<li>B:针对格式的解释<ul>
<li>public 被jvm调用，访问权限足够大。</li>
<li>static 被jvm调用，不用创建对象，直接类名访问</li>
<li>void被jvm调用，不需要给jvm返回值</li>
<li>main 一个通用的名称，虽然不是关键字，但是被jvm识别</li>
<li>String[] args 以前用于接收键盘录入的</li>
</ul>
</li>
<li>C:演示案例<ul>
<li>通过args接收键盘例如数据</li>
</ul>
</li>
</ul>
<h3 id="07-14-面向对象-工具类中使用静态-了解"><a href="#07-14-面向对象-工具类中使用静态-了解" class="headerlink" title="07.14_面向对象(工具类中使用静态)(了解)"></a>07.14_面向对象(工具类中使用静态)(了解)</h3><ul>
<li>A:制作一个工具类<ul>
<li>ArrayTool</li>
<li>1,获取最大值</li>
<li>2,数组的遍历</li>
<li>3,数组的反转</li>
</ul>
</li>
</ul>
<h3 id="07-15-面向对象-说明书的制作过程-了解"><a href="#07-15-面向对象-说明书的制作过程-了解" class="headerlink" title="07.15_面向对象(说明书的制作过程)(了解)"></a>07.15_面向对象(说明书的制作过程)(了解)</h3><ul>
<li>A:对工具类加入文档注释</li>
<li>B:通过javadoc命令生成说明书<ul>
<li>@author(提取作者内容)</li>
<li>@version(提取版本内容)</li>
<li>javadoc -d 指定的文件目录 -author -version ArrayTool.java</li>
<li>@param 参数名称//形式参数的变量名称@return 函数运行完返回的数据</li>
</ul>
</li>
</ul>
<h3 id="07-16-面向对象-如何使用JDK提供的帮助文档-了解"><a href="#07-16-面向对象-如何使用JDK提供的帮助文档-了解" class="headerlink" title="07.16_面向对象(如何使用JDK提供的帮助文档)(了解)"></a>07.16_面向对象(如何使用JDK提供的帮助文档)(了解)</h3><ul>
<li>A:找到文档，打开文档</li>
<li>B:点击显示，找到索引，出现输入框</li>
<li>C:你应该知道你找谁?举例：Scanner</li>
<li>D:看这个类的结构(需不需要导包)<ul>
<li>成员变量    字段</li>
<li>构造方法    构造方法</li>
<li>成员方法    方法</li>
</ul>
</li>
</ul>
<h3 id="07-17-面向对象-学习Math类的随机数功能-了解"><a href="#07-17-面向对象-学习Math类的随机数功能-了解" class="headerlink" title="07.17_面向对象(学习Math类的随机数功能)(了解)"></a>07.17_面向对象(学习Math类的随机数功能)(了解)</h3><ul>
<li>打开JDK提供的帮助文档学习</li>
<li>A:Math类概述<ul>
<li>类包含用于执行基本数学运算的方法</li>
</ul>
</li>
<li>B:Math类特点<ul>
<li>由于Math类在java.lang包下，所以不需要导包。</li>
<li>因为它的成员全部是静态的,所以私有了构造方法</li>
</ul>
</li>
<li>C:获取随机数的方法<ul>
<li>public static double random():返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。</li>
</ul>
</li>
<li>D:我要获取一个1-100之间的随机数，肿么办?<ul>
<li>int number = (int)(Math.random()*100)+1;</li>
</ul>
</li>
</ul>
<h3 id="07-18-面向对象-猜数字小游戏案例-了解"><a href="#07-18-面向对象-猜数字小游戏案例-了解" class="headerlink" title="07.18_面向对象(猜数字小游戏案例)(了解)"></a>07.18_面向对象(猜数字小游戏案例)(了解)</h3><ul>
<li>A:案例演示<ul>
<li>需求：猜数字小游戏(数据在1-100之间)</li>
</ul>
</li>
</ul>
<h3 id="07-19-day07总结"><a href="#07-19-day07总结" class="headerlink" title="07.19_day07总结"></a>07.19_day07总结</h3><p>把今天的知识点总结一遍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;07-01-面向对象-构造方法Constructor概述和格式-掌握&quot;&gt;&lt;a href=&quot;#07-01-面向对象-构造方法Constructor概述和格式-掌握&quot; class=&quot;headerlink&quot; title=&quot;07.01_面向对象(构造方法Constructor概述和格式)(掌握)&quot;&gt;&lt;/a&gt;07.01_面向对象(构造方法Constructor概述和格式)(掌握)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:构造方法概述和作用&lt;ul&gt;
&lt;li&gt;给对象的数据(属性)进行初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:构造方法格式特点&lt;ul&gt;
&lt;li&gt;a:方法名与类名相同(大小也要与类名一致)&lt;/li&gt;
&lt;li&gt;b:没有返回值类型，连void都没有&lt;/li&gt;
&lt;li&gt;c:没有具体的返回值return;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;07-02-面向对象-构造方法的重载及注意事项-掌握&quot;&gt;&lt;a href=&quot;#07-02-面向对象-构造方法的重载及注意事项-掌握&quot; class=&quot;headerlink&quot; title=&quot;07.02_面向对象(构造方法的重载及注意事项)(掌握)&quot;&gt;&lt;/a&gt;07.02_面向对象(构造方法的重载及注意事项)(掌握)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:案例演示&lt;ul&gt;
&lt;li&gt;构造方法的重载&lt;/li&gt;
&lt;li&gt;重载:方法名相同,与返回值类型无关(构造方法没有返回值),只看参数列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:构造方法注意事项&lt;ul&gt;
&lt;li&gt;a:如果我们没有给出构造方法，系统将自动提供一个无参构造方法。&lt;/li&gt;
&lt;li&gt;b:如果我们给出了构造方法，系统将不再提供默认的无参构造方法。&lt;ul&gt;
&lt;li&gt;注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="构造方法" scheme="http://harmansecurity.cn/tags/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    
      <category term="static" scheme="http://harmansecurity.cn/tags/static/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(六)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%85%AD)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(六)/</id>
    <published>2017-03-19T14:40:21.000Z</published>
    <updated>2017-03-19T15:16:09.170Z</updated>
    
    <content type="html"><![CDATA[<h3 id="06-01-面向对象-面向对象思想概述-了解"><a href="#06-01-面向对象-面向对象思想概述-了解" class="headerlink" title="06.01_面向对象(面向对象思想概述)(了解)"></a>06.01_面向对象(面向对象思想概述)(了解)</h3><ul>
<li>A:面向过程思想概述<ul>
<li>第一步</li>
<li>第二步 </li>
</ul>
</li>
<li>B:面向对象思想概述<ul>
<li>找对象(第一步,第二步) </li>
</ul>
</li>
<li>C:举例<ul>
<li>买煎饼果子</li>
<li>洗衣服 </li>
</ul>
</li>
<li>D:面向对象思想特点<ul>
<li>a:是一种更符合我们思想习惯的思想</li>
<li>b:可以将复杂的事情简单化</li>
<li>c:将我们从执行者变成了指挥者<ul>
<li>角色发生了转换</li>
</ul>
</li>
</ul>
</li>
<li>E:面向对象开发<ul>
<li>就是不断的创建对象，使用对象，指挥对象做事情。</li>
</ul>
</li>
<li>F:面向对象设计<ul>
<li>其实就是在管理和维护对象之间的关系。</li>
</ul>
</li>
<li>G:面向对象特征<ul>
<li>封装(encapsulation)</li>
<li>继承(inheritance)</li>
<li>多态(polymorphism)</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="06-02-面向对象-类与对象概述-掌握"><a href="#06-02-面向对象-类与对象概述-掌握" class="headerlink" title="06.02_面向对象(类与对象概述)(掌握)"></a>06.02_面向对象(类与对象概述)(掌握)</h3><ul>
<li>A:我们学习编程是为了什么<ul>
<li>为了把我们日常生活中实物用学习语言描述出来</li>
</ul>
</li>
<li>B:我们如何描述现实世界事物<ul>
<li>属性    就是该事物的描述信息(事物身上的名词)</li>
<li>行为    就是该事物能够做什么(事物身上的动词)</li>
</ul>
</li>
<li>C:Java中最基本的单位是类,Java中用class描述事物也是如此<ul>
<li>成员变量    就是事物的属性</li>
<li>成员方法    就是事物的行为</li>
</ul>
</li>
<li>D:定义类其实就是定义类的成员(成员变量和成员方法)<ul>
<li>a:成员变量    和以前定义变量是一样的，只不过位置发生了改变。在类中，方法外。</li>
<li>b:成员方法    和以前定义方法是一样的，只不过把static去掉，后面在详细讲解static的作用。</li>
</ul>
</li>
<li>E:类和对象的概念<ul>
<li>a:类：是一组相关的属性和行为的集合</li>
<li>b:对象：是该类事物的具体体现</li>
<li>c:举例：<ul>
<li>类     学生</li>
<li>对象    具体的某个学生就是一个对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="06-03-面向对象-学生类的定义-掌握"><a href="#06-03-面向对象-学生类的定义-掌握" class="headerlink" title="06.03_面向对象(学生类的定义)(掌握)"></a>06.03_面向对象(学生类的定义)(掌握)</h3><ul>
<li>A:学生事物</li>
<li>B:学生类</li>
<li>C:案例演示<ul>
<li>属性:姓名,年龄,性别</li>
<li>行为:学习,睡觉</li>
</ul>
</li>
</ul>
<h3 id="06-04-面向对象-手机类的定义-掌握"><a href="#06-04-面向对象-手机类的定义-掌握" class="headerlink" title="06.04_面向对象(手机类的定义)(掌握)"></a>06.04_面向对象(手机类的定义)(掌握)</h3><ul>
<li>模仿学生类，让学生自己完成<ul>
<li>属性:品牌(brand)价格(price)</li>
<li>行为:打电话(call),发信息(sendMessage)玩游戏(playGame)</li>
</ul>
</li>
</ul>
<h3 id="06-05-面向对象-学生类的使用-掌握"><a href="#06-05-面向对象-学生类的使用-掌握" class="headerlink" title="06.05_面向对象(学生类的使用)(掌握)"></a>06.05_面向对象(学生类的使用)(掌握)</h3><ul>
<li>A:文件名问题<ul>
<li>在一个java文件中写两个类：一个基本的类，一个测试类。</li>
<li>建议：文件名称和测试类名称一致。</li>
</ul>
</li>
<li>B:如何使用对象?<ul>
<li>创建对象并使用</li>
<li>格式：类名 对象名 = new 类名();</li>
</ul>
</li>
<li>D:如何使用成员变量呢?<ul>
<li>对象名.变量名</li>
</ul>
</li>
<li>E:如何使用成员方法呢?<ul>
<li>对象名.方法名(…)</li>
</ul>
</li>
</ul>
<h3 id="06-06-面向对象-手机类的使用-掌握"><a href="#06-06-面向对象-手机类的使用-掌握" class="headerlink" title="06.06_面向对象(手机类的使用)(掌握)"></a>06.06_面向对象(手机类的使用)(掌握)</h3><ul>
<li>A:学生自己完成<ul>
<li>模仿学生类，让学生自己完成</li>
</ul>
</li>
</ul>
<h3 id="06-07-面向对象-一个对象的内存图-掌握"><a href="#06-07-面向对象-一个对象的内存图-掌握" class="headerlink" title="06.07_面向对象(一个对象的内存图)(掌握)"></a>06.07_面向对象(一个对象的内存图)(掌握)</h3><ul>
<li>A:画图演示<ul>
<li>一个对象</li>
</ul>
</li>
</ul>
<h3 id="06-08-面向对象-二个对象的内存图-了解"><a href="#06-08-面向对象-二个对象的内存图-了解" class="headerlink" title="06.08_面向对象(二个对象的内存图)(了解)"></a>06.08_面向对象(二个对象的内存图)(了解)</h3><ul>
<li>A:画图演示<ul>
<li>二个不同的对象</li>
</ul>
</li>
</ul>
<h3 id="06-09-面向对象-三个引用两个对象的内存图-了解"><a href="#06-09-面向对象-三个引用两个对象的内存图-了解" class="headerlink" title="06.09_面向对象(三个引用两个对象的内存图)(了解)"></a>06.09_面向对象(三个引用两个对象的内存图)(了解)</h3><ul>
<li>A:画图演示<ul>
<li>三个引用，有两个对象的引用指向同一个地址</li>
</ul>
</li>
</ul>
<h3 id="06-10-面向对象-成员变量和局部变量的区别-掌握"><a href="#06-10-面向对象-成员变量和局部变量的区别-掌握" class="headerlink" title="06.10_面向对象(成员变量和局部变量的区别)(掌握)"></a>06.10_面向对象(成员变量和局部变量的区别)(掌握)</h3><ul>
<li>A:在类中的位置不同<ul>
<li>成员变量：在类中方法外</li>
<li>局部变量：在方法定义中或者方法声明上</li>
</ul>
</li>
<li>B:在内存中的位置不同<ul>
<li>成员变量：在堆内存(成员变量属于对象,对象进堆内存)</li>
<li>局部变量：在栈内存(局部变量属于方法,方法进栈内存)</li>
</ul>
</li>
<li>C:生命周期不同<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li>
<li>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失</li>
</ul>
</li>
<li><p>D:初始化值不同</p>
<ul>
<li>成员变量：有默认初始化值</li>
<li>局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。</li>
<li>基本数据类型变量包括哪些:byte,short,int,long,float,double,boolean,char</li>
<li>引用数据类型变量包括哪些:数组,类,接口,枚举</li>
</ul>
</li>
</ul>
<h3 id="06-11-面向对象-方法的形式参数是类名的时候如何调用-掌握"><a href="#06-11-面向对象-方法的形式参数是类名的时候如何调用-掌握" class="headerlink" title="06.11_面向对象(方法的形式参数是类名的时候如何调用)(掌握)"></a>06.11_面向对象(方法的形式参数是类名的时候如何调用)(掌握)</h3><ul>
<li>A:方法的参数是类名public void print(Student s){}//print(new Student());<ul>
<li>如果你看到了一个方法的形式参数是一个类类型(引用类型)，这里其实需要的是该类的对象。</li>
</ul>
</li>
</ul>
<h3 id="06-12-面向对象-匿名对象的概述和应用-掌握"><a href="#06-12-面向对象-匿名对象的概述和应用-掌握" class="headerlink" title="06.12_面向对象(匿名对象的概述和应用)(掌握)"></a>06.12_面向对象(匿名对象的概述和应用)(掌握)</h3><ul>
<li>A:什么是匿名对象<ul>
<li>没有名字的对象 </li>
</ul>
</li>
<li>B:匿名对象应用场景<ul>
<li>a:调用方法，仅仅只调用一次的时候。<ul>
<li>那么，这种匿名调用有什么好处吗?<ul>
<li>节省代码 </li>
</ul>
</li>
<li>注意：调用多次的时候，不适合。匿名对象调用完毕就是垃圾。可以被垃圾回收器回收。</li>
</ul>
</li>
<li>b:匿名对象可以作为实际参数传递</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>匿名对象应用场景</li>
</ul>
</li>
</ul>
<h3 id="06-13-面向对象-封装的概述-掌握"><a href="#06-13-面向对象-封装的概述-掌握" class="headerlink" title="06.13_面向对象(封装的概述)(掌握)"></a>06.13_面向对象(封装的概述)(掌握)</h3><ul>
<li><p>A:封装概述</p>
<ul>
<li>是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。</li>
</ul>
</li>
<li><p>B:封装好处</p>
<ul>
<li>隐藏实现细节，提供公共的访问方式</li>
<li>提高了代码的复用性</li>
<li>提高安全性。</li>
</ul>
</li>
<li>C:封装原则<ul>
<li>将不需要对外提供的内容都隐藏起来。</li>
<li>把属性隐藏，提供公共方法对其访问。</li>
</ul>
</li>
</ul>
<h3 id="06-14-面向对象-private关键字的概述和特点-掌握"><a href="#06-14-面向对象-private关键字的概述和特点-掌握" class="headerlink" title="06.14_面向对象(private关键字的概述和特点)(掌握)"></a>06.14_面向对象(private关键字的概述和特点)(掌握)</h3><ul>
<li>A:人类赋值年龄的问题</li>
<li>B:private关键字特点<ul>
<li>a:是一个权限修饰符</li>
<li>b:可以修饰成员变量和成员方法</li>
<li>c:被其修饰的成员只能在本类中被访问</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>封装和private的应用：</li>
<li>A:把成员变量用private修饰</li>
<li>B:提供对应的getXxx()和setXxx()方法</li>
<li>private仅仅是封装的一种体现形式,不能说封装就是私有</li>
</ul>
</li>
</ul>
<h3 id="06-15-面向对象-this关键字的概述和应用-掌握"><a href="#06-15-面向对象-this关键字的概述和应用-掌握" class="headerlink" title="06.15_面向对象(this关键字的概述和应用)(掌握)"></a>06.15_面向对象(this关键字的概述和应用)(掌握)</h3><ul>
<li>A:this关键字特点<ul>
<li>代表当前对象的引用 </li>
</ul>
</li>
<li>B:案例演示<ul>
<li>this的应用场景</li>
<li>用来区分成员变量和局部变量重名</li>
</ul>
</li>
</ul>
<h3 id="06-16-面向对象-手机类代码及其测试-掌握"><a href="#06-16-面向对象-手机类代码及其测试-掌握" class="headerlink" title="06.16_面向对象(手机类代码及其测试)(掌握)"></a>06.16_面向对象(手机类代码及其测试)(掌握)</h3><ul>
<li>A:学生练习<ul>
<li>请把手机类写成一个标准类，然后创建对象测试功能。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo2_Phone</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Phone p1 = <span class="keyword">new</span> Phone();</div><div class="line">		p1.setBrand(<span class="string">"三星"</span>);</div><div class="line">		p1.setPrice(<span class="number">5288</span>);</div><div class="line"></div><div class="line">		System.out.println(p1.getBrand() + <span class="string">"..."</span> + p1.getPrice());</div><div class="line">		p1.call();</div><div class="line">		p1.sendMessage();</div><div class="line">		p1.playGame();</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line">手机类</div><div class="line">	属性:品牌brand,价格price</div><div class="line">	行为:打电话call,发短信sendMessage,玩游戏,playGame</div><div class="line">*/</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;								<span class="comment">//java bean</span></div><div class="line">	<span class="keyword">private</span> String brand;					<span class="comment">//品牌</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> price;						<span class="comment">//价格</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBrand</span><span class="params">(String brand)</span> </span>&#123;	<span class="comment">//设置品牌</span></div><div class="line">		<span class="keyword">this</span>.brand = brand;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123;				<span class="comment">//获取品牌</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.brand;					<span class="comment">//this.可以省略,你不加系统会默认给你加</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;		<span class="comment">//设置价格</span></div><div class="line">		<span class="keyword">this</span>.price = price;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;					<span class="comment">//获取价格</span></div><div class="line">		<span class="keyword">return</span> price;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;					<span class="comment">//打电话</span></div><div class="line">		System.out.println(<span class="string">"打电话"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;				<span class="comment">//发短信</span></div><div class="line">		System.out.println(<span class="string">"发短信"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">()</span> </span>&#123;				<span class="comment">//玩游戏</span></div><div class="line">		System.out.println(<span class="string">"玩游戏"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="06-17-day06总结"><a href="#06-17-day06总结" class="headerlink" title="06.17_day06总结"></a>06.17_day06总结</h3><ul>
<li>把今天的知识点总结一遍。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;06-01-面向对象-面向对象思想概述-了解&quot;&gt;&lt;a href=&quot;#06-01-面向对象-面向对象思想概述-了解&quot; class=&quot;headerlink&quot; title=&quot;06.01_面向对象(面向对象思想概述)(了解)&quot;&gt;&lt;/a&gt;06.01_面向对象(面向对象思想概述)(了解)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:面向过程思想概述&lt;ul&gt;
&lt;li&gt;第一步&lt;/li&gt;
&lt;li&gt;第二步 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:面向对象思想概述&lt;ul&gt;
&lt;li&gt;找对象(第一步,第二步) &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C:举例&lt;ul&gt;
&lt;li&gt;买煎饼果子&lt;/li&gt;
&lt;li&gt;洗衣服 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D:面向对象思想特点&lt;ul&gt;
&lt;li&gt;a:是一种更符合我们思想习惯的思想&lt;/li&gt;
&lt;li&gt;b:可以将复杂的事情简单化&lt;/li&gt;
&lt;li&gt;c:将我们从执行者变成了指挥者&lt;ul&gt;
&lt;li&gt;角色发生了转换&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;E:面向对象开发&lt;ul&gt;
&lt;li&gt;就是不断的创建对象，使用对象，指挥对象做事情。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;F:面向对象设计&lt;ul&gt;
&lt;li&gt;其实就是在管理和维护对象之间的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;G:面向对象特征&lt;ul&gt;
&lt;li&gt;封装(encapsulation)&lt;/li&gt;
&lt;li&gt;继承(inheritance)&lt;/li&gt;
&lt;li&gt;多态(polymorphism)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="面向对象" scheme="http://harmansecurity.cn/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(五)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%94)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(五)/</id>
    <published>2017-03-19T14:39:22.000Z</published>
    <updated>2017-03-19T15:27:14.582Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接：<code>http://bbs.itheima.com/thread-270882-1-1.html</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考链接：&lt;code&gt;http://bbs.itheima.com/thread-270882-1-1.html&lt;/code&gt;&lt;/p&gt;

    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="数组操作" scheme="http://harmansecurity.cn/tags/%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(四)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E5%9B%9B)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(四)/</id>
    <published>2017-03-19T14:38:21.000Z</published>
    <updated>2017-03-19T15:12:13.869Z</updated>
    
    <content type="html"><![CDATA[<h3 id="04-01-Java语言基础-循环结构概述和for语句的格式及其使用"><a href="#04-01-Java语言基础-循环结构概述和for语句的格式及其使用" class="headerlink" title="04.01_Java语言基础(循环结构概述和for语句的格式及其使用)"></a>04.01_Java语言基础(循环结构概述和for语句的格式及其使用)</h3><ul>
<li>A:循环结构的分类<ul>
<li>for,while,do…while </li>
</ul>
</li>
<li>B:循环结构for语句的格式：</li>
<li><pre><code>for(初始化表达式;条件表达式;循环后的操作表达式) {
    循环体;
}
</code></pre></li>
<li>C执行流程：<ul>
<li>a:执行初始化语句</li>
<li>b:执行判断条件语句,看其返回值是true还是false<ul>
<li>如果是true，就继续执行</li>
<li>如果是false，就结束循环</li>
</ul>
</li>
<li>c:执行循环体语句;</li>
<li>d:执行循环后的操作表达式</li>
<li>e:回到B继续。</li>
</ul>
</li>
<li>D:案例演示<ul>
<li>在控制台输出10次”helloworld”</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="04-02-Java语言基础-循环结构for语句的练习之获取数据"><a href="#04-02-Java语言基础-循环结构for语句的练习之获取数据" class="headerlink" title="04.02_Java语言基础(循环结构for语句的练习之获取数据)"></a>04.02_Java语言基础(循环结构for语句的练习之获取数据)</h3><ul>
<li>A:案例演示<ul>
<li>需求：请在控制台输出数据1-10</li>
<li>需求：请在控制台输出数据10-1</li>
</ul>
</li>
<li>B:注意事项<ul>
<li>a:判断条件语句无论简单还是复杂结果是boolean类型。</li>
<li>b:循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。</li>
<li>c:一般来说：有左大括号就没有分号，有分号就没有左大括号</li>
</ul>
</li>
</ul>
<h3 id="04-03-Java语言基础-循环结构for语句的练习之求和思想"><a href="#04-03-Java语言基础-循环结构for语句的练习之求和思想" class="headerlink" title="04.03_Java语言基础(循环结构for语句的练习之求和思想)"></a>04.03_Java语言基础(循环结构for语句的练习之求和思想)</h3><ul>
<li>A:案例演示<ul>
<li>需求：求出1-10之间数据之和</li>
</ul>
</li>
<li>B:学生练习<ul>
<li>需求：求出1-100之间偶数和</li>
<li>需求：求出1-100之间奇数和</li>
</ul>
</li>
</ul>
<h3 id="04-04-Java语言基础-循环结构for语句的练习之水仙花"><a href="#04-04-Java语言基础-循环结构for语句的练习之水仙花" class="headerlink" title="04.04_Java语言基础(循环结构for语句的练习之水仙花)"></a>04.04_Java语言基础(循环结构for语句的练习之水仙花)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li><p>需求：在控制台输出所有的”水仙花数”</p>
</li>
<li><p>所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。</p>
</li>
<li>举例：153就是一个水仙花数。</li>
<li>153 = 1<em>1</em>1 + 5<em>5</em>5 + 3<em>3</em>3 = 1 + 125 + 27 = 153</li>
</ul>
</li>
</ul>
<h3 id="04-05-Java语言基础-循环结构for语句的练习之统计思想"><a href="#04-05-Java语言基础-循环结构for语句的练习之统计思想" class="headerlink" title="04.05_Java语言基础(循环结构for语句的练习之统计思想)"></a>04.05_Java语言基础(循环结构for语句的练习之统计思想)</h3><ul>
<li>A:案例演示<ul>
<li>需求：统计”水仙花数”共有多少个</li>
</ul>
</li>
</ul>
<h3 id="04-06-Java语言基础-循环结构while语句的格式和基本使用"><a href="#04-06-Java语言基础-循环结构while语句的格式和基本使用" class="headerlink" title="04.06_Java语言基础(循环结构while语句的格式和基本使用)"></a>04.06_Java语言基础(循环结构while语句的格式和基本使用)</h3><ul>
<li>A:循环结构while语句的格式：</li>
<li><p>while循环的基本格式：<br>while(判断条件语句) {<br>  循环体语句;<br>}</p>
<p>完整格式：</p>
<p>初始化语句;<br>while(判断条件语句) {<br>   循环体语句;<br>   控制条件语句;<br>}</p>
</li>
<li>B:执行流程：<ul>
<li>a:执行初始化语句</li>
<li>b:执行判断条件语句,看其返回值是true还是false<ul>
<li>如果是true，就继续执行</li>
<li>如果是false，就结束循环</li>
</ul>
</li>
<li>c:执行循环体语句;</li>
<li>d:执行控制条件语句</li>
<li>e:回到B继续。</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>需求：请在控制台输出数据1-10</li>
</ul>
</li>
</ul>
<h3 id="04-07-Java语言基础-循环结构while语句的练习"><a href="#04-07-Java语言基础-循环结构while语句的练习" class="headerlink" title="04.07_Java语言基础(循环结构while语句的练习)"></a>04.07_Java语言基础(循环结构while语句的练习)</h3><ul>
<li>A:求和思想<ul>
<li>求1-100之和</li>
</ul>
</li>
<li>B:统计思想<ul>
<li>统计”水仙花数”共有多少个</li>
</ul>
</li>
</ul>
<h3 id="04-08-Java语言基础-循环结构do…while语句的格式和基本使用"><a href="#04-08-Java语言基础-循环结构do…while语句的格式和基本使用" class="headerlink" title="04.08_Java语言基础(循环结构do…while语句的格式和基本使用)"></a>04.08_Java语言基础(循环结构do…while语句的格式和基本使用)</h3><ul>
<li>A:循环结构do…while语句的格式：</li>
<li><pre><code>do {
    循环体语句;
}while(判断条件语句);

完整格式；
初始化语句;
do {
    循环体语句;
    控制条件语句;
}while(判断条件语句);
</code></pre></li>
<li>B:执行流程：<ul>
<li>a:执行初始化语句</li>
<li>b:执行循环体语句;</li>
<li>c:执行控制条件语句</li>
<li>d:执行判断条件语句,看其返回值是true还是false<ul>
<li>如果是true，就继续执行</li>
<li>如果是false，就结束循环</li>
</ul>
</li>
<li>e:回到b继续。</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>需求：请在控制台输出数据1-10</li>
</ul>
</li>
</ul>
<h3 id="04-09-Java语言基础-循环结构三种循环语句的区别"><a href="#04-09-Java语言基础-循环结构三种循环语句的区别" class="headerlink" title="04.09_Java语言基础(循环结构三种循环语句的区别)"></a>04.09_Java语言基础(循环结构三种循环语句的区别)</h3><ul>
<li>A:案例演示<ul>
<li>三种循环语句的区别:</li>
<li>do…while循环至少执行一次循环体。</li>
<li>而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>for循环和while循环的区别：<ul>
<li>A:如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用谁就用for循环。因为变量及早的从内存中消失，可以提高内存的使用效率。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="04-10-Java语言基础-循环结构注意事项之死循环"><a href="#04-10-Java语言基础-循环结构注意事项之死循环" class="headerlink" title="04.10_Java语言基础(循环结构注意事项之死循环)"></a>04.10_Java语言基础(循环结构注意事项之死循环)</h3><ul>
<li>A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。</li>
<li>B:两种最简单的死循环格式<ul>
<li>while(true){…}</li>
<li>for(;;){…}</li>
</ul>
</li>
</ul>
<h3 id="04-11-Java语言基础-循环结构循环嵌套输出4行5列的星星"><a href="#04-11-Java语言基础-循环结构循环嵌套输出4行5列的星星" class="headerlink" title="04.11_Java语言基础(循环结构循环嵌套输出4行5列的星星)"></a>04.11_Java语言基础(循环结构循环嵌套输出4行5列的星星)</h3><ul>
<li>A:案例演示<ul>
<li>需求：请输出一个4行5列的星星(*)图案。</li>
<li><pre><code>如图：
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*****</div><div class="line">*****</div><div class="line">*****</div><div class="line">*****</div></pre></td></tr></table></figure>
</code></pre></li>
</ul>
</li>
</ul>
<pre><code>注意：
    `System.out.println(&quot;*&quot;);和System.out.print(&quot;*&quot;);`的区别
</code></pre><ul>
<li>B:结论：<ul>
<li>外循环控制行数，内循环控制列数</li>
</ul>
</li>
</ul>
<h3 id="04-12-Java语言基础-循环结构循环嵌套输出正三角形"><a href="#04-12-Java语言基础-循环结构循环嵌套输出正三角形" class="headerlink" title="04.12_Java语言基础(循环结构循环嵌套输出正三角形)"></a>04.12_Java语言基础(循环结构循环嵌套输出正三角形)</h3><ul>
<li>A:案例演示</li>
<li><pre><code>需求：请输出下列的形状
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">*</div><div class="line">**</div><div class="line">***</div><div class="line">****</div><div class="line">*****</div></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<h3 id="04-13-Java语言基础-循环结构九九乘法表"><a href="#04-13-Java语言基础-循环结构九九乘法表" class="headerlink" title="04.13_Java语言基础(循环结构九九乘法表)"></a>04.13_Java语言基础(循环结构九九乘法表)</h3><ul>
<li>A:案例演示<ul>
<li>需求：在控制台输出九九乘法表。</li>
</ul>
</li>
<li>B:代码优化</li>
<li><pre><code>注意：
&apos;\x&apos; x表示任意，\是转义符号,这种做法叫转移字符。

&apos;\t&apos;    tab键的位置
&apos;\r&apos;    回车
&apos;\n&apos;    换行
&apos;\&quot;&apos;
&apos;\&apos;&apos;
</code></pre></li>
</ul>
<h3 id="04-14-Java语言基础-控制跳转语句break语句"><a href="#04-14-Java语言基础-控制跳转语句break语句" class="headerlink" title="04.14_Java语言基础(控制跳转语句break语句)"></a>04.14_Java语言基础(控制跳转语句break语句)</h3><ul>
<li>A:break的使用场景<ul>
<li>只能在switch和循环中 </li>
</ul>
</li>
</ul>
<h3 id="04-15-Java语言基础-控制跳转语句continue语句"><a href="#04-15-Java语言基础-控制跳转语句continue语句" class="headerlink" title="04.15_Java语言基础(控制跳转语句continue语句)"></a>04.15_Java语言基础(控制跳转语句continue语句)</h3><ul>
<li>A:continue的使用场景<ul>
<li>只能在循环中 </li>
</ul>
</li>
</ul>
<h3 id="04-16-Java语言基础-控制跳转语句标号"><a href="#04-16-Java语言基础-控制跳转语句标号" class="headerlink" title="04.16_Java语言基础(控制跳转语句标号)"></a>04.16_Java语言基础(控制跳转语句标号)</h3><ul>
<li>标号:标记某个循环对其控制</li>
<li>标号组成规则:其实就是合法的标识符</li>
</ul>
<h3 id="04-17-Java语言基础-控制调整语句练习"><a href="#04-17-Java语言基础-控制调整语句练习" class="headerlink" title="04.17_Java语言基础(控制调整语句练习)"></a>04.17_Java语言基础(控制调整语句练习)</h3><ul>
<li>A:练习题</li>
<li><pre><code>for(int x=1; x&lt;=10; x++) {
    if(x%3==0) {
        //在此处填写代码
    }
    System.out.println(“Java基础班”);
}

我想在控制台输出2次:“Java基础班“
我想在控制台输出7次:“Java基础班“
我想在控制台输出13次:“Java基础班“    
</code></pre></li>
</ul>
<h3 id="04-18-Java语言基础-控制跳转语句return语句"><a href="#04-18-Java语言基础-控制跳转语句return语句" class="headerlink" title="04.18_Java语言基础(控制跳转语句return语句)"></a>04.18_Java语言基础(控制跳转语句return语句)</h3><ul>
<li>A:return的作用<ul>
<li>返回</li>
<li>其实它的作用不是结束循环的，而是结束方法的。</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>return和break以及continue的区别?</li>
<li>return是结束方法</li>
<li>break是跳出循环</li>
<li>continue是终止本次循环继续下次循环</li>
</ul>
</li>
</ul>
<h3 id="04-19-Java语言基础-方法概述和格式说明"><a href="#04-19-Java语言基础-方法概述和格式说明" class="headerlink" title="04.19_Java语言基础(方法概述和格式说明)"></a>04.19_Java语言基础(方法概述和格式说明)</h3><ul>
<li>A:为什么要有方法<ul>
<li>提高代码的复用性 </li>
</ul>
</li>
<li>B:什么是方法<ul>
<li>完成特定功能的代码块。 </li>
</ul>
</li>
<li>C:方法的格式</li>
<li><pre><code>修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) {
    方法体语句;
    return 返回值; 
} 
</code></pre></li>
<li>D:方法的格式说明<ul>
<li>修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。</li>
<li>返回值类型：就是功能结果的数据类型。</li>
<li>方法名：符合命名规则即可。方便我们的调用。</li>
<li>参数：<ul>
<li>实际参数：就是实际参与运算的。</li>
<li>形式参数；就是方法定义上的，用于接收实际参数的。</li>
</ul>
</li>
<li>参数类型：就是参数的数据类型</li>
<li>参数名：就是变量名</li>
<li>方法体语句：就是完成功能的代码。</li>
<li>return：结束方法的。</li>
<li>返回值：就是功能的结果，由return带给调用者。 </li>
</ul>
</li>
</ul>
<h3 id="04-20-Java语言基础-方法之求和案例及其调用"><a href="#04-20-Java语言基础-方法之求和案例及其调用" class="headerlink" title="04.20_Java语言基础(方法之求和案例及其调用)"></a>04.20_Java语言基础(方法之求和案例及其调用)</h3><ul>
<li>A:如何写一个方法<ul>
<li>1,明确返回值类型</li>
<li>2,明确参数列表 </li>
</ul>
</li>
<li>B:案例演示<ul>
<li>需求：求两个数据之和的案例</li>
</ul>
</li>
<li>C:方法调用图解</li>
</ul>
<h3 id="04-21-Java语言基础-方法的注意事项"><a href="#04-21-Java语言基础-方法的注意事项" class="headerlink" title="04.21_Java语言基础(方法的注意事项)"></a>04.21_Java语言基础(方法的注意事项)</h3><ul>
<li>A:方法调用(有具体返回值)<ul>
<li>a:单独调用,一般来说没有意义，所以不推荐。</li>
<li>b:输出调用,但是不够好。因为我们可能需要针对结果进行进一步的操作。</li>
<li>c:赋值调用,推荐方案。</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>a:方法不调用不执行</li>
<li>b:方法与方法是平级关系，不能嵌套定义</li>
<li>c:方法定义的时候参数之间用逗号隔开</li>
<li>d:方法调用的时候不用在传递数据类型</li>
<li>e:如果方法有明确的返回值，一定要有return带回一个值</li>
</ul>
</li>
</ul>
<h3 id="04-22-Java语言基础-方法的练习"><a href="#04-22-Java语言基础-方法的练习" class="headerlink" title="04.22_Java语言基础(方法的练习)"></a>04.22_Java语言基础(方法的练习)</h3><ul>
<li>A:案例演示<ul>
<li>需求：键盘录入两个数据，返回两个数中的较大值</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>需求：键盘录入两个数据，比较两个数是否相等     </li>
</ul>
</li>
</ul>
<h3 id="04-23-Java语言基础-方法之输出星形及其调用"><a href="#04-23-Java语言基础-方法之输出星形及其调用" class="headerlink" title="04.23_Java语言基础(方法之输出星形及其调用)"></a>04.23_Java语言基础(方法之输出星形及其调用)</h3><ul>
<li>A:案例演示<ul>
<li>需求：根据键盘录入的行数和列数，在控制台输出星形</li>
</ul>
</li>
<li>B:方法调用：(无返回值,void)<ul>
<li>单独调用</li>
<li>输出调用(错误)</li>
<li>赋值调用(错误)</li>
</ul>
</li>
</ul>
<h3 id="04-24-Java语言基础-方法的练习"><a href="#04-24-Java语言基础-方法的练习" class="headerlink" title="04.24_Java语言基础(方法的练习)"></a>04.24_Java语言基础(方法的练习)</h3><ul>
<li>A:案例演示<ul>
<li>需求：根据键盘录入的数据输出对应的乘法表</li>
</ul>
</li>
</ul>
<h3 id="04-25-Java语言基础-方法重载概述和基本使用"><a href="#04-25-Java语言基础-方法重载概述和基本使用" class="headerlink" title="04.25_Java语言基础(方法重载概述和基本使用)"></a>04.25_Java语言基础(方法重载概述和基本使用)</h3><ul>
<li>A:方法重载概述<ul>
<li>求和案例<ul>
<li>2个整数</li>
<li>3个整数</li>
<li>4个整数</li>
</ul>
</li>
</ul>
</li>
<li><p>B:方法重载：</p>
<ul>
<li><p>在同一个类中，方法名相同，参数列表不同。与返回值类型无关。</p>
</li>
<li><p>参数列表不同：</p>
<ul>
<li>A:参数个数不同</li>
<li>B:参数类型不同</li>
<li>C:参数的顺序不同(算重载,但是在开发中不用)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="04-26-Java语言基础-方法重载练习比较数据是否相等"><a href="#04-26-Java语言基础-方法重载练习比较数据是否相等" class="headerlink" title="04.26_Java语言基础(方法重载练习比较数据是否相等)"></a>04.26_Java语言基础(方法重载练习比较数据是否相等)</h3><ul>
<li>A:案例演示<ul>
<li>需求：比较两个数据是否相等。</li>
<li>参数类型分别为两个int类型，两个double类型，并在main方法中进行测试</li>
</ul>
</li>
</ul>
<h3 id="04-27-day04总结"><a href="#04-27-day04总结" class="headerlink" title="04.27_day04总结"></a>04.27_day04总结</h3><p>把今天的知识点总结一遍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;04-01-Java语言基础-循环结构概述和for语句的格式及其使用&quot;&gt;&lt;a href=&quot;#04-01-Java语言基础-循环结构概述和for语句的格式及其使用&quot; class=&quot;headerlink&quot; title=&quot;04.01_Java语言基础(循环结构概述和for语句的格式及其使用)&quot;&gt;&lt;/a&gt;04.01_Java语言基础(循环结构概述和for语句的格式及其使用)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:循环结构的分类&lt;ul&gt;
&lt;li&gt;for,while,do…while &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:循环结构for语句的格式：&lt;/li&gt;
&lt;li&gt;&lt;pre&gt;&lt;code&gt;for(初始化表达式;条件表达式;循环后的操作表达式) {
    循环体;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;C执行流程：&lt;ul&gt;
&lt;li&gt;a:执行初始化语句&lt;/li&gt;
&lt;li&gt;b:执行判断条件语句,看其返回值是true还是false&lt;ul&gt;
&lt;li&gt;如果是true，就继续执行&lt;/li&gt;
&lt;li&gt;如果是false，就结束循环&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;c:执行循环体语句;&lt;/li&gt;
&lt;li&gt;d:执行循环后的操作表达式&lt;/li&gt;
&lt;li&gt;e:回到B继续。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;D:案例演示&lt;ul&gt;
&lt;li&gt;在控制台输出10次”helloworld”&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="循环结构" scheme="http://harmansecurity.cn/tags/%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(三)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%89)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(三)/</id>
    <published>2017-03-19T14:36:21.000Z</published>
    <updated>2017-03-19T15:09:43.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="03-01-Java语言基础-逻辑运算符的基本用法-掌握"><a href="#03-01-Java语言基础-逻辑运算符的基本用法-掌握" class="headerlink" title="03.01_Java语言基础(逻辑运算符的基本用法)(掌握)"></a>03.01_Java语言基础(逻辑运算符的基本用法)(掌握)</h3><ul>
<li>A:逻辑运算符有哪些<ul>
<li>&amp;,|,^,!</li>
<li>&amp;&amp;,|| </li>
</ul>
</li>
<li>B:案例演示</li>
<li><p>逻辑运算符的基本用法</p>
</li>
<li><p>注意事项：</p>
<ul>
<li>a:逻辑运算符一般用于连接boolean类型的表达式或者值。</li>
<li>b:表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。<ul>
<li>算术表达式：a + b</li>
<li>比较表达式：a == b(条件表达式)</li>
</ul>
</li>
</ul>
</li>
<li>C:结论：</li>
<li>&amp;逻辑与:有false则false。</li>
<li>|逻辑或:有true则true。</li>
<li>^逻辑异或:相同为false，不同为true。</li>
<li>!逻辑非:非false则true，非true则false。<ul>
<li>特点：偶数个不改变本身。</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="03-02-Java语言基础-逻辑运算符-amp-amp-和-amp-的区别-掌握"><a href="#03-02-Java语言基础-逻辑运算符-amp-amp-和-amp-的区别-掌握" class="headerlink" title="03.02_Java语言基础(逻辑运算符&amp;&amp;和&amp;的区别)(掌握)"></a>03.02_Java语言基础(逻辑运算符&amp;&amp;和&amp;的区别)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>&amp;&amp;和&amp;的区别?<ul>
<li>a:最终结果一样。</li>
<li>b:&amp;&amp;具有短路效果。左边是false，右边不执行。</li>
<li>&amp;是无论左边是false还是true,右边都会执行</li>
</ul>
</li>
</ul>
</li>
<li>B:同理||和|的区别?(学生自学)</li>
<li>C:开发中常用谁?<ul>
<li>&amp;&amp;,||,!</li>
</ul>
</li>
</ul>
<h3 id="03-03-Java语言基础-位运算符的基本用法1-了解"><a href="#03-03-Java语言基础-位运算符的基本用法1-了解" class="headerlink" title="03.03_Java语言基础(位运算符的基本用法1)(了解)"></a>03.03_Java语言基础(位运算符的基本用法1)(了解)</h3><ul>
<li>A:位运算符有哪些<ul>
<li>&amp;,|,^,~ ,&gt;&gt;,&gt;&gt;&gt;,&lt;&lt;</li>
</ul>
</li>
<li><p>B:案例演示</p>
<ul>
<li><p>位运算符的基本用法1</p>
</li>
<li><p>&amp;,|,^,~ 的用法</p>
</li>
<li>&amp;:有0则0</li>
<li>|:有1则1</li>
<li>^:相同则0，不同则1</li>
<li>~:按位取反</li>
</ul>
</li>
</ul>
<h3 id="03-04-Java语言基础-位异或运算符的特点及面试题-掌握"><a href="#03-04-Java语言基础-位异或运算符的特点及面试题-掌握" class="headerlink" title="03.04_Java语言基础(位异或运算符的特点及面试题)(掌握)"></a>03.04_Java语言基础(位异或运算符的特点及面试题)(掌握)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li><p>位异或运算符的特点</p>
</li>
<li><p>^的特点：一个数据对另一个数据位异或两次，该数本身不变。</p>
</li>
</ul>
</li>
<li><p>B:面试题：</p>
<ul>
<li>请自己实现两个整数变量的交换</li>
<li>注意：以后讲课的过程中，我没有明确指定数据的类型，默认int类型。</li>
</ul>
</li>
</ul>
<h3 id="03-05-Java语言基础-位运算符的基本用法2及面试题-了解"><a href="#03-05-Java语言基础-位运算符的基本用法2及面试题-了解" class="headerlink" title="03.05_Java语言基础(位运算符的基本用法2及面试题)(了解)"></a>03.05_Java语言基础(位运算符的基本用法2及面试题)(了解)</h3><ul>
<li>A:案例演示 &gt;&gt;,&gt;&gt;&gt;,&lt;&lt;的用法:<ul>
<li>&lt;&lt;:左移    左边最高位丢弃，右边补齐0</li>
<li><blockquote>
<blockquote>
<p>:右移    最高位是0，左边补齐0;最高为是1，左边补齐1</p>
</blockquote>
</blockquote>
</li>
<li><blockquote>
<blockquote>
<blockquote>
<p>:无符号右移 无论最高位是0还是1，左边补齐0</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>最有效率的算出2 * 8的结果</li>
</ul>
</li>
</ul>
<h3 id="03-06-Java语言基础-三元运算符的基本用法-掌握"><a href="#03-06-Java语言基础-三元运算符的基本用法-掌握" class="headerlink" title="03.06_Java语言基础(三元运算符的基本用法)(掌握)"></a>03.06_Java语言基础(三元运算符的基本用法)(掌握)</h3><ul>
<li>A:三元运算符的格式</li>
<li>(关系表达式) ? 表达式1 : 表达式2;</li>
<li>B:三元运算符的执行流程 </li>
<li>C:案例演示<ul>
<li>获取两个数中的最大值</li>
</ul>
</li>
</ul>
<h3 id="03-07-Java语言基础-三元运算符的练习-掌握"><a href="#03-07-Java语言基础-三元运算符的练习-掌握" class="headerlink" title="03.07_Java语言基础(三元运算符的练习)(掌握)"></a>03.07_Java语言基础(三元运算符的练习)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>比较两个整数是否相同</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>获取三个整数中的最大值</li>
</ul>
</li>
</ul>
<h3 id="03-08-Java语言基础-键盘录入的基本格式讲解-掌握"><a href="#03-08-Java语言基础-键盘录入的基本格式讲解-掌握" class="headerlink" title="03.08_Java语言基础(键盘录入的基本格式讲解)(掌握)"></a>03.08_Java语言基础(键盘录入的基本格式讲解)(掌握)</h3><ul>
<li>A:为什么要使用键盘录入数据<ul>
<li>a:为了让程序的数据更符合开发的数据</li>
<li>b:让程序更灵活一下</li>
</ul>
</li>
<li>B:如何实现键盘录入呢?<ul>
<li>先照格式来。</li>
<li>a:导包<ul>
<li>格式：<ul>
<li>import java.util.Scanner; </li>
</ul>
</li>
<li>位置：<ul>
<li>在class上面。</li>
</ul>
</li>
</ul>
</li>
<li>b:创建键盘录入对象<ul>
<li>格式：<ul>
<li>Scanner sc = new Scanner(System.in);</li>
</ul>
</li>
</ul>
</li>
<li>c:通过对象获取数据    <ul>
<li>格式：<ul>
<li>int x = sc.nextInt();</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>键盘录入1个整数，并输出到控制台。</li>
<li>键盘录入2个整数，并输出到控制台。</li>
</ul>
</li>
</ul>
<h3 id="03-09-Java语言基础-键盘录入的练习1-掌握"><a href="#03-09-Java语言基础-键盘录入的练习1-掌握" class="headerlink" title="03.09_Java语言基础(键盘录入的练习1)(掌握)"></a>03.09_Java语言基础(键盘录入的练习1)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>键盘录入练习：键盘录入两个数据，并对这两个数据求和，输出其结果</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值</li>
</ul>
</li>
</ul>
<h3 id="03-10-Java语言基础-键盘录入的练习2-掌握"><a href="#03-10-Java语言基础-键盘录入的练习2-掌握" class="headerlink" title="03.10_Java语言基础(键盘录入的练习2)(掌握)"></a>03.10_Java语言基础(键盘录入的练习2)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>键盘录入练习：键盘录入两个数据，比较这两个数据是否相等</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>键盘录入练习：键盘录入三个数据，获取这三个数据中的最大值</li>
</ul>
</li>
</ul>
<h3 id="03-11-Java语言基础-顺序结构语句-了解"><a href="#03-11-Java语言基础-顺序结构语句-了解" class="headerlink" title="03.11_Java语言基础(顺序结构语句)(了解)"></a>03.11_Java语言基础(顺序结构语句)(了解)</h3><ul>
<li>A:什么是流程控制语句<ul>
<li>流程控制语句：可以控制程序的执行流程。</li>
</ul>
</li>
<li>B:流程控制语句的分类<ul>
<li>顺序结构</li>
<li>选择结构</li>
<li>循环结构</li>
</ul>
</li>
<li>C:执行流程：<ul>
<li>从上往下，依次执行。</li>
</ul>
</li>
<li>D:案例演示<ul>
<li>输出几句话看效果即可</li>
</ul>
</li>
</ul>
<h3 id="03-12-Java语言基础-选择结构if语句格式1及其使用-掌握"><a href="#03-12-Java语言基础-选择结构if语句格式1及其使用-掌握" class="headerlink" title="03.12_Java语言基础(选择结构if语句格式1及其使用)(掌握)"></a>03.12_Java语言基础(选择结构if语句格式1及其使用)(掌握)</h3><ul>
<li>A:选择结构的分类<ul>
<li>if语句</li>
<li>switch语句</li>
</ul>
</li>
<li>B:if语句有几种格式<ul>
<li>格式1</li>
<li>格式2</li>
<li>格式3</li>
</ul>
</li>
<li>C:if语句的格式1</li>
<li><pre><code>if(比较表达式) {
    语句体;
}
</code></pre></li>
<li>D:执行流程：<ul>
<li>先计算比较表达式的值，看其返回值是true还是false。</li>
<li>如果是true，就执行语句体；</li>
<li>如果是false，就不执行语句体；</li>
</ul>
</li>
</ul>
<h3 id="03-13-Java语言基础-选择结构if语句注意事项-掌握"><a href="#03-13-Java语言基础-选择结构if语句注意事项-掌握" class="headerlink" title="03.13_Java语言基础(选择结构if语句注意事项)(掌握)"></a>03.13_Java语言基础(选择结构if语句注意事项)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>a:比较表达式无论简单还是复杂，结果必须是boolean类型</li>
<li>b:if语句控制的语句体如果是一条语句，大括号可以省略；<ul>
<li>如果是多条语句，就不能省略。建议永远不要省略。</li>
</ul>
</li>
<li>c:一般来说：有左大括号就没有分号，有分号就没有左大括号</li>
</ul>
</li>
</ul>
<h3 id="03-14-Java语言基础-选择结构if语句格式2及其使用-掌握"><a href="#03-14-Java语言基础-选择结构if语句格式2及其使用-掌握" class="headerlink" title="03.14_Java语言基础(选择结构if语句格式2及其使用)(掌握)"></a>03.14_Java语言基础(选择结构if语句格式2及其使用)(掌握)</h3><ul>
<li>A:if语句的格式2</li>
<li><pre><code>if(比较表达式) {
    语句体1;
}else {
    语句体2;
}
</code></pre></li>
<li>B:执行流程：<ul>
<li>首先计算比较表达式的值，看其返回值是true还是false。</li>
<li>如果是true，就执行语句体1；</li>
<li>如果是false，就执行语句体2；</li>
</ul>
</li>
<li><p>C:案例演示</p>
<ul>
<li>a:获取两个数据中较大的值</li>
<li><p>b:判断一个数据是奇数还是偶数,并输出是奇数还是偶数</p>
</li>
<li><p>注意事项：else后面是没有比较表达式的，只有if后面有。</p>
</li>
</ul>
</li>
</ul>
<h3 id="03-15-Java语言基础-if语句的格式2和三元的相互转换问题-掌握"><a href="#03-15-Java语言基础-if语句的格式2和三元的相互转换问题-掌握" class="headerlink" title="03.15_Java语言基础(if语句的格式2和三元的相互转换问题)(掌握)"></a>03.15_Java语言基础(if语句的格式2和三元的相互转换问题)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>if语句和三元运算符完成同一个效果</li>
</ul>
</li>
<li><p>B:案例演示</p>
<ul>
<li><p>if语句和三元运算符的区别</p>
</li>
<li><p>三元运算符实现的，都可以采用if语句实现。反之不成立。</p>
</li>
<li><p>什么时候if语句实现不能用三元改进呢?</p>
<ul>
<li>当if语句控制的操作是一个输出语句的时候就不能。</li>
<li>为什么呢?因为三元运算符是一个运算符，运算符操作完毕就应该有一个结果，而不是一个输出。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="03-16-Java语言基础-选择结构if语句格式3及其使用-掌握"><a href="#03-16-Java语言基础-选择结构if语句格式3及其使用-掌握" class="headerlink" title="03.16_Java语言基础(选择结构if语句格式3及其使用)(掌握)"></a>03.16_Java语言基础(选择结构if语句格式3及其使用)(掌握)</h3><ul>
<li>A:if语句的格式3：</li>
<li><pre><code>if(比较表达式1) {
    语句体1;
}else if(比较表达式2) {
    语句体2;
}else if(比较表达式3) {
    语句体3;
}
...
else {
    语句体n+1;
}
</code></pre></li>
<li><p>B:执行流程：</p>
<ul>
<li>首先计算比较表达式1看其返回值是true还是false，</li>
<li>如果是true，就执行语句体1，if语句结束。</li>
<li><p>如果是false，接着计算比较表达式2看其返回值是true还是false，</p>
</li>
<li><p>如果是true，就执行语句体2，if语句结束。</p>
</li>
<li><p>如果是false，接着计算比较表达式3看其返回值是true还是false，</p>
</li>
<li><p>如果都是false，就执行语句体n+1。</p>
</li>
</ul>
</li>
<li>C:注意事项:最后一个else可以省略,但是建议不要省略,可以对范围外的错误值提示 </li>
</ul>
<h3 id="03-17-Java语言基础-选择结构if语句格式3练习-掌握"><a href="#03-17-Java语言基础-选择结构if语句格式3练习-掌握" class="headerlink" title="03.17_Java语言基础(选择结构if语句格式3练习)(掌握)"></a>03.17_Java语言基础(选择结构if语句格式3练习)(掌握)</h3><ul>
<li>A:练习1</li>
<li><pre><code>需求：键盘录入一个成绩，判断并输出成绩的等级。
90-100 优
80-89  良
70-79  中
60-69  及
0-59   差
</code></pre></li>
<li><p>B:练习2</p>
<ul>
<li><p>需求：</p>
<ul>
<li><p>键盘录入x的值，计算出y的并输出。</p>
</li>
<li><p>x&gt;=3    y = 2 * x + 1;</p>
</li>
<li>-1&lt;x&lt;3    y = 2 * x;</li>
<li>x&lt;=-1    y = 2 * x - 1;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="03-18-Java语言基础-选择结构if语句的嵌套使用-掌握"><a href="#03-18-Java语言基础-选择结构if语句的嵌套使用-掌握" class="headerlink" title="03.18_Java语言基础(选择结构if语句的嵌套使用)(掌握)"></a>03.18_Java语言基础(选择结构if语句的嵌套使用)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>需求：获取三个数据中的最大值</li>
<li>if语句的嵌套使用。</li>
</ul>
</li>
</ul>
<h3 id="03-19-Java语言基础-选择结构switch语句的格式及其解释-掌握"><a href="#03-19-Java语言基础-选择结构switch语句的格式及其解释-掌握" class="headerlink" title="03.19_Java语言基础(选择结构switch语句的格式及其解释)(掌握)"></a>03.19_Java语言基础(选择结构switch语句的格式及其解释)(掌握)</h3><ul>
<li>A:switch语句的格式</li>
<li><pre><code>switch(表达式) {
      case 值1：
        语句体1;
        break;
        case 值2：
        语句体2;
        break;
        …
        default：    
        语句体n+1;
        break;
}
</code></pre></li>
<li><p>B:switch语句的格式解释</p>
</li>
<li>C:面试题<ul>
<li>byte可以作为switch的表达式吗?</li>
<li>long可以作为switch的表达式吗?</li>
<li>String可以作为switch的表达式吗?</li>
</ul>
</li>
<li>C:执行流程<ul>
<li>先计算表达式的值</li>
<li>然后和case后面的匹配，如果有就执行对应的语句，否则执行default控制的语句</li>
</ul>
</li>
</ul>
<h3 id="03-20-Java语言基础-选择结构switch语句的练习-掌握"><a href="#03-20-Java语言基础-选择结构switch语句的练习-掌握" class="headerlink" title="03.20_Java语言基础(选择结构switch语句的练习)(掌握)"></a>03.20_Java语言基础(选择结构switch语句的练习)(掌握)</h3><ul>
<li>A:整数(给定一个值,输出对应星期几)</li>
</ul>
<h3 id="03-21-Java语言基础-选择结构switch语句的注意事项-掌握"><a href="#03-21-Java语言基础-选择结构switch语句的注意事项-掌握" class="headerlink" title="03.21_Java语言基础(选择结构switch语句的注意事项)(掌握)"></a>03.21_Java语言基础(选择结构switch语句的注意事项)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>a:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的</li>
<li>b:default可以省略吗?<ul>
<li>可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。</li>
<li>特殊情况：<ul>
<li>case就可以把值固定。</li>
<li>A,B,C,D</li>
</ul>
</li>
</ul>
</li>
<li>c:break可以省略吗?<ul>
<li>最后一个可以省略,其他最好不要省略</li>
<li>会出现一个现象：case穿透。</li>
<li>最终我们建议不要省略</li>
</ul>
</li>
<li>d:default一定要在最后吗?<ul>
<li>不是，可以在任意位置。但是建议在最后。</li>
</ul>
</li>
<li>e:switch语句的结束条件<ul>
<li>a:遇到break就结束了</li>
<li>b:执行到switch的右大括号就结束了</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="03-22-Java语言基础-选择结构switch语句练习-掌握"><a href="#03-22-Java语言基础-选择结构switch语句练习-掌握" class="headerlink" title="03.22_Java语言基础(选择结构switch语句练习)(掌握)"></a>03.22_Java语言基础(选择结构switch语句练习)(掌握)</h3><ul>
<li>A:看程序写结果：</li>
<li><pre><code>int x = 2;
int y = 3;
switch(x){
    default:
        y++;
        break;
    case 3:
        y++;
    case 4:
        y++;
}
System.out.println(&quot;y=&quot;+y);
</code></pre></li>
<li><p>B:看程序写结果：</p>
</li>
<li><pre><code>int x = 2;
int y = 3;
switch(x){
    default:
        y++;
    case 3:
        y++;
    case 4:
        y++;
}
System.out.println(&quot;y=&quot;+y);
</code></pre></li>
</ul>
<h3 id="03-23-Java语言基础-选择结构if语句和switch语句的区别-掌握"><a href="#03-23-Java语言基础-选择结构if语句和switch语句的区别-掌握" class="headerlink" title="03.23_Java语言基础(选择结构if语句和switch语句的区别)(掌握)"></a>03.23_Java语言基础(选择结构if语句和switch语句的区别)(掌握)</h3><ul>
<li>A:总结switch语句和if语句的各自使用场景</li>
<li>switch建议判断固定值的时候用</li>
<li>if建议判断区间或范围的时候用</li>
<li>B:案例演示<ul>
<li>分别用switch语句和if语句实现下列需求：<ul>
<li>键盘录入月份，输出对应的季节</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="03-24-day03总结"><a href="#03-24-day03总结" class="headerlink" title="03.24_day03总结"></a>03.24_day03总结</h3><p>把今天的知识点总结一遍。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;03-01-Java语言基础-逻辑运算符的基本用法-掌握&quot;&gt;&lt;a href=&quot;#03-01-Java语言基础-逻辑运算符的基本用法-掌握&quot; class=&quot;headerlink&quot; title=&quot;03.01_Java语言基础(逻辑运算符的基本用法)(掌握)&quot;&gt;&lt;/a&gt;03.01_Java语言基础(逻辑运算符的基本用法)(掌握)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:逻辑运算符有哪些&lt;ul&gt;
&lt;li&gt;&amp;amp;,|,^,!&lt;/li&gt;
&lt;li&gt;&amp;amp;&amp;amp;,|| &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:案例演示&lt;/li&gt;
&lt;li&gt;&lt;p&gt;逻辑运算符的基本用法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注意事项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a:逻辑运算符一般用于连接boolean类型的表达式或者值。&lt;/li&gt;
&lt;li&gt;b:表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。&lt;ul&gt;
&lt;li&gt;算术表达式：a + b&lt;/li&gt;
&lt;li&gt;比较表达式：a == b(条件表达式)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C:结论：&lt;/li&gt;
&lt;li&gt;&amp;amp;逻辑与:有false则false。&lt;/li&gt;
&lt;li&gt;|逻辑或:有true则true。&lt;/li&gt;
&lt;li&gt;^逻辑异或:相同为false，不同为true。&lt;/li&gt;
&lt;li&gt;!逻辑非:非false则true，非true则false。&lt;ul&gt;
&lt;li&gt;特点：偶数个不改变本身。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="流程控制语句" scheme="http://harmansecurity.cn/tags/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    
      <category term="逻辑运算符" scheme="http://harmansecurity.cn/tags/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(二)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%BA%8C)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(二)/</id>
    <published>2017-03-19T14:35:21.000Z</published>
    <updated>2017-03-19T15:08:49.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="02-01-Java语言基础-常量的概述和使用-掌握"><a href="#02-01-Java语言基础-常量的概述和使用-掌握" class="headerlink" title="02.01_Java语言基础(常量的概述和使用)(掌握)"></a>02.01_Java语言基础(常量的概述和使用)(掌握)</h3><ul>
<li>A:什么是常量<ul>
<li>在程序执行的过程中其值不可以发生改变 </li>
</ul>
</li>
<li>B:Java中常量的分类<ul>
<li>字面值常量</li>
<li>自定义常量(面向对象部分讲) </li>
</ul>
</li>
<li><p>C:字面值常量的分类</p>
<ul>
<li>字符串常量    用双引号括起来的内容</li>
<li>整数常量        所有整数</li>
<li>小数常量        所有小数</li>
<li>字符常量        用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号</li>
<li>布尔常量        较为特殊，只有true和false</li>
<li>空常量            null(数组部分讲解)</li>
</ul>
</li>
<li><p>D:案例演示</p>
<ul>
<li>用输出语句输出各种常量。null不演示</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h3 id="02-02-Java语言基础-进制概述和二-八-十六进制图解-了解"><a href="#02-02-Java语言基础-进制概述和二-八-十六进制图解-了解" class="headerlink" title="02.02_Java语言基础(进制概述和二,八,十六进制图解)(了解)"></a>02.02_Java语言基础(进制概述和二,八,十六进制图解)(了解)</h3><ul>
<li>A:什么是进制<ul>
<li>进制：就是进位制，是人们规定的一种进位方法。 对于任何一种进制–X进制，就表示某一位置上的数运算时是逢X进一位。二进制就是逢二进一，八进制是逢八进一，十进制是逢十进一，十六进制是逢十六进一。</li>
<li>例如一周有七天,七进制,一年有十二个月,十二进制</li>
</ul>
</li>
<li>B:十进制的由来 <ul>
<li>十进制的由来是因为人类有十个手指 </li>
</ul>
</li>
<li>C:二进制的由来<ul>
<li>其实二进制来源与中国,请看史料记载</li>
<li>18世纪德国数理哲学大师莱布尼兹从他的传教士朋友鲍威特寄给他的拉丁文译本《易经》中，读到了八卦的组成结构，惊奇地发现其基本素数（0）（1），即《易经》的阴爻yao- -和__阳爻，其进位制就是二进制，并认为这是世界上数学进制中最先进的。20世纪被称作第三次科技革命的重要标志之一的计算机的发明与应用，其运算模式正是二进制。它不但证明了莱布尼兹的原理是正确的，同时也证明了《易经》数理学是很了不起的。</li>
</ul>
</li>
<li>D:八进制的由来<ul>
<li>任何数据在计算机中都是以二进制的形式存在的。二进制早期由电信号开关演变而来。一个整数在内存中一样也是二进制的，但是使用一大串的1或者0组成的数值进行使用很麻烦。 </li>
<li>所以就想把一大串缩短点，将二进制中的三位用一位表示。这三位可以取到的最大值就是7.超过7就进位了，这就是八进制。 </li>
</ul>
</li>
<li>E:十六进制的由来<ul>
<li>但是对于过长的二进制变成八进制还是较长，所以出现的用4个二进制位表示一位的情况，四个二进制位最大是15，这就是十六进制。</li>
</ul>
</li>
<li>F:不同进制表现同一个数据的形式特点<ul>
<li>进制越大，表现形式越短</li>
</ul>
</li>
</ul>
<h3 id="02-03-Java语言基础-不同进制数据的表现形式-掌握"><a href="#02-03-Java语言基础-不同进制数据的表现形式-掌握" class="headerlink" title="02.03_Java语言基础(不同进制数据的表现形式)(掌握)"></a>02.03_Java语言基础(不同进制数据的表现形式)(掌握)</h3><ul>
<li>A:二进制的数据表现形式<ul>
<li>由0,1组成。以0b(b可以大写也可以小写)开头(JDK1.7版本可以表示二进制了)</li>
</ul>
</li>
<li>B:八进制的数据表现形式<ul>
<li>由0,1,…7组成。以0开头</li>
</ul>
</li>
<li>C:十进制的数据表现形式<ul>
<li>由0,1,…9组成。整数默认是十进制的 </li>
</ul>
</li>
<li>D:十六进制的数据表现形式<ul>
<li>由0,1,…9,a,b,c,d,e,f(大小写均可)。以0x开头 </li>
</ul>
</li>
<li>E:案例演示<ul>
<li>输出不同进制表现100的数据。</li>
<li>0b100</li>
<li>0100</li>
<li>100</li>
<li>0x100</li>
</ul>
</li>
</ul>
<h3 id="02-04-Java语言基础-任意进制到十进制的转换图解-了解"><a href="#02-04-Java语言基础-任意进制到十进制的转换图解-了解" class="headerlink" title="02.04_Java语言基础(任意进制到十进制的转换图解)(了解)"></a>02.04_Java语言基础(任意进制到十进制的转换图解)(了解)</h3><ul>
<li>A:任意进制到十进制的转换原理<ul>
<li>系数：就是每一位上的数据。</li>
<li>基数：X进制，基数就是X。</li>
<li>权：在右边，从0开始编号，对应位上的编号即为该位的权。</li>
<li>结果：把系数*基数的权次幂相加即可。 </li>
</ul>
</li>
<li>B:画图练习<ul>
<li>二进制–十进制</li>
<li>八进制–十进制</li>
<li>十六进制–十进制</li>
</ul>
</li>
</ul>
<h3 id="02-05-Java语言基础-十进制到任意进制的转换图解-了解"><a href="#02-05-Java语言基础-十进制到任意进制的转换图解-了解" class="headerlink" title="02.05_Java语言基础(十进制到任意进制的转换图解)(了解)"></a>02.05_Java语言基础(十进制到任意进制的转换图解)(了解)</h3><ul>
<li>A:十进制到任意进制的转换原理<ul>
<li>除积倒取余 </li>
</ul>
</li>
<li>B:画图练习<ul>
<li>十进制–二进制</li>
<li>十进制–八进制</li>
<li>十进制–十六进制</li>
</ul>
</li>
</ul>
<h3 id="02-06-Java语言基础-快速的进制转换法-了解"><a href="#02-06-Java语言基础-快速的进制转换法-了解" class="headerlink" title="02.06_Java语言基础(快速的进制转换法)(了解)"></a>02.06_Java语言基础(快速的进制转换法)(了解)</h3><ul>
<li>A:8421码及特点<ul>
<li>8421码是中国大陆的叫法，8421码是BCD代码中最常用的一种。在这种编码方式中每一位二值代码的1都是代表一个固定数值，把每一位的1代表的十进制数加起来，得到的结果就是它所代表的十进制数码。 </li>
</ul>
</li>
<li>B:通过8421码的方式进行二进制和十进制的相互转换</li>
<li>C:二进制到八进制的简易方式</li>
<li>D:二进制到十六进制的简易方式</li>
</ul>
<h3 id="02-07-Java语言基础-原码反码补码-了解"><a href="#02-07-Java语言基础-原码反码补码-了解" class="headerlink" title="02.07_Java语言基础(原码反码补码)(了解)"></a>02.07_Java语言基础(原码反码补码)(了解)</h3><ul>
<li>A:为什么要学习原码反码补码?<ul>
<li>后面要学习强制类型转换,如果不知道有原反补会看不懂结果 </li>
</ul>
</li>
<li>B:有符号数据表示法的几种方式<ul>
<li>原码<ul>
<li>就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。</li>
<li>通过一个字节,也就是8个二进制位表示+7和-7</li>
<li>0(符号位)    0000111</li>
<li>1(符号位)    0000111</li>
</ul>
</li>
<li>反码<ul>
<li>正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。</li>
</ul>
</li>
<li>补码<ul>
<li>正数的补码与其原码相同；负数的补码是在其反码的末位加1。 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-08-Java语言基础-原码反码补码的练习-了解"><a href="#02-08-Java语言基础-原码反码补码的练习-了解" class="headerlink" title="02.08_Java语言基础(原码反码补码的练习)(了解)"></a>02.08_Java语言基础(原码反码补码的练习)(了解)</h3><ul>
<li>A:已知原码求补码<ul>
<li>0b10110100 </li>
</ul>
</li>
<li>B:已知补码求原码<ul>
<li>0b11101110 </li>
</ul>
</li>
</ul>
<h3 id="02-09-Java语言基础-变量的概述及格式-掌握"><a href="#02-09-Java语言基础-变量的概述及格式-掌握" class="headerlink" title="02.09_Java语言基础(变量的概述及格式)(掌握)"></a>02.09_Java语言基础(变量的概述及格式)(掌握)</h3><ul>
<li>A:什么是变量<ul>
<li>在程序执行的过程中，在某个范围内其值可以发生改变的量</li>
</ul>
</li>
<li>B:变量的定义格式<ul>
<li>数据类型 变量名 = 变量值;</li>
</ul>
</li>
<li>C:为什么要定义变量<ul>
<li>用来不断的存放同一类型的常量，并可以重复使用 </li>
</ul>
</li>
</ul>
<h3 id="02-10-Java语言基础-数据类型的概述和分类-掌握"><a href="#02-10-Java语言基础-数据类型的概述和分类-掌握" class="headerlink" title="02.10_Java语言基础(数据类型的概述和分类)(掌握)"></a>02.10_Java语言基础(数据类型的概述和分类)(掌握)</h3><ul>
<li>A:为什么有数据类型<ul>
<li>Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间</li>
</ul>
</li>
<li>B:Java中数据类型的分类<ul>
<li>基本数据类型</li>
<li>引用数据类型 <ul>
<li>面向对象部分讲解 </li>
</ul>
</li>
</ul>
</li>
<li>C:基本数据类型分类(4类8种) <ul>
<li>整数型<ul>
<li>byte 占一个字节  -128到127</li>
<li>short 占两个字  -2^15~2^15-1</li>
<li>int 占四个字节 -2^31~2^31-1</li>
<li>long 占八个字节 -2^63~2^63-1</li>
</ul>
</li>
<li>浮点型<ul>
<li>float 占四个字节 -3.403E38~3.403E38  单精度</li>
<li>double 占八个字节-1.798E308~1.798E308 双精度</li>
</ul>
</li>
<li>字符型<ul>
<li>char 占两个字节 0~65535</li>
</ul>
</li>
<li>布尔型<ul>
<li>boolean   <ul>
<li>boolean理论上是占八分之一个字节,因为一个开关就可以决定是true和false了,但是java中boolean类型没有明确指定他的大小      </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-11-Java语言基础-定义不同数据类型的变量-掌握"><a href="#02-11-Java语言基础-定义不同数据类型的变量-掌握" class="headerlink" title="02.11_Java语言基础(定义不同数据类型的变量)(掌握)"></a>02.11_Java语言基础(定义不同数据类型的变量)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>定义不同基本数据类型的变量，并输出</li>
<li>赋值时候注意float类型,long类型</li>
</ul>
</li>
</ul>
<h3 id="02-12-Java语言基础-使用变量的注意事项-掌握"><a href="#02-12-Java语言基础-使用变量的注意事项-掌握" class="headerlink" title="02.12_Java语言基础(使用变量的注意事项)(掌握)"></a>02.12_Java语言基础(使用变量的注意事项)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>a:作用域问题<ul>
<li>同一个区域不能使用相同的变量名 </li>
</ul>
</li>
<li>b:初始化值问题<ul>
<li>局部变量在使用之前必须赋值 </li>
</ul>
</li>
<li>c:一条语句可以定义几个变量<ul>
<li>int a,b,c…; </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-13-Java语言基础-数据类型转换之隐式转换-掌握"><a href="#02-13-Java语言基础-数据类型转换之隐式转换-掌握" class="headerlink" title="02.13_Java语言基础(数据类型转换之隐式转换)(掌握)"></a>02.13_Java语言基础(数据类型转换之隐式转换)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>a:int + int</li>
<li>b:byte + int </li>
</ul>
</li>
<li>B:Java中的默认转换规则<ul>
<li>取值范围小的数据类型与取值范围大的数据类型进行运算,会先将小的数据类型提升为大的,再运算 </li>
</ul>
</li>
<li>C:画图解释byte+int类型的问题</li>
</ul>
<h3 id="02-14-Java语言基础-数据类型转换之强制转换-掌握"><a href="#02-14-Java语言基础-数据类型转换之强制转换-掌握" class="headerlink" title="02.14_Java语言基础(数据类型转换之强制转换)(掌握)"></a>02.14_Java语言基础(数据类型转换之强制转换)(掌握)</h3><ul>
<li>A:强制转换问题<ul>
<li>int a = 10;</li>
<li>byte b = 20; </li>
<li>b = a + b;</li>
</ul>
</li>
<li>B:强制转换的格式<ul>
<li>b = (byte)(a + b); </li>
</ul>
</li>
<li>C:强制转换的注意事项<ul>
<li>如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同 </li>
</ul>
</li>
</ul>
<h3 id="02-15-Java语言基础-面试题之变量相加和常量相加的区别-掌握"><a href="#02-15-Java语言基础-面试题之变量相加和常量相加的区别-掌握" class="headerlink" title="02.15_Java语言基础(面试题之变量相加和常量相加的区别)(掌握)"></a>02.15_Java语言基础(面试题之变量相加和常量相加的区别)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。</li>
<li>byte b1 = 3;</li>
<li>byte b2 = 4;</li>
<li>byte b3 = b1 + b2;<ul>
<li>从两方面去回答这个题</li>
<li>b1和b2是两个变量,变量里面存储的值都是变化的,所以在程序运行中JVM是无法判断里面具体的值</li>
<li>byte类型的变量在进行运算的时候,会自动类型提升为int类型 </li>
</ul>
</li>
<li>byte b4 = 3 + 4;<ul>
<li>3和4都是常量,java有常量优化机制,就是在编译的的时候直接把3和4的结果赋值给b4了 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-16-Java语言基础-long与float的取值范围谁大谁小-了解"><a href="#02-16-Java语言基础-long与float的取值范围谁大谁小-了解" class="headerlink" title="02.16_Java语言基础(long与float的取值范围谁大谁小)(了解)"></a>02.16_Java语言基础(long与float的取值范围谁大谁小)(了解)</h3><ul>
<li><p>进行混合运算的时候,byte,short,char不会相互转换,都会自动类型提升为int类型,其他类型进行混合运算的是小的数据类型提升为大的</p>
<ul>
<li><p>byte,short,char – int – long – float – double</p>
</li>
<li><p>long: 8个字节</p>
</li>
<li>float：4个字节</li>
<li>IEEE754</li>
<li>4个字节是32个二进制位</li>
<li>1位是符号位</li>
<li>8位是指数位</li>
<li>00000000   11111111</li>
<li>0到255</li>
<li>1到254</li>
<li>-126到127</li>
<li>23位是尾数位</li>
<li><p>每个指数位减去127</p>
</li>
<li><p>A:它们底层的存储结构不同。</p>
</li>
<li>B:float表示的数据范围比long的范围要大<ul>
<li>long：2^63-1</li>
<li><code>float：3.4*10^38 &gt; 2*10^38 &gt; 2*8^38 = 2*2^3^38 = 2*2^114 &gt; 2^63-1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-17-Java语言基础-字符和字符串参与运算-掌握"><a href="#02-17-Java语言基础-字符和字符串参与运算-掌握" class="headerlink" title="02.17_Java语言基础(字符和字符串参与运算)(掌握)"></a>02.17_Java语言基础(字符和字符串参与运算)(掌握)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li>System.out.println(‘a’);</li>
<li><p>System.out.println(‘a’+1);</p>
</li>
<li><p>通过看结果知道’a’的值是多少,由此引出ASCII码表</p>
</li>
</ul>
</li>
<li>B:ASCII码表的概述<ul>
<li>记住三个值：<ul>
<li>‘0’  48</li>
<li>‘A’  65</li>
<li>‘a’  97</li>
</ul>
</li>
</ul>
</li>
<li>C:案例演示<ul>
<li>System.out.println(“hello”+’a’+1);</li>
<li>System.out.println(‘a’+1+”hello”);</li>
</ul>
</li>
<li>D:+在有字符串参与中被称为字符串连接符<ul>
<li>System.out.println(“5+5=”+5+5);</li>
<li>System.out.println(5+5+”=5+5”);</li>
</ul>
</li>
</ul>
<h3 id="02-18-Java语言基础-char数据类型-掌握"><a href="#02-18-Java语言基础-char数据类型-掌握" class="headerlink" title="02.18_Java语言基础(char数据类型)(掌握)"></a>02.18_Java语言基础(char数据类型)(掌握)</h3><ul>
<li>A:char c = 97;    0到65535</li>
<li>B:Java语言中的字符char可以存储一个中文汉字吗?为什么呢?<ul>
<li>可以。因为Java语言采用的是Unicode编码。Unicode编码中的每个字符占用两个字节。中文也是占的两个字节</li>
<li>所以，Java中的字符可以存储一个中文汉字</li>
</ul>
</li>
</ul>
<h3 id="02-19-Java语言基础-算术运算符的基本用法-掌握"><a href="#02-19-Java语言基础-算术运算符的基本用法-掌握" class="headerlink" title="02.19_Java语言基础(算术运算符的基本用法)(掌握)"></a>02.19_Java语言基础(算术运算符的基本用法)(掌握)</h3><ul>
<li>A:什么是运算符<ul>
<li>就是对常量和变量进行操作的符号。</li>
</ul>
</li>
<li>B:运算符的分类<ul>
<li>算术运算符，赋值运算符，比较(关系或条件)运算符，逻辑运算符，位运算符，三目(元)运算符 </li>
</ul>
</li>
<li>C:算数运算符有哪些<ul>
<li>+,-,*,/,%,++,– </li>
</ul>
</li>
<li>D:注意事项：<ul>
<li>a:+号在java中有三种作用,代表正号,做加法运算,字符串的连接符</li>
<li>b:整数相除只能得到整数。如果想得到小数，必须把数据变化为浮点数类型</li>
<li>c:/获取的是除法操作的商，%获取的是除法操作的余数</li>
<li>%运算符<ul>
<li>当左边的绝对值小于右边绝对值时,结果是左边</li>
<li>当左边的绝对值等于右边或是右边的倍数时,结果是0</li>
<li>当左边的绝对值大于右边绝对值时,结果是余数</li>
<li>%运算符结果的符号只和左边有关系,与右边无关</li>
<li>任何一个正整数%2结果不是0就是1可以用来当作切换条件 </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-20-Java语言基础-算术运算符-和–的用法-掌握"><a href="#02-20-Java语言基础-算术运算符-和–的用法-掌握" class="headerlink" title="02.20_Java语言基础(算术运算符++和–的用法)(掌握)"></a>02.20_Java语言基础(算术运算符++和–的用法)(掌握)</h3><ul>
<li>A:++,–运算符的作用<ul>
<li>自加（++）自减（–）运算</li>
<li>++:自加。对原有的数据进行+1</li>
<li>–:自减。对原有的数据进行-1</li>
</ul>
</li>
<li>B:案例演示<ul>
<li>a:单独使用：<ul>
<li>放在操作数的前面和后面效果一样。(这种用法是我们比较常见的)</li>
</ul>
</li>
<li>b:参与运算使用：<ul>
<li>放在操作数的前面，先自增或者自减，然后再参与运算。</li>
<li>放在操作数的后面，先参与运算，再自增或者自减。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-21-Java语言基础-算术运算符-和–的练习-掌握"><a href="#02-21-Java语言基础-算术运算符-和–的练习-掌握" class="headerlink" title="02.21_Java语言基础(算术运算符++和–的练习)(掌握)"></a>02.21_Java语言基础(算术运算符++和–的练习)(掌握)</h3><ul>
<li><p>A:案例演示</p>
<ul>
<li>请分别计算出a,b,c的值?<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">	<span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line">	<span class="keyword">int</span> b = <span class="number">10</span>;</div><div class="line">	<span class="keyword">int</span> c = <span class="number">10</span>;</div><div class="line"></div><div class="line">	a = b++;		</div><div class="line">	c = --a;			</div><div class="line">	b = ++a;		</div><div class="line">	a = c--;	</div><div class="line">```		</div><div class="line">* B:案例演示</div><div class="line">	* 请分别计算出x,y的值?</div><div class="line">```java</div><div class="line">			<span class="keyword">int</span> x = <span class="number">4</span>;</div><div class="line">			<span class="keyword">int</span> y = (x++)+(++x)+(x*<span class="number">10</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>C:面试题</p>
<ul>
<li>byte b = 10;</li>
<li>b++;</li>
<li>b = b + 1;</li>
<li>问哪句会报错,为什么 </li>
</ul>
</li>
</ul>
<h3 id="02-22-Java语言基础-赋值运算符的基本用法-掌握"><a href="#02-22-Java语言基础-赋值运算符的基本用法-掌握" class="headerlink" title="02.22_Java语言基础(赋值运算符的基本用法)(掌握)"></a>02.22_Java语言基础(赋值运算符的基本用法)(掌握)</h3><ul>
<li><p>A:赋值运算符有哪些</p>
<ul>
<li><p>a:基本的赋值运算符：=</p>
<ul>
<li>把=右边的数据赋值给左边。</li>
</ul>
</li>
<li><p>b:扩展的赋值运算符：+=,-=,*=,/=,%=</p>
<ul>
<li>+= 把左边和右边做加法，然后赋值给左边。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="02-23-Java语言基础-赋值运算符的面试题-掌握"><a href="#02-23-Java语言基础-赋值运算符的面试题-掌握" class="headerlink" title="02.23_Java语言基础(赋值运算符的面试题)(掌握)"></a>02.23_Java语言基础(赋值运算符的面试题)(掌握)</h3><ul>
<li>A:案例演示<ul>
<li>面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。</li>
<li>short s=1;s = s+1;</li>
<li>short s=1;s+=1;</li>
</ul>
</li>
</ul>
<h3 id="02-24-Java语言基础-关系运算符的基本用法及其注意事项-掌握"><a href="#02-24-Java语言基础-关系运算符的基本用法及其注意事项-掌握" class="headerlink" title="02.24_Java语言基础(关系运算符的基本用法及其注意事项)(掌握)"></a>02.24_Java语言基础(关系运算符的基本用法及其注意事项)(掌握)</h3><ul>
<li>A:关系运算符有哪些(比较运算符,条件运算符)<ul>
<li>==,!=,&gt;,&gt;=,&lt;,&lt;= </li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li><p>无论你的操作是简单还是复杂，结果是boolean类型。</p>
</li>
<li><p>“==”不能写成”=”。</p>
</li>
</ul>
</li>
</ul>
<h3 id="02-25-day02总结"><a href="#02-25-day02总结" class="headerlink" title="02.25_day02总结"></a>02.25_day02总结</h3><ul>
<li>把今天的知识点总结一遍。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;02-01-Java语言基础-常量的概述和使用-掌握&quot;&gt;&lt;a href=&quot;#02-01-Java语言基础-常量的概述和使用-掌握&quot; class=&quot;headerlink&quot; title=&quot;02.01_Java语言基础(常量的概述和使用)(掌握)&quot;&gt;&lt;/a&gt;02.01_Java语言基础(常量的概述和使用)(掌握)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:什么是常量&lt;ul&gt;
&lt;li&gt;在程序执行的过程中其值不可以发生改变 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;B:Java中常量的分类&lt;ul&gt;
&lt;li&gt;字面值常量&lt;/li&gt;
&lt;li&gt;自定义常量(面向对象部分讲) &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;C:字面值常量的分类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串常量    用双引号括起来的内容&lt;/li&gt;
&lt;li&gt;整数常量        所有整数&lt;/li&gt;
&lt;li&gt;小数常量        所有小数&lt;/li&gt;
&lt;li&gt;字符常量        用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号&lt;/li&gt;
&lt;li&gt;布尔常量        较为特殊，只有true和false&lt;/li&gt;
&lt;li&gt;空常量            null(数组部分讲解)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;D:案例演示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用输出语句输出各种常量。null不演示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="数据类型" scheme="http://harmansecurity.cn/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="运算符" scheme="http://harmansecurity.cn/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习笔记(一)</title>
    <link href="http://harmansecurity.cn/2017/03/19/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://harmansecurity.cn/2017/03/19/Java基础学习笔记(一)/</id>
    <published>2017-03-19T14:34:21.000Z</published>
    <updated>2017-03-19T14:59:19.130Z</updated>
    
    <content type="html"><![CDATA[<h3 id="01-01-计算机基础知识-计算机概述-了解"><a href="#01-01-计算机基础知识-计算机概述-了解" class="headerlink" title="01.01_计算机基础知识(计算机概述)(了解)"></a>01.01_计算机基础知识(计算机概述)(了解)</h3><ul>
<li>A:什么是计算机?计算机在生活中的应用举例<ul>
<li>计算机（Computer）全称：电子计算机，俗称电脑。是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。常见的形式有台式计算机、笔记本计算机、大型计算机等。</li>
<li>应用举例<ul>
<li>1：科学计算</li>
<li>2、数据处理</li>
<li>3、自动控制</li>
<li>4、计算机辅助设计</li>
<li>5、人工智能</li>
<li>6、多媒体应用</li>
<li>7、计算机网络</li>
<li>… </li>
</ul>
</li>
</ul>
</li>
<li><p>B:什么是硬件?硬件举例</p>
<ul>
<li>计算机硬件（Computer Hardware）是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。</li>
<li>冯.诺依曼体系结构</li>
<li><p>计算机的硬件分成5大组成部件：运算器、控制器、存储器、输入设备和输出设备。</p>
<ul>
<li>运算器和控制器是计算机的核心，合称中央处理单元（Central Processing Unit，CPU）或处理器。CPU的内部还有一些高速存储单元，被称为寄存器。其中运算器执行所有的算术和逻辑运算；控制器负责把指令逐条从存储器中取出，经译码后向计算机发出各种控制命令；而寄存器为处理单元提供操作所需要的数据。</li>
<li>存储器是计算机的记忆部分，用来存放程序以及程序中涉及的数据。它分为内部存储器和外部存储器。内部存储器用于存放正在执行的程序和使用的数据，其成本高、容量小，但速度快。外部存储器可用于长期保存大量程序和数据，其成本低、容量大，但速度较慢。</li>
<li>输入设备和输出设备统称为外部设备，简称外设或I/O设备，用来实现人机交互和机间通信。微型机中常用的输入设备有键盘、鼠标等，输出设备有显示器、打印机等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li>C:什么是软件?软件分类及举例<ul>
<li>计算机软件(Computer Software)是使用计算机过程中必不可少的东西，计算机软件可以使计算机按照事先预定好的顺序完成特定的功能</li>
<li>计算机软件按照其功能划分为系统软件与应用软件<ul>
<li>系统软件： DOS(Disk Operating System), Windows, Linux, Unix, Mac, Android, iOS</li>
<li>应用软件：office  QQ聊天  YY语言  扫雷</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-02-计算机基础知识-软件开发和计算机语言概述-了解"><a href="#01-02-计算机基础知识-软件开发和计算机语言概述-了解" class="headerlink" title="01.02_计算机基础知识(软件开发和计算机语言概述)(了解)"></a>01.02_计算机基础知识(软件开发和计算机语言概述)(了解)</h3><ul>
<li>A:什么是软件<ul>
<li>按照特定顺序组织的计算机数据和指令的集合</li>
</ul>
</li>
<li>B:什么是开发<ul>
<li>软件的制作过程</li>
</ul>
</li>
<li>C:什么是软件开发<ul>
<li>借助开发工具与计算机语言制作软件 </li>
</ul>
</li>
<li>D:什么是计算机语言<ul>
<li>人与计算机之间进行信息交流沟通的一种特殊语言</li>
</ul>
</li>
<li>E:计算机语言的分类<ul>
<li>机器语言：<ul>
<li>机器语言是直接用二进制代码指令表达的计算机语言，指令是用0和1组成的一串代码，它们有一定的位数，并分成若干段，各段的编码表示不同的含义。</li>
</ul>
</li>
<li>汇编语言：<ul>
<li>汇编语言是使用一些特殊的符号来代替机器语言的二进制码，计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言。</li>
</ul>
</li>
<li>高级语言：  <ul>
<li>使用普通英语进行编写源代码，通过编译器将源代码翻译成计算机直接识别的机器语言，之后再由计算机执行。</li>
<li>高级语言包括C,C++,C#,JAVA</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-03-计算机基础知识-人机交互-了解"><a href="#01-03-计算机基础知识-人机交互-了解" class="headerlink" title="01.03_计算机基础知识(人机交互)(了解)"></a>01.03_计算机基础知识(人机交互)(了解)</h3><ul>
<li>A:人机交互的两种方式<ul>
<li>a:命令行方式 <ul>
<li>需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。 </li>
</ul>
</li>
<li>b:图形化界面方式<ul>
<li>这种方式简单直观，使用者易于接受，容易上手操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="01-04-计算机基础知识-键盘功能键和快捷键-掌握"><a href="#01-04-计算机基础知识-键盘功能键和快捷键-掌握" class="headerlink" title="01.04_计算机基础知识(键盘功能键和快捷键)(掌握)"></a>01.04_计算机基础知识(键盘功能键和快捷键)(掌握)</h3><ul>
<li>A:键盘功能键<ul>
<li>a:Tab</li>
<li>b:Shift</li>
<li>c:Ctrl</li>
<li>d:Alt</li>
<li>e:空格    </li>
<li>f:Enter</li>
<li>g:Window</li>
<li>h:上下左右键</li>
<li>i:PrtSc(PrintScreen)屏幕截图</li>
</ul>
</li>
<li>B:键盘快捷键<ul>
<li>a:Ctrl+A    全选</li>
<li>b:Ctrl+C    复制</li>
<li>c:Ctrl+V    粘贴</li>
<li>d:Ctrl+X    剪切</li>
<li>e:Ctrl+Z    撤销</li>
<li>f:Ctrl+S    保存</li>
</ul>
</li>
</ul>
<h3 id="01-05-计算机基础知识-如何打开DOS控制台-掌握"><a href="#01-05-计算机基础知识-如何打开DOS控制台-掌握" class="headerlink" title="01.05_计算机基础知识(如何打开DOS控制台)(掌握)"></a>01.05_计算机基础知识(如何打开DOS控制台)(掌握)</h3><ul>
<li>A:xp下如何打开DOS控制台？<ul>
<li>a:开始–程序–附件–命令提示符</li>
<li>b:开始–运行–cmd–回车</li>
<li>c:win+r–cmd–回车</li>
</ul>
</li>
<li>B:win7下如何打开DOS控制台？<ul>
<li>a:开始–所有程序–附件–命令提示符</li>
<li>b:开始–搜索程序和文件–cmd–回车</li>
<li>c:win+r–cmd–回车</li>
</ul>
</li>
<li>C:win8下如何打开DOS控制台<ul>
<li>a:鼠标左击开始–下箭头–命令提示符</li>
<li>b:鼠标右击开始–搜索–cmd–回车</li>
<li>c:鼠标右击开始–运行–cmd–回车</li>
<li>d:win+r–cmd–回车</li>
</ul>
</li>
</ul>
<h3 id="01-06-计算机基础知识-常见的DOS命令讲解"><a href="#01-06-计算机基础知识-常见的DOS命令讲解" class="headerlink" title="01.06_计算机基础知识(常见的DOS命令讲解)"></a>01.06_计算机基础知识(常见的DOS命令讲解)</h3><ul>
<li>A:d: 回车    盘符切换</li>
<li>B:dir(directory):列出当前目录下的文件以及文件夹</li>
<li>C:cd (change directory)改变指定目录(进入指定目录)</li>
<li>D:cd.. : 退回到上一级目录</li>
<li>E:cd\: 退回到根目录</li>
<li>F:cls : (clear screen)清屏</li>
<li>G:exit : 退出dos命令行(分割线上的需要掌握,下的了解)</li>
<li>/=========================================================</li>
<li>md (make directory) : 创建目录</li>
<li>rd (remove directory): 删除目录</li>
<li>del (delete): 删除文件,删除一堆后缀名一样的文件*.txt</li>
<li>notepad 创建文件</li>
<li>删除带内容的文件夹<ul>
<li>rd + /s    文件夹名称(询问是否删除)</li>
<li>rd + /q + /s 文件夹名称(直接删除)</li>
</ul>
</li>
</ul>
<h3 id="01-07-Java语言基础-Java语言概述-了解"><a href="#01-07-Java语言基础-Java语言概述-了解" class="headerlink" title="01.07_Java语言基础(Java语言概述)(了解)"></a>01.07_Java语言基础(Java语言概述)(了解)</h3><ul>
<li>A:Java语言发展史<ul>
<li>詹姆斯·高斯林（James Gosling）1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司，1990年，与Patrick，Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak”，后改名为Java。</li>
<li>SUN(Stanford University Network，斯坦福大学网络公司) </li>
</ul>
</li>
<li>B:Java语言版本<ul>
<li>JDK 1.1.4        Sparkler    宝石                1997-09-12</li>
<li>JDK 1.1.5        Pumpkin        南瓜                1997-12-13</li>
<li>JDK 1.1.6        Abigail        阿比盖尔–女子名        1998-04-24</li>
<li>JDK 1.1.7        Brutus        布鲁图–古罗马政治家和将军    1998-09-28</li>
<li>JDK 1.1.8        Chelsea        切尔西–城市名            1999-04-08</li>
<li>J2SE 1.2        Playground    运动场                1998-12-04</li>
<li>J2SE 1.2.1        none        无                1999-03-30</li>
<li>J2SE 1.2.2        Cricket        蟋蟀                1999-07-08</li>
<li>J2SE 1.3        Kestrel        美洲红隼(sǔn)            2000-05-08</li>
<li>J2SE 1.3.1        Ladybird    瓢虫                2001-05-17</li>
<li>J2SE 1.4.0        Merlin        灰背隼                2002-02-13</li>
<li>J2SE 1.4.1        grasshopper    蚱蜢                2002-09-16</li>
<li>J2SE 1.4.2        Mantis        螳螂                2003-06-26</li>
<li>JAVASE 5.0 (1.5.0)    Tiger        老虎    </li>
<li>JAVASE 5.1 (1.5.1)    Dragonfly    蜻蜓    </li>
<li>JAVASE 6.0 (1.6.0)    Mustang        野马</li>
<li>JAVASE 7.0 (1.7.0)    Dolphin        海豚</li>
</ul>
</li>
<li>C:Java语言平台<ul>
<li>J2SE(Java 2 Platform Standard Edition)标准版<ul>
<li>是为开发普通桌面和商务应用程序提供的解决方案,该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发</li>
</ul>
</li>
<li>J2ME(Java 2 Platform Micro Edition)小型版<ul>
<li>是为开发电子消费产品和嵌入式设备提供的解决方案</li>
</ul>
</li>
<li>J2EE(Java 2 Platform Enterprise Edition)企业版<ul>
<li>是为开发企业环境下的应用程序提供的一套解决方案,该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发 </li>
</ul>
</li>
</ul>
</li>
<li>C:Java语言特点<ul>
<li>简单性        </li>
<li>解释性</li>
<li>面向对象        </li>
<li>高性能</li>
<li>分布式处理    </li>
<li>多线程</li>
<li>健壮性        </li>
<li>动态</li>
<li>结构中立        </li>
<li>安全性</li>
<li>开源</li>
<li>跨平台</li>
</ul>
</li>
</ul>
<h3 id="01-08-Java语言基础-Java语言跨平台原理-掌握"><a href="#01-08-Java语言基础-Java语言跨平台原理-掌握" class="headerlink" title="01.08_Java语言基础(Java语言跨平台原理)(掌握)"></a>01.08_Java语言基础(Java语言跨平台原理)(掌握)</h3><ul>
<li>A:什么是跨平台性</li>
<li>B:Java语言跨平台原理<ul>
<li>只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。</li>
</ul>
</li>
<li>C:Java语言跨平台图解<ul>
<li>write once ,run anywhere!(一处编译,到处运行)</li>
</ul>
</li>
</ul>
<h3 id="01-09-Java语言基础-JRE和JDK的概述-掌握"><a href="#01-09-Java语言基础-JRE和JDK的概述-掌握" class="headerlink" title="01.09_Java语言基础(JRE和JDK的概述)(掌握)"></a>01.09_Java语言基础(JRE和JDK的概述)(掌握)</h3><ul>
<li>A:什么是JRE<ul>
<li>包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</li>
<li>JRE:JVM+类库。 </li>
</ul>
</li>
<li>B:什么是JDK<ul>
<li>JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。</li>
<li>其中的开发工具：编译工具(javac.exe)  打包工具(jar.exe)等<ul>
<li>JDK:JRE+JAVA的开发工具。</li>
</ul>
</li>
</ul>
</li>
<li>C:为什么JDK中包含一个JRE<ul>
<li>为什么JDK中包含一个JRE呢？<ul>
<li>开发完的程序，需要运行一下看看效果。</li>
</ul>
</li>
</ul>
</li>
<li>D:JDK,JRE,JVM的作用和关系</li>
</ul>
<h3 id="01-10-Java语言基础-JDK的下载和安装过程图解-了解"><a href="#01-10-Java语言基础-JDK的下载和安装过程图解-了解" class="headerlink" title="01.10_Java语言基础(JDK的下载和安装过程图解)(了解)"></a>01.10_Java语言基础(JDK的下载和安装过程图解)(了解)</h3><ul>
<li>A:JDK的下载<ul>
<li>a:官网 <a href="http://www.oracle.com" target="_blank" rel="external">http://www.oracle.com</a></li>
<li>b:演示下载流程</li>
</ul>
</li>
<li>B:JDK的安装<ul>
<li>a:傻瓜式安装<ul>
<li>双击安装程序，然后一路next即可(但是不建议)</li>
</ul>
</li>
<li>b:安装的推荐方式<ul>
<li>安装路径不要有中文或者特殊符号如空格等。</li>
<li>所有和开发相关的软件最好安装目录统一。<ul>
<li>举例：我的JDK安装路径<ul>
<li>D:\develop\Java\jdk1.7.0_72</li>
</ul>
</li>
</ul>
</li>
<li>当提示安装JRE时，可以选择不安装。建议还是安装上。</li>
</ul>
</li>
<li>c:演示安装流程<ul>
<li>可以先在d盘建立一个文件夹develop</li>
<li>然后演示安装过程</li>
</ul>
</li>
</ul>
</li>
<li>C:验证安装是否成功<ul>
<li>a:通过DOS命令，切换到JDK安装的bin目录下。<ul>
<li>D:\develop\Java\jdk1.7.0_72\bin</li>
</ul>
</li>
<li>b:然后分别输入javac和java，如果正常显示一些内容，说明安装成功</li>
</ul>
</li>
</ul>
<h3 id="01-11-Java语言基础-JDK安装路径下的目录解释-了解"><a href="#01-11-Java语言基础-JDK安装路径下的目录解释-了解" class="headerlink" title="01.11_Java语言基础(JDK安装路径下的目录解释)(了解)"></a>01.11_Java语言基础(JDK安装路径下的目录解释)(了解)</h3><ul>
<li>a:bin目录：该目录用于存放一些可执行程序。<ul>
<li>如javac.exe（java编译器）、java.exe(java运行工具)，jar.exe(打包工具)和* javadoc.exe(文档生成工具)等。</li>
</ul>
</li>
<li>b:db目录：db目录是一个小型的数据库。<ul>
<li>从JDK 6.0开始，Java中引用了一个新的成员JavaDB，这是一个纯Java实现、开源的数据库管理系统。这个数据库不仅轻便，而且支持JDBC 4.0所有的规范，在学习JDBC 时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。</li>
</ul>
</li>
<li>c:jre目录：”jre”是 Java Runtime Environment 的缩写，意为Java程序运行时环境。此目录是Java运行时环境的根目录，它包括Java虚拟机，运行时的类包，Java应用启动器以及一个bin目录，但不包含开发环境中的开发工具。</li>
<li>d:include目录：由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。</li>
<li>e:lib目录：lib是library的缩写，意为 Java 类库或库文件，是开发工具使用的归档包文件。</li>
<li>f:src.zip文件：src.zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码，通过该文件可以查看Java基础类的源代码。</li>
</ul>
<h3 id="01-12-Java语言基础-Java开发工具介绍-了解"><a href="#01-12-Java语言基础-Java开发工具介绍-了解" class="headerlink" title="01.12_Java语言基础(Java开发工具介绍)(了解)"></a>01.12_Java语言基础(Java开发工具介绍)(了解)</h3><ul>
<li>A:notepad(微软操作系统自带)</li>
<li>B:Editplus/Notepad++</li>
<li>C:Eclipse</li>
<li>D:MyEclipse<ul>
<li>给大家简单的介绍一下这些工具，然后说说我们使用这些工具的顺序。</li>
<li>基础班：先notepad，然后Editplus，再Eclipse。</li>
<li>就业班：MyEclipse和Eclipse都用。</li>
</ul>
</li>
</ul>
<h3 id="01-13-Java语言基础-HelloWorld案例的编写和运行-掌握"><a href="#01-13-Java语言基础-HelloWorld案例的编写和运行-掌握" class="headerlink" title="01.13_Java语言基础(HelloWorld案例的编写和运行)(掌握)"></a>01.13_Java语言基础(HelloWorld案例的编写和运行)(掌握)</h3><ul>
<li>A:定义类</li>
<li>B:写main方法</li>
<li>C:写输出语句</li>
<li>D:Java程序开发运行与工作原理</li>
<li>E:编译和运行程序<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"HelloWorld"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="01-14-Java语言基础-HelloWorld案例常见问题-掌握"><a href="#01-14-Java语言基础-HelloWorld案例常见问题-掌握" class="headerlink" title="01.14_Java语言基础(HelloWorld案例常见问题)(掌握)"></a>01.14_Java语言基础(HelloWorld案例常见问题)(掌握)</h3><ul>
<li>A:找不到文件(都演示一下，让学生看看出现的都是什么问题)<ul>
<li>a:文件扩展名隐藏导致编译失败</li>
<li>b:文件名写错了</li>
</ul>
</li>
<li>B:单词拼写问题(都演示一下，让学生看看出现的都是什么问题)<ul>
<li>a:class写成Class</li>
<li>b:String写成string</li>
<li>c:System写成system</li>
<li>d:main写成mian</li>
</ul>
</li>
<li>C:括号匹配问题(都演示一下，让学生看看出现的都是什么问题)<ul>
<li>a:把类体的那对大括号弄掉一个</li>
<li>b:把方法体的那对大括号弄掉一个</li>
<li>c:把输出语句的那对小括号弄掉一个</li>
</ul>
</li>
<li>D:中英文问题(都演示一下，让学生看看出现的都是什么问题)<ul>
<li>a:提示信息：错误: 非法字符: \????的格式</li>
<li>注意：java编程中需要的基本上都是英文字符</li>
</ul>
</li>
</ul>
<h3 id="01-15-Java语言基础-Java语言的书写格式-约定俗成-掌握"><a href="#01-15-Java语言基础-Java语言的书写格式-约定俗成-掌握" class="headerlink" title="01.15_Java语言基础(Java语言的书写格式(约定俗成))    (掌握)"></a>01.15_Java语言基础(Java语言的书写格式(约定俗成))    (掌握)</h3><ul>
<li>1,大括号要对齐,并且成对写</li>
<li>2,左大括号前面有空格</li>
<li>3,遇到左大括号要缩进,Tab</li>
<li>4,方法和程序块之间加空行让程序看起来清晰</li>
<li>5,并排语句之间加空格,例如for语句</li>
<li>6,运算符两侧加空格</li>
</ul>
<h3 id="01-16-Java语言基础-path环境变量的作用及配置方式1-掌握"><a href="#01-16-Java语言基础-path环境变量的作用及配置方式1-掌握" class="headerlink" title="01.16_Java语言基础(path环境变量的作用及配置方式1)(掌握)"></a>01.16_Java语言基础(path环境变量的作用及配置方式1)(掌握)</h3><ul>
<li>A:在JDK的bin目录下开发程序容易产生的问题<ul>
<li>a:如果文件过多，不方便管理</li>
<li>b:删除自己写过的不需要的文件，可能不小心把JDK自带的工具给删除了</li>
</ul>
</li>
<li>B:如何解决问题呢<ul>
<li>notepad这样的命令为什么在任何路径下都能够执行,配置path环境变量</li>
</ul>
</li>
<li>C:配置方式<ul>
<li>a:xp系统<ul>
<li>右键点击桌面计算机→选择属性→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。</li>
</ul>
</li>
<li>b:win7/win8系统<ul>
<li>右键点击桌面计算机→选择属性→选择高级系统设置→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。</li>
</ul>
</li>
</ul>
</li>
<li>path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件</li>
</ul>
<h3 id="01-17-Java语言基础-Path环境变量的配置方式2-掌握"><a href="#01-17-Java语言基础-Path环境变量的配置方式2-掌握" class="headerlink" title="01.17_Java语言基础(Path环境变量的配置方式2)(掌握)"></a>01.17_Java语言基础(Path环境变量的配置方式2)(掌握)</h3><ul>
<li>A:先配置JAVA_HOME</li>
<li>B:再修改path</li>
<li>C:最后说一下path是有先后顺序关系的</li>
</ul>
<h3 id="01-18-Java语言基础-classpath环境变量的作用及其配置-了解"><a href="#01-18-Java语言基础-classpath环境变量的作用及其配置-了解" class="headerlink" title="01.18_Java语言基础(classpath环境变量的作用及其配置)(了解)"></a>01.18_Java语言基础(classpath环境变量的作用及其配置)(了解)</h3><ul>
<li>A:为什么要配置classpath</li>
<li>B:classpath配置的原理</li>
<li><p>C:如何配置classpath</p>
<p>  如果将Java执行环境比喻为操作系统，如果设置Path变量是为了让操作系统找到指定的工具程序(以Windows来说就是找到.exe文件)，则设置Classpath的目的就是让Java执行环境找到指定的Java程序(也就是.class文件)。</p>
</li>
<li><p>path和classpath的区别</p>
<ul>
<li>path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件</li>
<li>classpath配置的java的类文件,就是.class文件</li>
</ul>
</li>
</ul>
<h3 id="01-19-Java语言基础-Editplus开发程序并编译运行-了解"><a href="#01-19-Java语言基础-Editplus开发程序并编译运行-了解" class="headerlink" title="01.19_Java语言基础(Editplus开发程序并编译运行)(了解)"></a>01.19_Java语言基础(Editplus开发程序并编译运行)(了解)</h3><ul>
<li>A:配置快捷键编译运行</li>
<li>B:去除备份文件</li>
</ul>
<h3 id="01-20-Java语言基础-注释概述及其分类-掌握"><a href="#01-20-Java语言基础-注释概述及其分类-掌握" class="headerlink" title="01.20_Java语言基础(注释概述及其分类)(掌握)"></a>01.20_Java语言基础(注释概述及其分类)(掌握)</h3><ul>
<li>A:什么是注释</li>
<li><p>B:注释的分类及讲解</p>
<ul>
<li>文档注释目前不讲，说后面讲解</li>
</ul>
</li>
<li><p>注释的作用</p>
<ul>
<li>A:解释说明程序</li>
<li>B:帮助我们调试错误</li>
</ul>
</li>
</ul>
<h3 id="01-21-Java语言基础-关键字的概述和使用-掌握"><a href="#01-21-Java语言基础-关键字的概述和使用-掌握" class="headerlink" title="01.21_Java语言基础(关键字的概述和使用)(掌握)"></a>01.21_Java语言基础(关键字的概述和使用)(掌握)</h3><ul>
<li>A:什么是关键字<ul>
<li>被Java语言赋予特定含义的单词 </li>
</ul>
</li>
<li>B:关键字的特点<ul>
<li>组成关键字的字母全部小写 </li>
</ul>
</li>
<li>C:常见关键字<ul>
<li>public static void class等 </li>
</ul>
</li>
<li>D:关键字的注意事项<ul>
<li>goto和const作为保留字存在,目前并不使用,类似Editplus这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 </li>
</ul>
</li>
</ul>
<h3 id="01-22-Java语言基础-标识符的概述和组成规则-掌握"><a href="#01-22-Java语言基础-标识符的概述和组成规则-掌握" class="headerlink" title="01.22_Java语言基础(标识符的概述和组成规则)(掌握)"></a>01.22_Java语言基础(标识符的概述和组成规则)(掌握)</h3><ul>
<li>A:什么是标识符<ul>
<li>就是给类,接口,方法,变量等起名字时使用的字符序列 </li>
</ul>
</li>
<li>B:标识符的组成规则<ul>
<li>英文大小写字母</li>
<li>数字字符</li>
<li><code>$和__</code></li>
</ul>
</li>
<li>C:标识符注意事项<ul>
<li>1,不能使用关键字</li>
<li>2,不能数字开头 </li>
</ul>
</li>
</ul>
<h3 id="01-23-Java语言基础-标识符中常见的命名规则-了解"><a href="#01-23-Java语言基础-标识符中常见的命名规则-了解" class="headerlink" title="01.23_Java语言基础(标识符中常见的命名规则)(了解)"></a>01.23_Java语言基础(标识符中常见的命名规则)(了解)</h3><ul>
<li>见名知意</li>
<li>A:包<ul>
<li>最好是域名倒过来,要求所有的字母小写 </li>
</ul>
</li>
<li>B:类或者接口<ul>
<li>如果是一个单词首字母大写</li>
<li>如果是多个单词每个单词首字母大写(驼峰标识) </li>
</ul>
</li>
<li>C:方法或者变量<ul>
<li>如果是一个单词全部小写</li>
<li>如果是多个单词,从第二个单词首字母大写 </li>
</ul>
</li>
<li>D:常量<ul>
<li>如果是一个单词,所有字母大写</li>
<li>如果是多个单词,所有的单词大写,用下划线区分每个单词 </li>
</ul>
</li>
</ul>
<h3 id="01-24-day01总结"><a href="#01-24-day01总结" class="headerlink" title="01.24_day01总结"></a>01.24_day01总结</h3><ul>
<li>把今天的知识点总结一遍。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;01-01-计算机基础知识-计算机概述-了解&quot;&gt;&lt;a href=&quot;#01-01-计算机基础知识-计算机概述-了解&quot; class=&quot;headerlink&quot; title=&quot;01.01_计算机基础知识(计算机概述)(了解)&quot;&gt;&lt;/a&gt;01.01_计算机基础知识(计算机概述)(了解)&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;A:什么是计算机?计算机在生活中的应用举例&lt;ul&gt;
&lt;li&gt;计算机（Computer）全称：电子计算机，俗称电脑。是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。常见的形式有台式计算机、笔记本计算机、大型计算机等。&lt;/li&gt;
&lt;li&gt;应用举例&lt;ul&gt;
&lt;li&gt;1：科学计算&lt;/li&gt;
&lt;li&gt;2、数据处理&lt;/li&gt;
&lt;li&gt;3、自动控制&lt;/li&gt;
&lt;li&gt;4、计算机辅助设计&lt;/li&gt;
&lt;li&gt;5、人工智能&lt;/li&gt;
&lt;li&gt;6、多媒体应用&lt;/li&gt;
&lt;li&gt;7、计算机网络&lt;/li&gt;
&lt;li&gt;… &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;B:什么是硬件?硬件举例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;计算机硬件（Computer Hardware）是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。&lt;/li&gt;
&lt;li&gt;冯.诺依曼体系结构&lt;/li&gt;
&lt;li&gt;&lt;p&gt;计算机的硬件分成5大组成部件：运算器、控制器、存储器、输入设备和输出设备。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运算器和控制器是计算机的核心，合称中央处理单元（Central Processing Unit，CPU）或处理器。CPU的内部还有一些高速存储单元，被称为寄存器。其中运算器执行所有的算术和逻辑运算；控制器负责把指令逐条从存储器中取出，经译码后向计算机发出各种控制命令；而寄存器为处理单元提供操作所需要的数据。&lt;/li&gt;
&lt;li&gt;存储器是计算机的记忆部分，用来存放程序以及程序中涉及的数据。它分为内部存储器和外部存储器。内部存储器用于存放正在执行的程序和使用的数据，其成本高、容量小，但速度快。外部存储器可用于长期保存大量程序和数据，其成本低、容量大，但速度较慢。&lt;/li&gt;
&lt;li&gt;输入设备和输出设备统称为外部设备，简称外设或I/O设备，用来实现人机交互和机间通信。微型机中常用的输入设备有键盘、鼠标等，输出设备有显示器、打印机等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java语言基础" scheme="http://harmansecurity.cn/tags/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
      <category term="计算机基础知识" scheme="http://harmansecurity.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>2017年3月小记</title>
    <link href="http://harmansecurity.cn/2017/03/19/2017%E5%B9%B43%E6%9C%88%E5%B0%8F%E8%AE%B0/"/>
    <id>http://harmansecurity.cn/2017/03/19/2017年3月小记/</id>
    <published>2017-03-19T14:07:22.000Z</published>
    <updated>2017-03-19T14:22:52.737Z</updated>
    
    <content type="html"><![CDATA[<!--<img src="/diaryImages/diary-1.jpg" width = "700" height = "400"/>-->
<p>　　最近一直在忙着挑战杯以及看论文写论文，没有太多的时间来写博客。回想之前做的事，虽然都是有收获的但是有些还是没继续做到最后。自从寒假前想清楚以后要做的是从事技术，一直在盘算着未来到底做哪一块，什么样的岗位，想更适合做哪些领域的工作，早作决定然后早点准备，打牢基础。</p>
<p>　　对待买书这件事上一直不是很吝啬的，从去年到现在购买书所花费的费用快接近千元了，很多书都过了一遍，有些经典的书一时半会儿还吃不完，等以后有时间慢慢消化。本科有一些Java前端和后台开发的基础，对我来说选择Java更容易上手。但是之前所学深感都是皮毛，为了开发一个东西而开发，理解的深度不够。最近新购了一批Java相关的书籍，利用接下来的时间过一遍，从最基础的开始，温故而知新。也在看某马的Java基础教程，发现有些基础知识已经遗忘，这套视频的好处，每节课都会有一个markdown写的笔记，我打算看完一节视频，更新一下笔记，虽然都是基础，但是牢牢掌握还是很有必要的。先从基础开始，然后多动手实践。上学期看的相关安全类的书和做的一些简单小实验对自己还是有很大启发的，以前的开发中从未考虑过安全，很多细节在之后的开发中都需要注意。下面的就是书单，在这边发上来，也督促自己先把这些书看完。<br><a id="more"></a></p>
<div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B43%E6%9C%88%E5%B0%8F%E8%AE%B01.jpg" alt=""><br></div><br><div align="center"><br><img src="http://ojto7c1rw.bkt.clouddn.com/2017%E5%B9%B43%E6%9C%88%E5%B0%8F%E8%AE%B02.jpg" alt=""><br></div>
]]></content>
    
    <summary type="html">
    
      &lt;!--&lt;img src=&quot;/diaryImages/diary-1.jpg&quot; width = &quot;700&quot; height = &quot;400&quot;/&gt;--&gt;
&lt;p&gt;　　最近一直在忙着挑战杯以及看论文写论文，没有太多的时间来写博客。回想之前做的事，虽然都是有收获的但是有些还是没继续做到最后。自从寒假前想清楚以后要做的是从事技术，一直在盘算着未来到底做哪一块，什么样的岗位，想更适合做哪些领域的工作，早作决定然后早点准备，打牢基础。&lt;/p&gt;
&lt;p&gt;　　对待买书这件事上一直不是很吝啬的，从去年到现在购买书所花费的费用快接近千元了，很多书都过了一遍，有些经典的书一时半会儿还吃不完，等以后有时间慢慢消化。本科有一些Java前端和后台开发的基础，对我来说选择Java更容易上手。但是之前所学深感都是皮毛，为了开发一个东西而开发，理解的深度不够。最近新购了一批Java相关的书籍，利用接下来的时间过一遍，从最基础的开始，温故而知新。也在看某马的Java基础教程，发现有些基础知识已经遗忘，这套视频的好处，每节课都会有一个markdown写的笔记，我打算看完一节视频，更新一下笔记，虽然都是基础，但是牢牢掌握还是很有必要的。先从基础开始，然后多动手实践。上学期看的相关安全类的书和做的一些简单小实验对自己还是有很大启发的，以前的开发中从未考虑过安全，很多细节在之后的开发中都需要注意。下面的就是书单，在这边发上来，也督促自己先把这些书看完。&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://harmansecurity.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="小记" scheme="http://harmansecurity.cn/tags/%E5%B0%8F%E8%AE%B0/"/>
    
  </entry>
  
</feed>
