[{"title":"2017年5月小结","date":"2017-06-09T14:28:31.000Z","path":"2017/06/09/2017年5月小结/","text":"这一个月时间过得很快，主要就是继续按照之前制定的计划进行学习和找实习。准备好好打理自己的博客和GitHub，所以把之前的一些东西整理到GitHub上面，也阅读了《图解HTTP》、《MYSQL必知必会》两本书，然后对Java进行了一个加强的学习。 Java加强学习 Java加强 深入理解Java反射 深入理解Java注解 深入理解Java泛型 深入理解Java类加载器 深入理解Java动态代理 深入理解Java多线程及并发 找实习总结 众安保险：技术面，大概四十分钟。面试是在楼下的一个咖啡厅，主要的问的都是简历上写的内容：IO流、反射、多线程、集合泛型、动态代理、静态代理。笔试题：两道编程题，主要考察的是HashSet、TreeSet。 中软融鑫：Hr面，一个小时左右。其实也没聊什么，很快就伸出了橄榄枝。不过建议我去做数据库开发(这边的数据库开发是对数据进行一些处理，然后存储到Oracle中)。我的体会是：Hr完全不懂技术，然后我和另一个人同时面的都是Java岗位，她们缺做数据库开发的人，就说我们的经历更适合做数据库开发，跟我扯什么未来的规划，做数据库可以以后做项目经理，带团队，做Java开发就是个码农等等。最不能理解的是，说之前很多面试的人都不是很符合要求，说上海理工的学生跟我们的差距是不是因为学校的原因等等，总之给我留下的印象很差。 B站：技术面，大概四十分钟。可能由于早上七点钟左右就起床，然后早上面试完中软融鑫，下午又赶来面试B站，整个人的状态就很晕。总体给我的感觉还好，面试官也很亲切，B站公司的环境也很年轻化。问的问题比较多，比较细。问题有：泛型、反射、多线程、代理、mybatis、spring（AOP，IOC）、servlet和servlet容器和Javabean的区别、对json的认识。MySQL的问题也问的比较多，回答的不是很理想，其实刚看了MySQL必知必会，很多都没想起来，所以书上的内容还是需要实践的。MySQL方面的问题有：索引、MySQL有哪些引擎、什么是等值联结、left join和right join和inner join的区别等等。 饿了么：面试整个流程大概一小时，问的内容也很基础。一面项目经理：面向对象的几个特征、final能不能被继承、string的变量能不能被修改、SSH框架架构、集合、反射、多线程。二面架构师：后台的概念、我以前做的项目是前后台分离的还是什么、手写一个韩信点兵程序等等。三面Hr面：简单聊了聊，然后说前面两位面试官对我的评价都挺高，直接给我offer，然后今天就收到了Hr发的正式邮件offer。 EMC：EMC面试的很顺利啊，陆陆续续大概有四面。一面Hr面：简单问了下我的情况，做过什么，看我情况基本与岗位匹配，就把邮件转发给了应聘的部门。二面技术面：主要还是问的简历写的，还有一个算法是排序，对我了解ELK应该是加分项。接下来的两面就是去公司面的。三面技术面：一个其他部门的人来面的，也没问太多问题，就觉得我很优秀什么的，然后问我以后的规划。四面技术面：应该是部门老大，跟我讲了下部门的人员情况和详细介绍了做什么，问了一个简单算法(一个数组里面如果有重复的就返回true)，最后说没什么问题，之后让Hr通知给我offer。 面了五家目前收到了三家的offer，最大的感受是基础很重要。其实在EMC和饿了么飘摇不定，EMC给我的整体感受是很轻松，比较安逸，饿了么的话是互联网公司，可能加班严重会更辛苦，不过现阶段想学习更多的技术，最后还是决定去饿了么，离学校也是挺近的，只有两站路。半个月找实习已告一段落，接下来开始准备期末考试，然后去公司好好实习，按照制定的计划一步步来。","tags":[{"name":"小结","slug":"小结","permalink":"http://harmansecurity.cn/tags/小结/"}]},{"title":"深入理解Java多线程及并发","date":"2017-05-25T13:24:21.000Z","path":"2017/05/25/深入理解Java多线程及并发/","text":"一、线程创建的两种方式及区别1.扩展Thread类2.实现Runnable接口3.两者区别 采用继承Thread类方式：（1）优点：编写简单，如果需要访问当前线程，无需使用Thread.currentThread()方法，直接使用this，即可获得当前线程。（2）缺点：因为线程类已经继承了Thread类，所以不能再继承其他的父类。 采用实现Runnable接口方式：（1）优点：线程类只是实现了Runable接口，还可以继承其他的类。可以多个线程共享同一个目标对象，所以非常适合多个相同线程来处理同一份资源的情况。（2）缺点：编程稍微复杂，如果需要访问当前线程，必须使用Thread.currentThread()方法。 Runnable可以实现资源共享但Thread不能原因： 因为一个线程只能启动一次，通过Thread实现线程时，线程和线程所要执行的任务是捆绑在一起的。也就使得一个任务只能启动一个线程，不同的线程执行的任务是不相同的，所以没有必要，也不能让两个线程共享彼此任务中的资源。 一个任务可以启动多个线程，通过Runnable方式实现的线程，实际是开辟一个线程，将任务传递进去，由此线程执行。可以实例化多个 Thread对象，将同一任务传递进去，也就是一个任务可以启动多个线程来执行它。这些线程执行的是同一个任务，所以他们的资源是共享。12345678910111213141516171819202122232425262728293031package test;import java.io.IOException;public class Test &#123; /** * @param args * @throws IOException */ public static void main(String[] args) throws IOException &#123; // 第一种 Thread t = new Thread(new Test2()); t.start(); // 第二种 Thread t1 = new Thread(new Test3()); t1.start(); &#125;&#125;class Test2 implements Runnable &#123; public void run() &#123; &#125;&#125;class Test3 extends Thread &#123; public void run() &#123; &#125;&#125; 二、实现定时器的三种方式12345678910111213141516171819202122232425262728/** * 普通thread * 这是最常见的，创建一个thread，然后让它在while循环里一直运行着， * 通过sleep方法来达到定时任务的效果。这样可以快速简单的实现，代码如下： * */ public class Task1 &#123; public static void main(String[] args) &#123; // run in a second final long timeInterval = 1000; Runnable runnable = new Runnable() &#123; public void run() &#123; while (true) &#123; // ------- code for task to run System.out.println(\"Hello !!\"); // ------- ends here try &#123; Thread.sleep(timeInterval); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;; Thread thread = new Thread(runnable); thread.start(); &#125; &#125; 123456789101112131415161718192021222324252627import java.util.TimerTask; /** * * 于第一种方式相比，优势 1&gt;当启动和去取消任务时可以控制 2&gt;第一次执行任务时可以指定你想要的delay时间 * * 在实现时，Timer类可以调度任务，TimerTask则是通过在run()方法里实现具体任务。 Timer实例可以调度多任务，它是线程安全的。 * 当Timer的构造器被调用时，它创建了一个线程，这个线程可以用来调度任务。 下面是代码： * * */ public class Task2 &#123; public static void main(String[] args) &#123; TimerTask task = new TimerTask() &#123; @Override public void run() &#123; // task to run goes here System.out.println(\"Hello !!!\"); &#125; &#125;; Timer timer = new Timer(); long delay = 0; long intevalPeriod = 1 * 1000; // schedules the task to be run in an interval timer.scheduleAtFixedRate(task, delay, intevalPeriod); &#125; // end of main &#125; 12345678910111213141516171819202122232425262728293031import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; /** * * * ScheduledExecutorService是从Java SE5的java.util.concurrent里，做为并发工具类被引进的，这是最理想的定时任务实现方式。 * 相比于上两个方法，它有以下好处： * 1&gt;相比于Timer的单线程，它是通过线程池的方式来执行任务的 * 2&gt;可以很灵活的去设定第一次执行任务delay时间 * 3&gt;提供了良好的约定，以便设定执行的时间间隔 * * 下面是实现代码，我们通过ScheduledExecutorService#scheduleAtFixedRate展示这个例子，通过代码里参数的控制，首次执行加了delay时间。 * * */ public class Task3 &#123; public static void main(String[] args) &#123; Runnable runnable = new Runnable() &#123; public void run() &#123; // task to run goes here System.out.println(\"Hello !!\"); &#125; &#125;; ScheduledExecutorService service = Executors .newSingleThreadScheduledExecutor(); // 第二个参数为首次执行的延时时间，第三个参数为定时执行的间隔时间 service.scheduleAtFixedRate(runnable, 10, 1, TimeUnit.SECONDS); &#125; &#125; 三、线程同步和互斥1.多线程互斥 线程间互斥应对的是这种场景：多个线程操作同一个资源（即某个对象），为保证线程在对资源的状态（即对象的成员变量）进行一些非原子性操作后，状态仍然是正确的。典型的例子是“售票厅售票应用”。售票厅剩余100张票，10个窗口去卖这些票。这10个窗口，就是10条线程，售票厅就是他们共同操作的资源，其中剩余的100张票就是这个资源的一个状态。线程买票的过程就是去递减这个剩余数量的过程。 互斥操作的控制，Java提供了关键字synchronized进行的。synchronized可以修饰方法，也可以修饰代码段。其代表的含义就是：进入他修饰的这段代码内的线程必须先去获取一个特定对象的锁定标示，并且虚拟机保证这个标示一次只能被一条线程拥有。通过这两种方式修改上述代码的方法sellOneTicket()，如下： 1234567891011121314151617181920212223242526272829303132333435363738/** * 已经进行了互斥控制。这里是通过synchronized修饰整个方法实现的。 * 线程想进入这个方法，必须获取当前对象的锁定表示！ */ public synchronized void sellOneTicket()&#123; ticketNum--; // 打印剩余票的数量 if(ticketNum &gt;= 0)&#123; System.out.println(\"售票成功，剩余票数： \" + ticketNum); &#125;else&#123; System.out.println(\"售票失败，票已售罄！\"); &#125; &#125; /** * 已经进行了互斥控制。这里是通过synchronized修饰代码块实现的。线程要想进入修饰的代码块， * 必须获取lock对象的对象标示。 */ private Object lock = new Object(); public void sellOneTicket2()&#123; synchronized(lock)&#123; ticketNum--; // 打印剩余票的数量 if(ticketNum &gt;= 0)&#123; System.out.println(\"售票成功，剩余票数： \" + ticketNum); &#125;else&#123; System.out.println(\"售票失败，票已售罄！\"); &#125; &#125; &#125; 2.多线程同步 同步的概念再于线程间通信，比较典型的例子就是“生产者-消费者问题”。多个生产者和多个消费者就是多条执行线程，他们共同操作一个数据结构中的数据，数据结构中有时是没有数据的，这个时候消费者应该处于等待状态而不是不断的去访问这个数据结构。这里就涉及到线程间通信（当然此处还涉及到互斥，这里暂不考虑这一点），消费者线程一次消费后发现数据结构空了，就应该处于等待状态，生产者生产数据后，就去唤醒消费者线程开始消费。生产者线程某次生产后发现数据结构已经满了，也应该处于等待状态，消费者消费一条数据后，就去唤醒生产者继续生产。 实现这种线程间同步，可以通过Object类提供的wait，notify， notifyAll 3个方法去进行即可。一个简单的生产者和消费者的例子代码为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package cn.test; public class ProducerConsumer &#123; public static void main(String[] args) &#123; final MessageQueue mq = new MessageQueue(10); // 创建3个生产者 for(int p=0;p&lt;3;p++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; while(true)&#123; mq.put(\"消息来了！\"); // 生产消息后，休息100毫秒 try &#123; Thread.currentThread().sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;, \"Producer\" + p).start(); &#125; // 创建3个消费者 for(int s=0;s&lt;3;s++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; while(true)&#123; mq.get(); // 消费消息后，休息100毫秒 try &#123; Thread.currentThread().sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;, \"Consumer\" + s).start(); &#125; &#125; /** * 内部类模拟一个消息队列，生产者和消费者就去操作这个消息队列 */ private static class MessageQueue&#123; private String[] messages;// 放置消息的数据结构 private int opIndex; // 将要操作的位置索引 public MessageQueue(int size) &#123; if(size &lt;= 0)&#123; throw new IllegalArgumentException(\"消息队列的长度至少为1！\"); &#125; messages = new String[size]; opIndex = 0; &#125; public synchronized void put(String message)&#123; // Java中存在线程假醒的情况，此处用while而不是用if！可以参考Java规范！ while(opIndex == messages.length)&#123; // 消息队列已满，生产者需要等待 try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; messages[opIndex] = message; opIndex++; System.out.println(\"生产者 \" + Thread.currentThread().getName() + \" 生产了一条消息: \" + message); // 生产后，对消费者进行唤醒 notifyAll(); &#125; public synchronized String get()&#123; // Java中存在线程假醒的情况，此处用while而不是用if！可以参考Java规范！ while(opIndex == 0)&#123; // 消息队列无消息，消费者需要等待 try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; String message = messages[opIndex-1]; opIndex--; System.out.println(\"消费者 \" + Thread.currentThread().getName() + \" 消费了一条消息: \" + message); // 消费后，对生产者进行唤醒 notifyAll(); return message; &#125; &#125; &#125; 四、多线程访问共享数据1.如果每个线程执行的代码相同，可以使用同一个runnable对象，这个runnable对象中有那个共享对象。如：买票系统。12345678910111213141516171819202122public class MulteThreadlShareData &#123; public static void main(String[] args) &#123; ShareData shareData = new ShareData(); new Thread(shareData).start(); new Thread(shareData).start(); &#125; static class ShareData implements Runnable&#123; int count = 100; @Override public void run() &#123; while(count&gt;0)&#123; decrease(); &#125; &#125; public synchronized void decrease()&#123; count--; System.out.println(Thread.currentThread().getName()+\"this count: \"+count); &#125; &#125;&#125; 2.如果每个线程执行的代码不相同，就要用不同的runnable对象了。这种方式又有两种来实现这些runnable对象之间的数据共享。 将共享数据封装在另一个对象中，然后将这个对象逐一传递给各个runnable对象中。每个线程共享数据的操作方法也分配到了这个对象身上去完成，这样容易实现针对该数据进行共享数据的互斥和通信。代码实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142public class MulteThreadlShareData2 &#123; public static void main(String[] args) &#123; final ShareData shareData = new ShareData(); new Thread(new Decrease(shareData)).start(); new Thread(new Increment(shareData)).start(); &#125; static class Decrease implements Runnable&#123; private ShareData shareData; public Decrease(ShareData shareData)&#123; this.shareData=shareData; &#125; @Override public void run() &#123; shareData.decrease(); &#125; &#125; static class Increment implements Runnable&#123; private ShareData shareData; public Increment(ShareData shareData)&#123; this.shareData=shareData; &#125; @Override public void run() &#123; shareData.increment(); &#125; &#125; static class ShareData&#123; int count = 100; public synchronized void decrease()&#123; count--; System.out.println(Thread.currentThread().getName()+\"decrease this count: \"+count); &#125; public synchronized void increment()&#123; count++; System.out.println(Thread.currentThread().getName()+\"increment this count: \"+count); &#125; &#125;&#125; 将这些runnable对象作为某个类的内部类，共享数据作为这个外部类的成员变量，每个线程对共享数据的操作也分配到外部类，以便实现对共享数据进行的各个操作进行互斥和通信，作为内部类的各个runnable对象调用外部类的这些方法。 123456789101112131415161718192021222324252627282930public class MulteThreadlShareData3 &#123; static int count = 100; public static void main(String[] args) &#123; new Thread(new Decrease()).start(); new Thread(new Increment()).start(); &#125; public synchronized static void decrease()&#123; count--; System.out.println(Thread.currentThread().getName()+\"decrease this count: \"+count); &#125; public synchronized static void increment()&#123; count++; System.out.println(Thread.currentThread().getName()+\"increment this count: \"+count); &#125; static class Decrease implements Runnable&#123; @Override public void run() &#123; decrease(); &#125; &#125; static class Increment implements Runnable&#123; @Override public void run() &#123; increment(); &#125; &#125;&#125; 五、ThreadLocal与线程级变量共享1.ThreadLocal实现线程范围内变量共享123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package com.test.shareData;import java.util.Random;/*** * @description 通过ThreadLocal实现，同一个线程范围内，不同的对象中数据共享 * 注意：一个ThradLocal只能代表一个变量，即只能放一个数据；多个线程范围内都需要共享数据，则需要定义多个ThreadLocal * 另外：多个变量共享，同一个线程范围内共享，可通过创建实体对象，将实体对象放到ThreadLocal中 * */public class ThreadLocalTest &#123; //1.一个ThradLocal只能代表一个变量，即只能放一个数据；多个线程范围内都需要共享数据，则需要定义多个ThreadLocal private static ThreadLocal&lt;Integer&gt; x=new ThreadLocal&lt;Integer&gt;(); //2.多个变量共享(共享name,age)，同一个线程范围内共享，可通过创建实体对象，将实体对象放到ThreadLocal中 private static ThreadLocal&lt;MyTreadScopeData&gt; myThreadLocal=new ThreadLocal&lt;MyTreadScopeData&gt;(); public static void main(String[] args) &#123; for(int i=0;i&lt;2;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; int data=new Random().nextInt(); x.set(data); System.out.println(Thread.currentThread().getName()+\" data\"+data); MyTreadScopeData myTreadScopeData=new MyTreadScopeData(); myTreadScopeData.setName(\"chenxiaobing\"); myTreadScopeData.setAge(28); myThreadLocal.set(myTreadScopeData); new A().get(); new B().get(); &#125; &#125;).start(); &#125; &#125; static class A&#123; int data=x.get(); private void get()&#123; System.out.println(\"class A:\"+Thread.currentThread().getName()+data); // MyTreadScopeData myThread=myThreadLocal.get(); // myThread.setAge(30); // myThread.setName(\"aaaaaaaaaaaaaaa\"); System.out.println(\"class A myThreadLocal:\"+Thread.currentThread().getName()+myThreadLocal.get().getName()); &#125; &#125; static class B&#123; int data=x.get(); private void get()&#123; System.out.println(\"class B:\"+Thread.currentThread().getName()+data); // MyTreadScopeData myThread=myThreadLocal.get(); // myThread.setAge(30); // myThread.setName(\"bbbbbbbbbbbbbbbb\"); System.out.println(\"class B myThreadLocal:\"+Thread.currentThread().getName()+myThreadLocal.get().getName()); &#125; &#125;&#125;class MyTreadScopeData&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 2.单例模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package com.test.shareData;import java.util.Random;/*** * @description 通过ThreadLocal实现，同一个线程范围内，不同的对象中数据共享 * 注意：一个ThradLocal只能代表一个变量，即只能放一个数据；多个线程范围内都需要共享数据，则需要定义多个ThreadLocal * 另外：多个变量共享，同一个线程范围内共享，可通过创建实体对象，将实体对象放到ThreadLocal中 * */public class ThreadLocalTest1 &#123; private static ThreadLocal&lt;Integer&gt; x=new ThreadLocal&lt;Integer&gt;(); public static void main(String[] args) &#123; for(int i=0;i&lt;2;i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; int data=new Random().nextInt(); x.set(data); System.out.println(Thread.currentThread().getName()+\" data\"+data); MyTreadScopeData1 myTreadScopeData =MyTreadScopeData1.getInstance(); myTreadScopeData.setName(\"chenxiaobing\"+data); myTreadScopeData.setAge(data); new A().get(); new B().get(); &#125; &#125;).start(); &#125; &#125; static class A&#123; int data=x.get(); private void get()&#123; System.out.println(\"class A:\"+Thread.currentThread().getName()+data); MyTreadScopeData1 myTreadScopeData =MyTreadScopeData1.getInstance(); System.out.println(\"class A myThreadLocal:\"+Thread.currentThread().getName()+myTreadScopeData.getName()); &#125; &#125; static class B&#123; int data=x.get(); private void get()&#123; System.out.println(\"class B:\"+Thread.currentThread().getName()+data); MyTreadScopeData1 myTreadScopeData =MyTreadScopeData1.getInstance(); System.out.println(\"class B myThreadLocal:\"+Thread.currentThread().getName()+myTreadScopeData.getName()); &#125; &#125;&#125;class MyTreadScopeData1&#123; private MyTreadScopeData1()&#123;&#125;//私有的构成方法，使其他无法创建实例对象 //1.懒汉、饱汉模式的单例，预先定义一个静态的实例对象 /*private static MyTreadScopeData1 instance=new MyTreadScopeData1(); public static MyTreadScopeData1 getInstance()&#123;//定义一个可供其他调用的静态方法 return instance; &#125;*/ //2.饿汉模式的单例，只有在需要时才创建实例对象 /*private static MyTreadScopeData1 instance=null; public static synchronized MyTreadScopeData1 getInstance()&#123;//定义一个可供其他调用的静态方法 if(null==instance)&#123; instance =new MyTreadScopeData1(); &#125; return instance; &#125;*/ //3.这里ThreadLocal的使用，类似1/2中的单例模式,只是1/2单例模式，所有线程都会共享MyTreadScopeData1的实例对象 private static ThreadLocal&lt;MyTreadScopeData1&gt; myThreadLocal=new ThreadLocal&lt;MyTreadScopeData1&gt;(); //不同的线程共享不同的实例对象，不需要使用synchronized public static MyTreadScopeData1 getInstance()&#123; MyTreadScopeData1 instance=myThreadLocal.get(); if(null==instance)&#123; instance =new MyTreadScopeData1(); myThreadLocal.set(instance); &#125; return instance; &#125; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 六、java4种线程池的使用Java通过Executors提供四种线程池，分别为： newCachedThreadPool创建个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 1.newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。线程池为无限大，当执行第二个任务时第一个任务已经完成，会复用执行第一个任务的线程，而不用每次新建线程。示例代码如下： 123456789101112131415161718192021package test; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolExecutorTest &#123; public static void main(String[] args) &#123; ExecutorService cachedThreadPool = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; try &#123; Thread.sleep(index * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; cachedThreadPool.execute(new Runnable() &#123; public void run() &#123; System.out.println(index); &#125; &#125;); &#125; &#125; &#125; 2.newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。因为线程池大小为3，每个任务输出index后sleep 2秒，所以每两秒打印3个数字。定长线程池的大小最好根据系统资源进行设置。如Runtime.getRuntime().availableProcessors()。示例代码如下： 123456789101112131415161718192021package test; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolExecutorTest &#123; public static void main(String[] args) &#123; ExecutorService fixedThreadPool = Executors.newFixedThreadPool(3); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; fixedThreadPool.execute(new Runnable() &#123; public void run() &#123; try &#123; System.out.println(index); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; &#125; 3.newScheduledThreadPool创建一个定长线程池，支持定时及周期性任务执行。延迟执行示例代码如下： 1234567891011121314151617181920212223242526272829303132//表示延迟3秒执行。package test; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class ThreadPoolExecutorTest &#123; public static void main(String[] args) &#123; ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.schedule(new Runnable() &#123; public void run() &#123; System.out.println(\"delay 3 seconds\"); &#125; &#125;, 3, TimeUnit.SECONDS); &#125; &#125; //表示延迟1秒后每3秒执行一次。package test; import java.util.concurrent.Executors; import java.util.concurrent.ScheduledExecutorService; import java.util.concurrent.TimeUnit; public class ThreadPoolExecutorTest &#123; public static void main(String[] args) &#123; ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(5); scheduledThreadPool.scheduleAtFixedRate(new Runnable() &#123; public void run() &#123; System.out.println(\"delay 1 seconds, and excute every 3 seconds\"); &#125; &#125;, 1, 3, TimeUnit.SECONDS); &#125; &#125; 4.newSingleThreadExecutor创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。示例代码如下： 123456789101112131415161718192021package test; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class ThreadPoolExecutorTest &#123; public static void main(String[] args) &#123; ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor(); for (int i = 0; i &lt; 10; i++) &#123; final int index = i; singleThreadExecutor.execute(new Runnable() &#123; public void run() &#123; try &#123; System.out.println(index); Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; &#125; &#125; 七、线程锁技术1.Lock概念Lock比传统线程模型中的synchronized方式更加面向对象，与生活中的锁类似，锁本身也是一个对象。两个线程执行的代码片段要实现同步互斥的效果，它们必须用同一个Lock对象。锁是加在代表要操作的资源的类的内部方法中，而不是线程代码中！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.util.concurrent.locks.Lock; import java.util.concurrent.locks.ReentrantLock; public class LockTest &#123; public static void main(String[] args) &#123; new TraditionalThreadSynchronized().init(); &#125; public void init()&#123; final Outputer outputer=new Outputer(); new Thread(new Runnable()&#123; public void run() &#123; while(true)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; outputer.output(\"ABCDEFGHIJKLNOPQRST\"); &#125; &#125; &#125; ).start(); new Thread(new Runnable()&#123; public void run() &#123; while(true)&#123; try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; outputer.output(\"abcdefghijklmnopqrst\"); &#125; &#125; &#125; ).start(); &#125; class Outputer&#123; Lock lock = new ReentrantLock();//创建一个锁 public void output(String name)&#123; int len=name.length(); lock.lock();//上锁 try &#123; for (int i = 0; i &lt; len; i++) &#123; System.out.print(name.charAt(i)); &#125; System.out.println(); &#125;finally&#123; //这么做是防止线程死掉大家都进不去 lock.unlock();//开锁 &#125; &#125; &#125; &#125; 2.读写锁读写锁:分为读锁和写锁，多个读锁不互斥，读锁与写锁互斥，写锁与写锁互斥，这是由JVM自己控制的，你只要加好相应的锁即可。如果代码只读数据，可以很多人同时读，但是不能同时写，那就加读锁；如果代码修改数据，只能有一个人在写，且不能同时读取，那就加写锁。总之，读的时候加读锁，写的时候加写锁。 如果我们上了读写锁，读的时候没有写，写的时候没有读和其它写，即是“读中无写，写中无读写”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Random; import java.util.concurrent.locks.ReentrantReadWriteLock; public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; final Queue q = new Queue(); for (int i = 0; i &lt; 3; i++) &#123; new Thread()&#123; public void run()&#123; while(true)&#123; q.get(); &#125; &#125; &#125;.start(); new Thread()&#123; public void run()&#123; while(true)&#123; q.put(new Random().nextInt(10000)); &#125; &#125; &#125;.start(); &#125; &#125; &#125; class Queue&#123; private Object data = null;//共享数据，只有一个线程能写该数据，但可以有多个线程同时读该数据 private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); public void get()&#123; rwl.readLock().lock(); try &#123; System.out.println(Thread.currentThread().getName().toString()+\"准备读取数据\"); Thread.sleep((long)Math.random()*1000); System.out.println(Thread.currentThread().getName().toString()+\"读取数据：\"+data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; rwl.readLock().unlock(); &#125; &#125; public void put(Object data)&#123; rwl.writeLock().lock(); try &#123; System.out.println(Thread.currentThread().getName().toString()+\"准备改写数据\"); Thread.sleep((long)Math.random()*1000); this.data=data; System.out.println(Thread.currentThread().getName().toString()+\"改写数据为：\"+data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally&#123; rwl.writeLock().unlock(); &#125; &#125; &#125; 八、同步集合 1.传统集合类在并发访问时的问题说明，见例子程序 2.传统方式下用Collections工具类提供的synchronizedCollection方法来获得同步集合，分析该方法的实现源码。 3.传统方式下的Collection在迭代集合时，不允许对集合进行修改。 4.通过看java.util.concurrent包下的介绍可以知道有哪些并发集合 (1)ConcurrentHashMap (2)CopyOnWriteArrayList (3)CopyOnWriteArraySet 12345678910111213141516171819202122232425262728293031package edu.java5.util; import java.util.ArrayList; import java.util.Collection; import java.util.Iterator; import java.util.concurrent.CopyOnWriteArrayList; public class CollectionModifyException &#123; public static void main(String[] args) &#123; //将ArrayList改为CopyOnWriteArrayList,则不会出现以下情况 Collection users = new ArrayList(); //Collection users = new CopyOnWriteArrayList(); users.add(new User(\"张三\",28)); users.add(new User(\"李四\",25)); users.add(new User(\"王五\",31)); Iterator itrUsers = users.iterator(); while(itrUsers.hasNext())&#123; User user = (User)itrUsers.next(); if(\"张三\".equals(user.getName()))&#123; //代码1 /** * 注意比较这两种的区别 * users.remove(user)操作可能会引起异常，集合中的数据会被删除 * itrUsers.remove()操作不会引起异常，集合中的数据会被删除 **/ users.remove(user); //代码2 //itrUsers.remove(); //代码3 &#125; else &#123; System.out.println(user); &#125; &#125; System.out.println(users.size()); &#125; &#125; 九、参考文献 http://blog.csdn.net/zhongguozhichuang/article/details/53928447 http://blog.csdn.net/u013702312/article/details/51145703 http://blog.csdn.net/drifterj/article/details/7771230 http://www.cnblogs.com/lcngu/p/5150024.html http://www.cnblogs.com/brant/p/6017407.html http://www.cnblogs.com/SKILL0825/p/5971539.html http://blog.csdn.net/acmman/article/details/52902128 http://blog.csdn.net/xh16319/article/details/8241368","tags":[{"name":"多线程","slug":"多线程","permalink":"http://harmansecurity.cn/tags/多线程/"},{"name":"并发","slug":"并发","permalink":"http://harmansecurity.cn/tags/并发/"}]},{"title":"深入理解Java动态代理","date":"2017-05-25T11:34:21.000Z","path":"2017/05/25/深入理解Java动态代理/","text":"一、静态代理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package common;public class Test &#123; static interface Subject&#123; void sayHi(); void sayHello(); &#125; static class SubjectImpl implements Subject&#123; @Override public void sayHi() &#123; System.out.println(\"hi\"); &#125; @Override public void sayHello() &#123; System.out.println(\"hello\"); &#125; &#125; static class SubjectImplProxy implements Subject&#123; private Subject target; public SubjectImplProxy(Subject target) &#123; this.target=target; &#125; @Override public void sayHi() &#123; System.out.print(\"say:\"); target.sayHi(); &#125; @Override public void sayHello() &#123; System.out.print(\"say:\"); target.sayHello(); &#125; &#125; public static void main(String[] args) &#123; Subject subject=new SubjectImpl(); Subject subjectProxy=new SubjectImplProxy(subject); subjectProxy.sayHi(); subjectProxy.sayHello(); &#125;&#125; 这段代码中首先定义了一个Subject接口，接口中有两个方法。然后定义了SubjectImpl类实现Subject接口并实现其中的两个方法，到这里肯定是没问题的。现在再定义一个SubjuectImplProxy类，也实现Subject接口。这个SubjectImplProxy类的作用是包装SubjectImpl类的实例，它的内部定义一个变量target来保存一个SubjectImpl的实例。SubjectImplProxy也实现了接口规定的两个方法，并且在它的实现版本中，都调用了SubjectImpl的实现，但是又添加了自己的处理逻辑。相信这段代码不难理解，它通过对SubjectImpl进行包装，达到了给输出内容添加前缀的功能。这种代理方式叫做静态代理。 二、代理：设计模式 代理模式是一种常用的设计模式，其目的就是为其他对象提供一个代理以控制对某个真实对象的访问。代理类负责为委托类预处理消息，过滤消息并转发消息，以及进行消息被委托类执行后的后续处理。 通过代理层这一中间层，有效的控制对于真实委托类对象的直接访问，同时可以实现自定义的控制策略（Spring的AOP机制），设计上获得更大的灵活性。 三、java动态代理的类和接口1.java.lang.reflect.Proxy：动态代理机制的主类，提供一组静态方法为一组接口动态的生成对象和代理类。12345678910111213// 方法 1: 该方法用于获取指定代理对象所关联的调用处理器public static InvocationHandler getInvocationHandler(Object proxy) // 方法 2：该方法用于获取关联于指定类装载器和一组接口的动态代理类的类对象public static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;... interfaces)// 方法 3：该方法用于判断指定类对象是否是一个动态代理类public static boolean isProxyClass(Class&lt;?&gt; cl) // 方法 4：该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h) 2.java.lang.reflect.InvocationHandler：调用处理器接口，自定义invokle方法，用于实现对于真正委托类的代理访问。123456789/* 该方法负责集中处理动态代理类上的所有方法调用。 第一个参数既是代理类实例， 第二个参数是被调用的方法对象 第三个方法是调用参数。 调用处理器根据这三个参数进行预处理或分派到委托类实例上发射执行*/public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; 3.java.lang.ClassLoader：类装载器类。 将类的字节码装载到Java虚拟机（JVM）中并为其定义类对象，然后该类才能被使用。Proxy类与普通类的唯一区别就是其字节码是由 JVM 在运行时动态生成的而非预存在于任何一个.class文件中。每次生成动态代理类对象时都需要指定一个类装载器对象：newProxyInstance()方法第一个参数。 四、动态代理机制java动态代理创建对象的过程为如下步骤： 1.通过实现 InvocationHandler 接口创建自己的调用处理器；123// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发// 其内部通常包含指向委托类实例的引用，用于真正执行分派转发过来的方法调用InvocationHandler handler = new InvocationHandlerImpl(..); 2.通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类；12// 通过 Proxy 为包括 Interface 接口在内的一组接口动态创建代理类的类对象Class clazz = Proxy.getProxyClass(classLoader, new Class[] &#123; Interface.class, ... &#125;); 3.通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型；12// 通过反射从生成的类对象获得构造函数对象Constructor constructor = clazz.getConstructor(new Class[] &#123; InvocationHandler.class &#125;); 4.通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入。12// 通过构造函数对象创建动态代理类实例Interface Proxy = (Interface)constructor.newInstance(new Object[] &#123; handler &#125;); 为了简化对象创建过程，Proxy类中的newProxyInstance方法封装了2~4，只需两步即可完成代理对象的创建。 1234567// InvocationHandlerImpl 实现了 InvocationHandler 接口，并能实现方法调用从代理类到委托类的分派转发InvocationHandler handler = new InvocationHandlerImpl(..); // 通过 Proxy 直接创建动态代理类实例Interface proxy = (Interface)Proxy.newProxyInstance( classLoader, new Class[] &#123; Interface.class &#125;, handler ); 五、动态代理实现 AOP的拦截功能是由java中的动态代理来实现的。说白了，就是在目标类的基础上增加切面逻辑，生成增强的目标类（该切面逻辑或者在目标类函数执行之前，或者目标类函数执行之后，或者在目标类函数抛出异常时候执行。不同的切入时机对应不同的Interceptor的种类，如BeforeAdviseInterceptor，AfterAdviseInterceptor以及ThrowsAdviseInterceptor等）。 那么动态代理是如何实现将切面逻辑（advise）织入到目标类方法中去的呢？下面我们就来详细介绍并实现AOP中用到的两种动态代理。 AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。总的来说，反射机制在生成类的过程中比较高效，而asm在生成类之后的相关执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。还有一点必须注意：jdk动态代理的应用前提，必须是目标类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势 1.定义接口和实现12345678package com.meituan.hyt.test3.service; public interface UserService &#123; public String getName(int id); public Integer getAge(int id); &#125; 123456789101112131415161718package com.meituan.hyt.test3.service.impl; import com.meituan.hyt.test3.service.UserService; public class UserServiceImpl implements UserService &#123; @Override public String getName(int id) &#123; System.out.println(\"------getName------\"); return \"Tom\"; &#125; @Override public Integer getAge(int id) &#123; System.out.println(\"------getAge------\"); return 10; &#125; &#125; 2.jdk动态代理实现1234567891011121314151617181920212223242526272829303132package com.meituan.hyt.test3.jdk; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; public class MyInvocationHandler implements InvocationHandler &#123; private Object target; MyInvocationHandler() &#123; super(); &#125; MyInvocationHandler(Object target) &#123; super(); this.target = target; &#125; @Override public Object invoke(Object o, Method method, Object[] args) throws Throwable &#123; if(\"getName\".equals(method.getName()))&#123; System.out.println(\"++++++before \" + method.getName() + \"++++++\"); Object result = method.invoke(target, args); System.out.println(\"++++++after \" + method.getName() + \"++++++\"); return result; &#125;else&#123; Object result = method.invoke(target, args); return result; &#125; &#125; &#125; 12345678910111213141516171819package com.meituan.hyt.test3.jdk; import com.meituan.hyt.test3.service.UserService; import com.meituan.hyt.test3.service.impl.UserServiceImpl; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; public class Main1 &#123; public static void main(String[] args) &#123; UserService userService = new UserServiceImpl(); InvocationHandler invocationHandler = new MyInvocationHandler(userService); UserService userServiceProxy = (UserService)Proxy.newProxyInstance(userService.getClass().getClassLoader(), userService.getClass().getInterfaces(), invocationHandler); System.out.println(userServiceProxy.getName(1)); System.out.println(userServiceProxy.getAge(1)); &#125; &#125; 123456789//运行结果运行结果++++++before getName++++++------getName------++++++after getName++++++Tom------getAge------10 3.cglib动态代理实现 Cglib是一个优秀的动态代理框架，它的底层使用ASM在内存中动态的生成被代理类的子类，使用CGLIB即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB具有简单易用，它的运行速度要远远快于JDK的Proxy动态代理。 CGLIB的核心类： net.sf.cglib.proxy.Enhancer – 主要的增强类 net.sf.cglib.proxy.MethodInterceptor – 主要的方法拦截类，它是Callback接口的子接口，需要用户实现 net.sf.cglib.proxy.MethodProxy – JDK的java.lang.reflect.Method类的代理类，可以方便的实现对源对象方法的调用,如使用： Object o = methodProxy.invokeSuper(proxy, args);//虽然第一个参数是被代理对象，也不会出现死循环的问题。 net.sf.cglib.proxy.MethodInterceptor接口是最通用的回调（callback）类型，它经常被基于代理的AOP用来实现拦截（intercept）方法的调用。这个接口只定义了一个方法public Object intercept(Object object, java.lang.reflect.Method method,Object[] args, MethodProxy proxy) throws Throwable; 第一个参数是代理对像，第二和第三个参数分别是拦截的方法和方法的参数。原来的方法可能通过使用java.lang.reflect.Method对象的一般反射调用，或者使用net.sf.cglib.proxy.MethodProxy对象调用。net.sf.cglib.proxy.MethodProxy通常被首选使用，因为它更快。 12345678910111213141516171819package com.meituan.hyt.test3.cglib; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class CglibProxy implements MethodInterceptor &#123; @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"++++++before \" + methodProxy.getSuperName() + \"++++++\"); System.out.println(method.getName()); Object o1 = methodProxy.invokeSuper(o, args); System.out.println(\"++++++before \" + methodProxy.getSuperName() + \"++++++\"); return o1; &#125; &#125; 123456789101112131415161718192021package com.meituan.hyt.test3.cglib; import com.meituan.hyt.test3.service.UserService; import com.meituan.hyt.test3.service.impl.UserServiceImpl; import net.sf.cglib.proxy.Enhancer; public class Main2 &#123; public static void main(String[] args) &#123; CglibProxy cglibProxy = new CglibProxy(); Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(UserServiceImpl.class); enhancer.setCallback(cglibProxy); UserService o = (UserService)enhancer.create(); o.getName(1); o.getAge(1); &#125; &#125; 123456789//输出++++++before CGLIB$getName$0++++++getName------getName------++++++before CGLIB$getName$0++++++++++++before CGLIB$getAge$1++++++getAge------getAge------++++++before CGLIB$getAge$1++++++ 六、参考文献 http://blog.csdn.net/scplove/article/details/52451899 http://blog.csdn.net/heyutao007/article/details/49738887 http://rejoy.iteye.com/blog/1627405 http://blog.csdn.net/dapangzi88/article/details/54848260","tags":[{"name":"动态代理","slug":"动态代理","permalink":"http://harmansecurity.cn/tags/动态代理/"},{"name":"AOP","slug":"AOP","permalink":"http://harmansecurity.cn/tags/AOP/"}]},{"title":"深入理解Java类加载器","date":"2017-05-24T14:11:21.000Z","path":"2017/05/24/深入理解Java类加载器/","text":"1. 类的加载过程 JVM将类加载过程分为三个步骤：装载（Load），链接（Link）和初始化(Initialize)链接又分为三个步骤： 装载：查找并加载类的二进制数据； 链接： 验证：确保被加载类的正确性； 准备：为类的静态变量分配内存，并将其初始化为默认值； 解析：把类中的符号引用转换为直接引用； 初始化：为类的静态变量赋予正确的初始值； 2. 类的初始化类什么时候才被初始化： 1）创建类的实例，也就是new一个对象 2）访问某个类或接口的静态变量，或者对该静态变量赋值 3）调用类的静态方法 4）反射（Class.forName(“com.lyj.load”)） 5）初始化一个类的子类（会首先初始化子类的父类） 6）JVM启动时标明的启动类，即文件名和类名相同的那个类 只有这6中情况才会导致类的类的初始化。 类的初始化步骤： 1）如果这个类还没有被加载和链接，那先进行加载和链接 2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口） 3)加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。 3.类的加载 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象。如下图： 类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。 加载类的方式有以下几种： 1）从本地系统直接加载 2）通过网络下载.class文件 3）从zip，jar等归档文件中加载.class文件 4）从专有数据库中提取.class文件 5）将Java源文件动态编译为.class文件（服务器） 4.加载器JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述： 1）Bootstrap ClassLoader：负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类 2）Extension ClassLoader：负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包 3）App ClassLoader：负责记载classpath中指定的jar包及目录中class 4）Custom ClassLoader：属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。 类加载器也是Java类，因为Java类的类加载器本身也是要被类加载器加载的，显然必须有第一个类加载器不是Java类，这个正是BootStrap,使用C/C++代码写的，已经封装到JVM内核中了，而ExtClassLoader和AppClassLoader是Java类。 这边是另一张类加载器的属性结构图： Java虚拟机中的所有类加载器采用具有父子关系的树形结构进行组织，在实例化每个类加载器对象的时候，需要为其指定一个父级类加载器对象或者默认采用系统类加载器为其父级类加载。 5、类加载器的委托机制当Java虚拟机要加载第一个类的时候，到底派出哪个类加载器去加载呢？ (1). 首先当前线程的类加载器去加载线程中的第一个类(当前线程的类加载器：Thread类中有一个get/setContextClassLoader(ClassLoader cl);方法，可以获取/指定本线程中的类加载器) (2). 如果类A中引用了类B,Java虚拟机将使用加载类A的类加载器来加载类B (3). 还可以直接调用ClassLoader.loadClass(String className)方法来指定某个类加载器去加载某个类 每个类加载器加载类时，又先委托给其上级类加载器当所有祖宗类加载器没有加载到类，回到发起者类加载器，还加载不了，则会抛出ClassNotFoundException,不是再去找发起者类加载器的儿子，因为没有getChild()方法。例如：如上图所示： MyClassLoader-&gt;AppClassLoader-&gt;Ext-&gt;ClassLoader-&gt;BootStrap.自定定义的MyClassLoader1首先会先委托给AppClassLoader,AppClassLoader会委托给ExtClassLoader,ExtClassLoader会委托给BootStrap，这时候BootStrap就去加载，如果加载成功，就结束了。如果加载失败，就交给ExtClassLoader去加载，如果ExtClassLoader加载成功了，就结束了，如果加载失败就交给AppClassLoader加载，如果加载成功，就结束了，如果加载失败，就交给自定义的MyClassLoader1类加载器加载，如果加载失败，就报ClassNotFoundException异常，结束。 6、类加载器的可见性机制 根据可见性机制，子类加载器可以看到父类加载器加载的类，而反之则不行。所以下面的例子中，当Abc.class已经被Application类加载器加载过了，然后如果想要使用Extension类加载器加载这个类，将会抛出java.lang.ClassNotFoundException异常。1234567891011121314151617181920212223242526272829package test; import java.util.logging.Level;import java.util.logging.Logger;/** * Java program to demonstrate How ClassLoader works in Java, * in particular about visibility principle of ClassLoader. * * @author Javin Paul */public class ClassLoaderTest &#123; public static void main(String args[]) &#123; try &#123; //printing ClassLoader of this class System.out.println(\"ClassLoaderTest.getClass().getClassLoader() : \" + ClassLoaderTest.class.getClassLoader()); //trying to explicitly load this class again using Extension class loader Class.forName(\"test.ClassLoaderTest\", true , ClassLoaderTest.class.getClassLoader().getParent()); &#125; catch (ClassNotFoundException ex) &#123; Logger.getLogger(ClassLoaderTest.class.getName()).log(Level.SEVERE, null, ex); &#125; &#125;&#125; 输出： 12345678910111213ClassLoaderTest.getClass().getClassLoader() : sun.misc.Launcher$AppClassLoader@601bb116/08/2012 2:43:48 AM test.ClassLoaderTest mainSEVERE: nulljava.lang.ClassNotFoundException: test.ClassLoaderTest at java.net.URLClassLoader$1.run(URLClassLoader.java:202) at java.security.AccessController.doPrivileged(Native Method) at java.net.URLClassLoader.findClass(URLClassLoader.java:190) at sun.misc.Launcher$ExtClassLoader.findClass(Launcher.java:229) at java.lang.ClassLoader.loadClass(ClassLoader.java:306) at java.lang.ClassLoader.loadClass(ClassLoader.java:247) at java.lang.Class.forName0(Native Method) at java.lang.Class.forName(Class.java:247) at test.ClassLoaderTest.main(ClassLoaderTest.java:29) 7、类加载器的单一性机制 根据这个机制，父加载器加载过的类不能被子加载器加载第二次。虽然重写违反委托和单一性机制的类加载器是可能的，但这样做并不可取。你写自己的类加载器的时候应该严格遵守这三条机制。 8、参考文献 http://blog.csdn.net/gjanyanlig/article/details/6818655/ http://blog.csdn.net/jiangwei0910410003/article/details/17733153 http://www.importnew.com/6581.html","tags":[{"name":"类加载器","slug":"类加载器","permalink":"http://harmansecurity.cn/tags/类加载器/"}]},{"title":"深入理解Java泛型","date":"2017-05-24T12:46:21.000Z","path":"2017/05/24/深入理解Java泛型/","text":"一. 泛型概念的提出1234567891011121314public class GenericTest &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add(\"qqyumidi\"); list.add(\"corn\"); list.add(100); for (int i = 0; i &lt; list.size(); i++) &#123; String name = (String) list.get(i); // 1 System.out.println(\"name:\" + name); &#125; &#125;&#125; 定义了一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。 在如上的编码过程中，我们发现主要存在两个问题： 当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。 因此，//1处取出集合元素时需要人为的强制类型转化到具体目标类型，且很容易出现“java.lang.ClassCastException”异常。 那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。 二.什么是泛型 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 123456789101112131415161718192021public class GenericTest &#123; public static void main(String[] args) &#123; /* List list = new ArrayList(); list.add(\"qqyumidi\"); list.add(\"corn\"); list.add(100); */ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add(\"qqyumidi\"); list.add(\"corn\"); //list.add(100); // 1 提示编译错误 for (int i = 0; i &lt; list.size(); i++) &#123; String name = list.get(i); // 2 System.out.println(\"name:\" + name); &#125; &#125;&#125; 采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。 结合上面的泛型定义，我们知道在List中，String是类型实参，也就是说，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）。下面就来看看List接口的的具体定义：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean addAll(Collection&lt;? extends E&gt; c); boolean addAll(int index, Collection&lt;? extends E&gt; c); boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode(); E get(int index); E set(int index, E element); void add(int index, E element); E remove(int index); int indexOf(Object o); int lastIndexOf(Object o); ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); List&lt;E&gt; subList(int fromIndex, int toIndex);&#125; 我们可以看到，在List接口中采用泛型化定义之后，中的E表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。自然的，ArrayList作为List接口的实现类，其定义形式是： 123456789101112131415161718public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; //...省略掉其他具体的定义过程&#125; 由此，我们从源代码角度明白了为什么//1处加入Integer类型对象编译错误，且//2处get()到的类型直接就是String类型了。 三、自定义泛型接口、泛型类和泛型方法 从上面的内容中，大家已经明白了泛型的具体运作过程。也知道了接口、类和方法也都可以使用泛型去定义，以及相应的使用。是的，在具体使用时，可以分为泛型接口、泛型类和泛型方法。 自定义泛型接口、泛型类和泛型方法与上述Java源码中的List、ArrayList类似。如下，我们看一个最简单的泛型类和方法定义：12345678910111213141516171819202122public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;(\"corn\"); System.out.println(\"name:\" + name.getData()); &#125;&#125;class Box&lt;T&gt; &#123; private T data; public Box() &#123; &#125; public Box(T data) &#123; this.data = data; &#125; public T getData() &#123; return data; &#125;&#125; 在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？1234567891011121314public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;(\"corn\"); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); System.out.println(\"name class:\" + name.getClass()); // com.qqyumidi.Box System.out.println(\"age class:\" + age.getClass()); // com.qqyumidi.Box System.out.println(name.getClass() == age.getClass()); // true &#125;&#125; 由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。 究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 四、类型通配符 接着上面的结论，我们知道，Box和Box实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于Box和Box是否可以看成具有父子关系的泛型类型呢？为了弄清这个问题，我们继续看下下面这个例子:1234567891011121314151617181920public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;Number&gt; name = new Box&lt;Number&gt;(99); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); getData(name); //The method getData(Box&lt;Number&gt;) in the type GenericTest is //not applicable for the arguments (Box&lt;Integer&gt;) getData(age); // 1 &#125; public static void getData(Box&lt;Number&gt; data)&#123; System.out.println(\"data :\" + data.getData()); &#125;&#125; 我们发现，在代码//1处出现了错误提示信息：The method getData(Box) in the t ype GenericTest is not applicable for the arguments (Box)。显然，通过提示信息，我们知道Box在逻辑上不能视为Box的父类。那么，原因何在呢？12345678910111213141516171819202122232425262728293031323334public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;Integer&gt; a = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; b = a; // 1 Box&lt;Float&gt; f = new Box&lt;Float&gt;(3.14f); b.setData(f); // 2 &#125; public static void getData(Box&lt;Number&gt; data) &#123; System.out.println(\"data :\" + data.getData()); &#125;&#125;class Box&lt;T&gt; &#123; private T data; public Box() &#123; &#125; public Box(T data) &#123; setData(data); &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 这个例子中，显然//1和//2处肯定会出现错误提示的。在此我们可以使用反证法来进行说明。 假设Box在逻辑上可以视为Box的父类，那么//1和//2处将不会有错误提示了，那么问题就出来了，通过getData()方法取出数据时到底是什么类型呢？Integer? Float? 还是Number？且由于在编程过程中的顺序不可控性，导致在必要的时候必须要进行类型判断，且进行强制类型转换。显然，这与泛型的理念矛盾，因此，在逻辑上Box不能视为Box的父类。 好，那我们回过头来继续看“类型通配符”中的第一个例子，我们知道其具体的错误提示的深层次原因了。那么如何解决呢？总部能再定义一个新的函数吧。这和Java中的多态理念显然是违背的，因此，我们需要一个在逻辑上可以用来表示同时是Box和Box的父类的一个引用类型，由此，类型通配符应运而生。 类型通配符一般是使用 ? 代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且Box&lt;?&gt;在逻辑上是Box、Box…等所有Box&lt;具体类型实参&gt;的父类。由此，我们依然可以定义泛型方法，来完成此类需求。123456789101112131415161718public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;(\"corn\"); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); getData(name); getData(age); getData(number); &#125; public static void getData(Box&lt;?&gt; data) &#123; System.out.println(\"data :\" + data.getData()); &#125;&#125; 有时候，我们还可能听到类型通配符上限和类型通配符下限。具体有是怎么样的呢？ 在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。 1234567891011121314151617181920212223242526public class GenericTest &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;(\"corn\"); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); getData(name); getData(age); getData(number); //getUpperNumberData(name); // 1 getUpperNumberData(age); // 2 getUpperNumberData(number); // 3 &#125; public static void getData(Box&lt;?&gt; data) &#123; System.out.println(\"data :\" + data.getData()); &#125; public static void getUpperNumberData(Box&lt;? extends Number&gt; data)&#123; System.out.println(\"data :\" + data.getData()); &#125;&#125; 此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。 类型通配符上限通过形如Box&lt;? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt;? super Number&gt;形式，其含义与类型通配符上限正好相反。 五、通过反射获得泛型的实际类型参数 java 的泛型，只是编译时作为类型检查，一旦编译完成，泛型就会被擦除，在运行期间是得不到泛型的信息的，包括它的类型参数。有时候我们需要用到泛型的类型参数，反射看起来是取不到的，因反射在运行期间执行，但那时已无泛型的信息。一些构架却办到了，那么它们是怎么实现的呢？请看下面代码：12345678910111213import java.lang.reflect.*; import java.util.*; class Test &#123; public static void main(String args[]) throws Exception &#123; Method applyMethod=Test.class.getMethod(\"applyVector\", Vector.class); Type[] types=applyMethod.getGenericParameterTypes(); System.out.println(types[0].toString()); &#125; public static void applyVector(Vector&lt;Date&gt; v1)&#123; &#125; &#125; 看到了，实际上是通过获得方法，再取得方法的类型参数，这样泛型的实际类型参数就出来了。上面代码输出：java.util.Vector，如果不只一个参数，要具体的类型参数呢？12345678910111213141516171819import java.lang.reflect.*; import java.util.*; class Test &#123; public static void main(String args[]) throws Exception &#123; Method applyMethod=Test.class.getMethod(\"applyVector\", Vector.class); Type[] types=applyMethod.getGenericParameterTypes(); ParameterizedType pType=(ParameterizedType)types[0]; System.out.println(pType.getActualTypeArguments()[0]); System.out.println(pType.getRawType()); &#125; public static void applyVector(Vector&lt;Date&gt; v1)&#123; &#125; &#125; //输出：//class java.util.Date//class java.util.Vector 三、参考文献 http://www.cnblogs.com/lwbqqyumidi/p/3837629.html http://jisonami.iteye.com/blog/2282650 http://blog.csdn.net/hq333/article/details/7455328","tags":[{"name":"泛型","slug":"泛型","permalink":"http://harmansecurity.cn/tags/泛型/"}]},{"title":"深入理解Java注解","date":"2017-05-24T11:34:21.000Z","path":"2017/05/24/深入理解Java注解/","text":"一、元注解 元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：1.@Target,2.@Retention,3.@Documented,4.@Inherited。 这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。 1.@Target @Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标。 作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方） 取值(ElementType)有： 1.CONSTRUCTOR:用于描述构造器 2.FIELD:用于描述域 3.LOCAL_VARIABLE:用于描述局部变量 4.METHOD:用于描述方法 5.PACKAGE:用于描述包 6.PARAMETER:用于描述参数 7.TYPE:用于描述类、接口(包括注解类型) 或enum声明 12345678910111213@Target(ElementType.TYPE)public @interface Table &#123; /** * 数据表名称注解，默认值为类名称 * @return */ public String tableName() default \"className\";&#125;@Target(ElementType.FIELD)public @interface NoDBColumn &#123;&#125; 2.@Retention @Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。 作用：表示需要在什么级别保存该注释信息，用于描述注解的生命周期（即：被描述的注解在什么范围内有效） 取值（RetentionPoicy）有： 1.SOURCE:在源文件中有效（即源文件保留） 2.CLASS:在class文件中有效（即class保留） 3.RUNTIME:在运行时有效（即运行时保留） Retention meta-annotation类型有唯一的value作为成员，它的取值来自java.lang.annotation.RetentionPolicy的枚举类型值。Column注解的的RetentionPolicy的属性值是RUTIME,这样注解处理器可以通过反射，获取到该注解的属性值，从而去做一些运行时的逻辑处理。具体实例如下：12345678@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface Column &#123; public String name() default \"fieldName\"; public String setFuncName() default \"setField\"; public String getFuncName() default \"getField\"; public boolean defaultDBValue() default false;&#125; 3.@Documented @Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。 123456789@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Column &#123; public String name() default \"fieldName\"; public String setFuncName() default \"setField\"; public String getFuncName() default \"getField\"; public boolean defaultDBValue() default false;&#125; 4.@Inherited @Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。 注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。 当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。 123456@Inheritedpublic @interface Greeting &#123; public enum FontColor&#123; BULE,RED,GREEN&#125;; String name(); FontColor fontColor() default FontColor.GREEN;&#125; 二、自定义注解 使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。 定义注解格式：public @interface 注解名 {定义体} 注解参数的可支持数据类型： 所有基本数据类型（int,float,boolean,byte,double,char,long,short) String类型 Class类型 enum类型 Annotation类型 以上所有类型的数组 Annotation类型里面的参数该怎么设定: 第一,只能用public或默认(default)这两个访问权修饰.例如,String value();这里把方法设为defaul默认类型； 第二,参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和 String,Enum,Class,annotations等数据类型,以及这一些类型的数组.例如,String value();这里的参数成员就为String; 第三,如果只有一个参数成员,最好把参数名称设为”value”,后加小括号. 1.自定义注解接口12345678910111213141516171819202122package com.java.annotation;import java.lang.annotation.Documented;import java.lang.annotation.ElementType;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)@Inherited@Documented@Retention(RetentionPolicy.RUNTIME)public @interface Annotation_my &#123; String name() default \"张三\";//defalt 表示默认值 String say() default \"hello world\"; int age() default 21; &#125; 2.定义接口123456789101112131415package com.java.annotation;@Annotation_my //使用我们刚才定义的注解public interface Person &#123; @Annotation_my public void name(); @Annotation_my public void say(); @Annotation_my public void age();&#125; 3.写接口的实现类12345678910111213141516171819202122232425262728package com.java.annotation;@Annotation_my@SuppressWarnings(\"unused\")public class Student implements Person &#123; private String name; @Override @Annotation_my(name=\"流氓公子\") //赋值给name 默认的为张三//在定义注解时没有给定默认值时，在此处必须name赋初值 public void name() &#123; &#125; @Override @Annotation_my(say=\" hello world ！\") public void say() &#123; &#125; @Override @Annotation_my(age=20) public void age() &#123; &#125;&#125; 4.测试类测试注解(反射调用)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.java.annotation;import java.lang.annotation.Annotation;import java.lang.reflect.Field;import java.lang.reflect.Method;public class Text &#123; Annotation[] annotation = null; public static void main(String[] args) throws ClassNotFoundException &#123; new Text().getAnnotation(); &#125; public void getAnnotation() throws ClassNotFoundException&#123; Class&lt;?&gt; stu = Class.forName(\"com.java.annotation.Student\");//静态加载类 boolean isEmpty = stu.isAnnotationPresent(com.java.annotation.Annotation_my.class);//判断stu是不是使用了我们刚才定义的注解接口if(isEmpty)&#123; annotation = stu.getAnnotations();//获取注解接口中的 for(Annotation a:annotation)&#123; Annotation_my my = (Annotation_my)a;//强制转换成Annotation_my类型 System.out.println(stu+\":\\n\"+my.name()+\" say: \"+my.say()+\" my age: \"+my.age()); &#125; &#125; Method[] method = stu.getMethods();// System.out.println(\"Method\"); for(Method m:method)&#123; boolean ismEmpty = m.isAnnotationPresent(com.java.annotation.Annotation_my.class); if(ismEmpty)&#123; Annotation[] aa = m.getAnnotations(); for(Annotation a:aa)&#123; Annotation_my an = (Annotation_my)a; System.out.println(m+\":\\n\"+an.name()+\" say: \"+an.say()+\" my age: \"+an.age()); &#125; &#125; &#125; //get Fields by force System.out.println(\"get Fileds by force !\"); Field[] field = stu.getDeclaredFields(); for(Field f:field)&#123; f.setAccessible(true); System.out.println(f.getName()); &#125; System.out.println(\"get methods in interfaces !\"); Class&lt;?&gt; interfaces[] = stu.getInterfaces(); for(Class&lt;?&gt; c:interfaces)&#123; Method[] imethod = c.getMethods(); for(Method m:imethod)&#123; System.out.println(m.getName()); &#125; &#125; &#125;&#125; 5.注解添加属性值注解类型的属性：MetaAnnotation annotationAttr() default @MetaAnnotation(“xxxx”); 被添加的注解设置属性值：@MyAnnotation(annotationAttr=@MetaAnnotation(“yyy”) )可以认为上面这个@MyAnnotation是MyAnnotaion类的一个实例对象. 同样的道理，可以认为上面这个@MetaAnnotation是MetaAnnotation类的一个实例对象，调用代码如下： MetaAnnotation ma = myAnnotation.annotationAttr(); System.out.println(ma.value());12345678910111213141516171819202122232425262728293031323334353637383940package mypkg; import java.lang.annotation.*; import mypkg.EnumDemo4; @interface MetaAnnotation&#123; String value(); &#125; @Retention(RetentionPolicy.RUNTIME) //此注解运行到内存时才消除 @Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;) //此注解可修饰方法和类 @interface MyAnnotation &#123; String color() default \"blue\" ; String value(); int[] arrayAttr() default &#123;1&#125;; EnumDemo4.TrafficLamp lamp() default EnumDemo4.TrafficLamp.RED; MetaAnnotation annotationAttr() default @MetaAnnotation( \"lhm\"); Class clazz() default String.class; &#125; //AnnotationTest2类的注解及属性 @MyAnnotation(annotationAttr=@MetaAnnotation(\"flx\"),color=\"red\",value=\"abc\",arrayAttr=&#123;1,2,3&#125;) public class AnnotationTest2 &#123; @MyAnnotation(\"xyz\") //main方法的注解的属性value=\"xyz\" public static void main(String[] args) &#123; if(AnnotationTest2.class.isAnnotationPresent(MyAnnotation. class))&#123; MyAnnotation myAnnotation = AnnotationTest2.class .getAnnotation(MyAnnotation. class); System. out.println(myAnnotation.color()); //结果：red System. out.println(myAnnotation.arrayAttr().length); //结果：3 System. out.println(myAnnotation.lamp().nextLamp().name()); //结果：GREEN System. out.println(myAnnotation.annotationAttr().value()); //结果：flx System. out.println(myAnnotation.clazz()); //结果：class java.lang.String &#125; &#125; &#125; 三、参考文献 http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html http://blog.csdn.net/rock_ray/article/details/22334467(全) http://www.cnblogs.com/lzh984294471/p/4959953.html http://www.cnblogs.com/cr330326/p/5695474.html http://blog.csdn.net/zheng963/article/details/49991303","tags":[{"name":"注解","slug":"注解","permalink":"http://harmansecurity.cn/tags/注解/"}]},{"title":"深入理解Java反射","date":"2017-05-24T06:07:21.000Z","path":"2017/05/24/深入理解Java反射/","text":"一、反射的概念 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 二、反射提供的功能 在运行时判断任意一个对象所属的类； 在运行时构造任意一个类的对象； 在运行时判断任意一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法； 生成动态代理。 三、反射机制的相关API1.通过一个对象获得完整的包名和类名12345678package net.xsoftlab.baike;public class TestReflect &#123; public static void main(String[] args) throws Exception &#123; TestReflect testReflect = new TestReflect(); System.out.println(testReflect.getClass().getName()); // 结果 net.xsoftlab.baike.TestReflect &#125;&#125; 2.获取Class类三种方法123456789101112131415package net.xsoftlab.baike;public class TestReflect &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; class1 = null; Class&lt;?&gt; class2 = null; Class&lt;?&gt; class3 = null; // 一般采用这种形式 class1 = Class.forName(\"net.xsoftlab.baike.TestReflect\"); class2 = new TestReflect().getClass();////java语言中任何一个java对象都有getClass 方法 class3 = TestReflect.class;//java中每个类型都有class 属性. System.out.println(\"类名称 \" + class1.getName()); System.out.println(\"类名称 \" + class2.getName()); System.out.println(\"类名称 \" + class3.getName()); &#125;&#125; 3.获取一个对象的父类与实现的接口1234567891011121314151617181920package net.xsoftlab.baike;import java.io.Serializable;public class TestReflect implements Serializable &#123; private static final long serialVersionUID = -2862585049955236662L; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = Class.forName(\"net.xsoftlab.baike.TestReflect\"); // 取得父类 Class&lt;?&gt; parentClass = clazz.getSuperclass(); System.out.println(\"clazz的父类为：\" + parentClass.getName()); // clazz的父类为： java.lang.Object // 获取所有的接口 Class&lt;?&gt; intes[] = clazz.getInterfaces(); System.out.println(\"clazz实现的接口有：\"); for (int i = 0; i &lt; intes.length; i++) &#123; System.out.println((i + 1) + \"：\" + intes[i].getName()); &#125; // clazz实现的接口有： // 1：java.io.Serializable &#125;&#125; 4.通过反射机制实例化一个类的对象(获取类中的构造函数)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package net.xsoftlab.baike;import java.lang.reflect.Constructor;public class TestReflect &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; class1 = null; class1 = Class.forName(\"net.xsoftlab.baike.User\"); // 第一种方法，实例化默认构造方法，调用set赋值 User user = (User) class1.newInstance(); user.setAge(20); user.setName(\"Rollen\"); System.out.println(user); // 结果 User [age=20, name=Rollen] // 第二种方法 取得全部的构造函数 使用构造函数赋值 Constructor&lt;?&gt; cons[] = class1.getConstructors(); // 查看每个构造方法需要的参数 for (int i = 0; i &lt; cons.length; i++) &#123; Class&lt;?&gt; clazzs[] = cons[i].getParameterTypes(); System.out.print(\"cons[\" + i + \"] (\"); for (int j = 0; j &lt; clazzs.length; j++) &#123; if (j == clazzs.length - 1) System.out.print(clazzs[j].getName()); else System.out.print(clazzs[j].getName() + \",\"); &#125; System.out.println(\")\"); &#125; // 结果 // cons[0] (java.lang.String) // cons[1] (int,java.lang.String) // cons[2] () user = (User) cons[0].newInstance(\"Rollen\"); System.out.println(user); // 结果 User [age=0, name=Rollen] user = (User) cons[1].newInstance(20, \"Rollen\"); System.out.println(user); // 结果 User [age=20, name=Rollen] &#125;&#125;class User &#123; private int age; private String name; public User() &#123; super(); &#125; public User(String name) &#123; super(); this.name = name; &#125; public User(int age, String name) &#123; super(); this.age = age; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return \"User [age=\" + age + \", name=\" + name + \"]\"; &#125;&#125; 5.获取类的全部属性123456789101112131415161718192021222324252627282930313233package net.xsoftlab.baike;import java.io.Serializable;import java.lang.reflect.Field;import java.lang.reflect.Modifier;public class TestReflect implements Serializable &#123; private static final long serialVersionUID = -2862585049955236662L; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = Class.forName(\"net.xsoftlab.baike.TestReflect\"); System.out.println(\"===============本类属性===============\"); // 取得本类的全部属性 Field[] field = clazz.getDeclaredFields(); for (int i = 0; i &lt; field.length; i++) &#123; // 权限修饰符 int mo = field[i].getModifiers(); String priv = Modifier.toString(mo); // 属性类型 Class&lt;?&gt; type = field[i].getType(); System.out.println(priv + \" \" + type.getName() + \" \" + field[i].getName() + \";\"); &#125; System.out.println(\"==========实现的接口或者父类的属性==========\"); // 取得实现的接口或者父类的属性 Field[] filed1 = clazz.getFields(); for (int j = 0; j &lt; filed1.length; j++) &#123; // 权限修饰符 int mo = filed1[j].getModifiers(); String priv = Modifier.toString(mo); // 属性类型 Class&lt;?&gt; type = filed1[j].getType(); System.out.println(priv + \" \" + type.getName() + \" \" + filed1[j].getName() + \";\"); &#125; &#125;&#125; 6.获取类的全部方法123456789101112131415161718192021222324252627282930313233343536373839package net.xsoftlab.baike;import java.io.Serializable;import java.lang.reflect.Method;import java.lang.reflect.Modifier;public class TestReflect implements Serializable &#123; private static final long serialVersionUID = -2862585049955236662L; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = Class.forName(\"net.xsoftlab.baike.TestReflect\"); Method method[] = clazz.getMethods(); for (int i = 0; i &lt; method.length; ++i) &#123; Class&lt;?&gt; returnType = method[i].getReturnType(); Class&lt;?&gt; para[] = method[i].getParameterTypes(); int temp = method[i].getModifiers(); System.out.print(Modifier.toString(temp) + \" \"); System.out.print(returnType.getName() + \" \"); System.out.print(method[i].getName() + \" \"); System.out.print(\"(\"); for (int j = 0; j &lt; para.length; ++j) &#123; System.out.print(para[j].getName() + \" \" + \"arg\" + j); if (j &lt; para.length - 1) &#123; System.out.print(\",\"); &#125; &#125; Class&lt;?&gt; exce[] = method[i].getExceptionTypes(); if (exce.length &gt; 0) &#123; System.out.print(\") throws \"); for (int k = 0; k &lt; exce.length; ++k) &#123; System.out.print(exce[k].getName() + \" \"); if (k &lt; exce.length - 1) &#123; System.out.print(\",\"); &#125; &#125; &#125; else &#123; System.out.print(\")\"); &#125; System.out.println(); &#125; &#125;&#125; 7.通过反射机制调用某个类的方法1234567891011121314151617181920212223package net.xsoftlab.baike;import java.lang.reflect.Method;public class TestReflect &#123; public static void main(String[] args) throws Exception &#123; Class&lt;?&gt; clazz = Class.forName(\"net.xsoftlab.baike.TestReflect\"); // 调用TestReflect类中的reflect1方法 Method method = clazz.getMethod(\"reflect1\"); method.invoke(clazz.newInstance()); // Java 反射机制 - 调用某个类的方法1. // 调用TestReflect的reflect2方法 method = clazz.getMethod(\"reflect2\", int.class, String.class); method.invoke(clazz.newInstance(), 20, \"张三\"); // Java 反射机制 - 调用某个类的方法2. // age -&gt; 20. name -&gt; 张三 &#125; public void reflect1() &#123; System.out.println(\"Java 反射机制 - 调用某个类的方法1.\"); &#125; public void reflect2(int age, String name) &#123; System.out.println(\"Java 反射机制 - 调用某个类的方法2.\"); System.out.println(\"age -&gt; \" + age + \". name -&gt; \" + name); &#125;&#125; 8.反射机制的动态代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 获取类加载器的方法TestReflect testReflect = new TestReflect(); System.out.println(\"类加载器 \" + testReflect.getClass().getClassLoader().getClass().getName());package net.xsoftlab.baike;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;//定义项目接口interface Subject &#123; public String say(String name, int age);&#125;// 定义真实项目class RealSubject implements Subject &#123; public String say(String name, int age) &#123; return name + \" \" + age; &#125;&#125;class MyInvocationHandler implements InvocationHandler &#123; private Object obj = null; public Object bind(Object obj) &#123; this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj.getClass().getInterfaces(), this); &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object temp = method.invoke(this.obj, args); return temp; &#125;&#125;/** * 在java中有三种类类加载器。 * * 1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。 * * 2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jrelibext目录中的类 * * 3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。 * * 如果想要完成动态代理，首先需要定义一个InvocationHandler接口的子类，已完成代理的具体操作。 * * @author xsoftlab.net * */public class TestReflect &#123; public static void main(String[] args) throws Exception &#123; MyInvocationHandler demo = new MyInvocationHandler(); Subject sub = (Subject) demo.bind(new RealSubject()); String info = sub.say(\"Rollen\", 20); System.out.println(info); &#125;&#125; 四、反射机制的应用实例1.在泛型为Integer的ArrayList中存放一个String类型的对象1234567891011package net.xsoftlab.baike;import java.lang.reflect.Method;import java.util.ArrayList;public class TestReflect &#123; public static void main(String[] args) throws Exception &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); Method method = list.getClass().getMethod(\"add\", Object.class); method.invoke(list, \"Java反射机制实例。\"); System.out.println(list.get(0)); &#125;&#125; 2.通过反射取得并修改数组的信息12345678910111213package net.xsoftlab.baike;import java.lang.reflect.Array;public class TestReflect &#123; public static void main(String[] args) throws Exception &#123; int[] temp = &#123; 1, 2, 3, 4, 5 &#125;; Class&lt;?&gt; demo = temp.getClass().getComponentType(); System.out.println(\"数组类型： \" + demo.getName()); System.out.println(\"数组长度 \" + Array.getLength(temp)); System.out.println(\"数组的第一个元素: \" + Array.get(temp, 0)); Array.set(temp, 0, 100); System.out.println(\"修改之后数组第一个元素为： \" + Array.get(temp, 0)); &#125;&#125; 3.通过反射机制修改数组的大小1234567891011121314151617181920212223242526272829303132package net.xsoftlab.baike;import java.lang.reflect.Array;public class TestReflect &#123; public static void main(String[] args) throws Exception &#123; int[] temp = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int[] newTemp = (int[]) arrayInc(temp, 15); print(newTemp); String[] atr = &#123; \"a\", \"b\", \"c\" &#125;; String[] str1 = (String[]) arrayInc(atr, 8); print(str1); &#125; // 修改数组大小 public static Object arrayInc(Object obj, int len) &#123; Class&lt;?&gt; arr = obj.getClass().getComponentType(); Object newArr = Array.newInstance(arr, len); int co = Array.getLength(obj); System.arraycopy(obj, 0, newArr, 0, co); return newArr; &#125; // 打印 public static void print(Object obj) &#123; Class&lt;?&gt; c = obj.getClass(); if (!c.isArray()) &#123; return; &#125; System.out.println(\"数组长度为： \" + Array.getLength(obj)); for (int i = 0; i &lt; Array.getLength(obj); i++) &#123; System.out.print(Array.get(obj, i) + \" \"); &#125; System.out.println(); &#125;&#125; 4.将反射机制应用于工厂模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546package net.xsoftlab.baike;interface fruit &#123; public abstract void eat();&#125;class Apple implements fruit &#123; public void eat() &#123; System.out.println(\"Apple\"); &#125;&#125;class Orange implements fruit &#123; public void eat() &#123; System.out.println(\"Orange\"); &#125;&#125;class Factory &#123; public static fruit getInstance(String ClassName) &#123; fruit f = null; try &#123; f = (fruit) Class.forName(ClassName).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return f; &#125;&#125;/** * 对于普通的工厂模式当我们在添加一个子类的时候，就需要对应的修改工厂类。 当我们添加很多的子类的时候，会很麻烦。 * Java 工厂模式可以参考 * http://baike.xsoftlab.net/view/java-factory-pattern * * 现在我们利用反射机制实现工厂模式，可以在不修改工厂类的情况下添加任意多个子类。 * * 但是有一点仍然很麻烦，就是需要知道完整的包名和类名，这里可以使用properties配置文件来完成。 * * java 读取 properties 配置文件 的方法可以参考 * http://baike.xsoftlab.net/view/java-read-the-properties-configuration-file * */public class TestReflect &#123; public static void main(String[] args) throws Exception &#123; fruit f = Factory.getInstance(\"net.xsoftlab.baike.Apple\"); if (f != null) &#123; f.eat(); &#125; &#125;&#125; 五、框架的概念及用反射技术开发框架的原理1.框架：通过反射调用Java类的一种方式。 (框架与房子非常类似，使用的用户写的程序写配置文件，就相当于给房子装修) 如房地产商造房子用户住，门窗和空调等等内部都是由用户自己安装，房子就是框架，用户需使用此框架，安好门窗等放入到房地产商提供的框架中。 框架和工具类的区别：工具类被用户类调用，而框架是调用用户提供的类。 2.框架机器要解决的核心问题 我们在写框架（造房子的过程）的时候，调用的类（安装的门窗等）还未出现，那么，框架无法知道要被调用的类名，所以在程序中无法直接new其某个类的实例对象，而要用反射来做。 3.简单框架程序的步骤：1）右击项目File命名一个配置文件如：config.properties,然后写入配置信息。如键值对：className=java.util.ArrayList，等号右边的配置键，右边是值。 2）代码实现，加载此文件： 将文件读取到读取流中，要写出配置文件的绝对路径。 如：InputStream is=new FileInputStream(“配置文件”); 用Properties类的load()方法将流中的数据存入集合。 关闭流：关闭的是读取流，因为流中的数据已经加载进内存。 3）通过getProperty()方法获取className，即配置的值，也就是某个类名。 4）用反射的方式，创建对象newInstance()。 5）执行程序主体功能 123456FileInputStream fileInputStream = new FileInputStream(\"config.properties\"); Properties properties = new Properties(); properties.load(fileInputStream); fileInputStream.close(); String className =properties.getProperty(\"className\"); ArrayList arrayList = (ArrayList)Class.forName(className).newInstance(); 六、用类加载器的方式管理资源和配置文件1.简述：类加载器是将.class的文件加载进内存，也可将普通文件中的信息加载进内存。spring这些框架加载配置文件 2.文件的加载问题： 1）eclipse会将源程序中的所有.java文件编译成.class文件，然后放到classPath指定的目录中去。并且会将非.java文件原封不动的复制到.class指定的目录中去。在运行的时候，执行的是.class文件。 2）将配置文件放到.class文件目录中一同打包，类加载器就会一同加载。 3.资源文件的加载：是使用类加载器。1）由类加载器ClassLoader来加载进内存，即用getClassLoader()方法获取类加载器，然后用类加载器的getResourceAsStream(String name)方法，将配置文件（资源文件）加载进内存。利用类加载器来加载配置文件，需把配置文件放置的包名一起写上。这种方式只有读取功能。 2）Class类也提供getResourceAsStream方法来加载资源文件，其实它内部就是调用了ClassLoader的方法。这时，配置文件是相对类文件的当前目录的，也就是说用这种方法，配置文件前面可以省略包名。 如：类名.class.getResourceAsStream(“资源文件名”) 4.配置文件的路径问题：1）用绝对路径，通过getRealPath()方法运算出来具体的目录，而不是内部编码出来的。 一般先得到用户自定义的总目录，在加上自己内部的路径。可以通过getRealPath()方法获取文件路径。对配置文件修改是需要要储存到配置文件中，那么就要得到它的绝对路径才行，因此，配置文件要放到程序的内部。 2）name的路径问题： 如果配置文件和classPath目录没关系，就必须写上绝对路径， 如果配置文件和classPath目录有关系，即在classPath目录中或在其子目录中（一般是资源文件夹resource），那么就得写相对路径，因为它自己了解自己属于哪个包，是相对于当前包而言的。 123456789101112/** * 类加载器不但可以加载类，也可以加载配置文件 */ //在classpath指定的目录下逐一的查找要加载的哪个文件 // 注：com前不能加 / \"com/Reflection/config.properties\" 表示的是从根目录开始查找， InputStream fileInputStream = ReflectTest.class.getClassLoader().getResourceAsStream(\"com/Reflection/config.properties\"); Properties properties = new Properties(); properties.load(fileInputStream); fileInputStream.close(); String className =properties.getProperty(\"className\"); ArrayList arrayList = (ArrayList)Class.forName(className).newInstance(); 七、Beanutils工具包操作JavaBean1.Beanutils工具包设置和读取JavaBean的属性 先把工具包的类导入进来，名字commons-beanutils-current.zip 加jar包 工程右键，Build Path选择Configure Buile Path…选项卡为Libraries,Add External JARs…增加外面的jar包，这种方法是加在自己的目录下，没在工程内部，别人不能用 在工程建立一个lib目录，放所有类库，把jar包拷贝到目录下，点击jar包右键-&gt;Build Path-〉Add to Build Path 还要用到日志开发包，apache提供的日志包：commons-logging.zip 2.方法一123456789101112Object value=7;//不为变量没法设 setProperties(pt1, prpertyName, value); //上边set过属性，现在用工具 System.out.println(BeanUtils.getProperty(pt1, \"x\").getClass().getName());//结果的类型 /* * x设置的时候是int类型的 * 但在beanUtils里设置的时候要用字符串，返回的也用String * beanUtils可以自动进行类型转换 */ BeanUtils.setProperty(pt1, \"x\", \"9\"); System.out.println(pt1.getX()); 3.方法二：操作Date对象12345678910/* 操作Date对象 date类型有个setTime的方法 birthday在ReflectPoint设置的 birthday是复合属性，不是基本属性，属性的类型是对象 把Date当成JavaBean来使用，setTime()当成time 这样就等于pt1上边的birthday的time对象赋值了 */ BeanUtils.setProperty(pt1, \"birthday.time()\", \"111\"); System.out.println(BeanUtils.getProperty(pt1, \"birthday.time()\"));//这样的好处是支持属性链 4.方法三：BeanUtils工具不仅操作javaBean还可以操作map，map的key相当于javaBean的属性12Map map=&#123;name:\"zxx\",age:18&#125;; BeanUtils.setProperty(map, \"name\", \"lhm\"); 5.BeanUtils和PropertyUtils的区别,BeanUtils以字符串的形式对java进行操作，PropertyUtils不需要进行转换12345678910//进行类型转换 &lt;span style=\"color:#ff0000;\"&gt;BeanUtils&lt;/span&gt;.setProperty(pt1, \"birthday.time()\", \"111\"); System.out.println(BeanUtils.getProperty(pt1, \"birthday.time()\"));//这样的好处是支持属性链 PropertyUtils.setProperty(pt1, \"x\", 9); System.out.println(PropertyUtils.getProperty(pt1, \"x\").getClass().getName());//结果的类型 PropertyUtils.setProperty(pt1, \"x\", 9); //不进行类型转化时 System.out.println(PropertyUtils.getProperty(pt1, \"x\").getClass()); 八、参考文献 http://blog.csdn.net/liujiahan629629/article/details/18013523 http://www.cnblogs.com/lzq198754/p/5780331.html http://blog.csdn.net/zuoanyinxiang/article/details/50493552 http://blog.csdn.net/lukyaa/article/details/8771604","tags":[{"name":"反射","slug":"反射","permalink":"http://harmansecurity.cn/tags/反射/"}]},{"title":"ARM Linux2.6.37中获取系统调用号","date":"2017-05-19T10:40:11.000Z","path":"2017/05/19/ARM Linux2.6.37中获取系统调用号/","text":"这个过程的实现基本原理是和Linux0.11差别不大的，不过一些汇编指令和系统架构还是有略微却别的，毕竟版本差异较大。Linux0.11主要是在system_call函数中实现获取系统调用号，而ARM Linux2.6.37是在软中断（vector_swi）中获取系统调用号的。下面主要说一下实现的步骤和遇到的问题。 一、实验步骤 1.在linux-2.6.37/arch/arm/kernel文件下找到entry-common.S修改源码，在软中断里面添加实现获取调用号的函数bl get_syscall_num。 2.get_scno.c是用来实现get_syscall_num函数的。该文件主要是放在linux-2.6.37/arch/arm/kernel文件下。 3.修改linux-2.6.37/arch/arm/kernel文件下的Makefile，如图所示。 二、实验小结 如果真正的想修改内核还是需要话功夫去研读源码的，可以先从Linux0.11开始学习。此实验的源码地址是：https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/ARMLinux2.6.37%E8%8E%B7%E5%8F%96%E8%B0%83%E7%94%A8%E5%8F%B7。","tags":[{"name":"系统调用","slug":"系统调用","permalink":"http://harmansecurity.cn/tags/系统调用/"},{"name":"ARM Linux2.6.37","slug":"ARM-Linux2-6-37","permalink":"http://harmansecurity.cn/tags/ARM-Linux2-6-37/"}]},{"title":"ARM Linux2.6.37系统调用原理","date":"2017-05-19T10:40:11.000Z","path":"2017/05/19/ARM Linux2.6.37系统调用原理/","text":"系统调用是操作系统提供给用户（应用程序）的一组接口，每个系统调用都有一个对应的系统调用函数来完成相应的工作。用户通过这个接口向操作系统申请服务， 如访问硬件，管理进程等等。但是因为用户程序运行在用户空间，而系统调用运行在内核空间，因此用户程序不能直接调用系统调用函数，我们经常看到的比如 fork、open、write 等等函数实际上并不是真正的系统调用函数，他们都只是c库，在这些函数里将执行一个软中断 swi 指令，产生一个软中断，使CPU 陷入内核态，接着在内核中进行一系列的判断，判断出是哪个系统调用，再转到真正的系统调用函数，完成相应的功能。 一、系统调用原理1.entry-armv.S里面有switch软件中断的入口 2.调转到entry-common.S中执行vector_swi软中断指令 二、参考资料 http://www.linuxidc.com/Linux/2015-04/116546.htm http://blog.csdn.net/tommy_wxie/article/details/7610118 http://blog.csdn.net/myarrow/article/details/7036266 http://blog.chinaunix.net/uid-28236237-id-3404140.html http://blog.csdn.net/liduxun/article/details/48119849","tags":[{"name":"系统调用","slug":"系统调用","permalink":"http://harmansecurity.cn/tags/系统调用/"},{"name":"ARM Linux2.6.37","slug":"ARM-Linux2-6-37","permalink":"http://harmansecurity.cn/tags/ARM-Linux2-6-37/"}]},{"title":"QEMU安装和调试运行Linux0.11","date":"2017-05-19T06:33:12.000Z","path":"2017/05/19/QEMU安装和调试运行Linux0.11/","text":"首先遇到的一个问题就是虚拟机装了VMaretools还是得用Ctrl+Alt和Ctrl+G切入切出特别麻烦，而且虚拟机和物理机不能进行复制粘贴。重新安装了VMare tools也没有用，至少能让我复制粘贴，其他倒无所谓啊。试了不少办法都没解决问题，最后发现我虚拟机和物理机不是在一个网段，我物理机的ip是：192.168.115.23。我把我虚拟机的ip也设置成一个网段，命令式：sudo ifconfig eth0 192.168.115.150。 一、QEMU安装 1.sudo apt-get install libsdl1.2-dev (安装一些必要的库，并不只是这个，可以根据参考资料的第二个链接) 2.git clone git://git.qemu-project.org/qemu.git 3.进入qemu的目录下面：./configure --enable-debug --enable-tcg-interpreter --enable-sdl --enable-gtk --enable-debug-info --enable-kvm --enable-vnc --enable-curses --prefix=/home/wlwaq/qemu（prefix如果不配置默认是usr/local/bin，配置完的话运行就需要加前缀/home/wlwaq/qemu/bin如第六步） 4.sudo make -j4 5.sudo make install 6./home/wlwaq/qemu/bin/qemu-system-x86_64 -m 16M -L /home/wlwaq/qemu/pc-bios/ -boot a -fda Image -hda hdc-0.11.img -s -S -sdl -monitor stdio(qemu-system-x86_64 –help可以知道“-s -S -sdl -monitor stdio ”代表什么意思） 7.（qemu）c 就可以启动Linux0.11了如果需要用gdb调试，可见第四个参考资料链接。调试工具有：emacs(相当于gdb的图形化界面) Trace32 insight gdb安装emacs的命令：sudo apt-get install emacs。 二、参考资料 http://blog.chinaunix.net/uid-27117600-id-4148061.html http://blog.csdn.net/liwugang43210/article/details/44155143 http://qemu-project.org/Hosts/Linux http://blog.chinaunix.net/uid-26299634-id-4943500.html(主要参考资料)","tags":[{"name":"Linux0.11","slug":"Linux0-11","permalink":"http://harmansecurity.cn/tags/Linux0-11/"},{"name":"QEMU","slug":"QEMU","permalink":"http://harmansecurity.cn/tags/QEMU/"}]},{"title":"Linux0.11系统调用原理","date":"2017-05-19T06:20:11.000Z","path":"2017/05/19/Linux0.11系统调用原理/","text":"一、系统调用原理1.sys_call.s程序的功能描述：在Linux中，用户使用中断调用int 0x80和放在寄存器eax中的功能号来使用内核提供的各种功能服务，这些操作系统提供的功能被称为系统调用功能。通常用户并不是直接使用系统调用中断，而是通过函数库(例如 libc)中提供的接口函数来调用的。例如创建进程的系统调用fork可直接使用函数fork()即可。函数库libc中的fork()函数会实现对中断int 0x80的调用过程并把调用结果返回给用户程序。 由上可知：用户程序-&gt;libc.so-&gt;syscall-&gt;内核提供的各种服务 2.对于所有系统调用的实现函数，内核把他们按照系统调用功能号顺序排列成一张函数指针（地址）表（在include/linux/sys.h文件中）。然后在中断int 0x80的处理过程中根据用户提供的功能号调用对应系统调用函数进行处理。 3.程序在执行的时候首先会检查eax中的功能号是否有效(在给定的范围内)，如果无效中断返回，有效的话通过一个地址跳转表(sys_call_table)调用相应系统调用的函数。 二、参考资料 http://blog.csdn.net/sun20082567/article/details/38729561 http://blog.csdn.net/yhf19881015/article/details/7570354","tags":[{"name":"Linux0.11","slug":"Linux0-11","permalink":"http://harmansecurity.cn/tags/Linux0-11/"},{"name":"系统调用","slug":"系统调用","permalink":"http://harmansecurity.cn/tags/系统调用/"}]},{"title":"用户态和内核态","date":"2017-05-19T04:32:28.000Z","path":"2017/05/19/用户态和内核态/","text":"一、用户态和内核态的区别 当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核 代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行 态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。当正在执行用户程序而突然被中断程序中断时，此时用户程序也可以象征性地称为处于进程 的内核态。因为中断处理程序将使用当前进程的内核栈。这与处于内核态的进程的状态有些类似。 内核态与用户态是操作系统的两种运行级别, 跟intel cpu没有必然的联系, intel cpu提供Ring0-Ring3三种级别的运行模式，Ring0级别高，Ring3最低。Linux使用了Ring3级别运行用户态，Ring0作为 内核态，没有使用Ring1和Ring2。Ring3状态不能访问Ring0的地址空间，包括代码和数据。Linux进程的4GB地址空间，3G-4G部 分大家是共享的，是内核态的地址空间，这里存放在整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程开始是运 行在用户态的，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作，这时，必 须切换到Ring0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后，切换回Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。 至于说保护模式，是说通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程的地址空间中的数据。 二、用户态和内核态的转换用户态切换到内核态的3种方式 a. 系统调用 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使 用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户 特别开放的一个中断来实现，例如Linux的int 80h中断。 b. 异常 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。 c. 外围设备的中断 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会 暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到 内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。 这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。 三、参考资料 http://www.cnblogs.com/viviwind/archive/2012/09/22/2698450.html http://blog.csdn.net/tommy_wxie/article/details/17122923/","tags":[{"name":"用户态","slug":"用户态","permalink":"http://harmansecurity.cn/tags/用户态/"},{"name":"内核态","slug":"内核态","permalink":"http://harmansecurity.cn/tags/内核态/"}]},{"title":"Linux0.11内核添加系统调用","date":"2017-05-19T03:18:32.000Z","path":"2017/05/19/Linux0.11内核添加系统调用/","text":"一、实验步骤1.首先在linux0.11/lib下添加两个文件：writeeax.c,readeax.c 12345678#define __LIBRARY__ !一边是两个下滑线#include&lt;unistd.h&gt;_syscall0(int,writeeax)#define __LIBRARY__ !一边是两个下滑线#include&lt;unistd.h&gt;_syscall0(int,readeax) 2.接下来修改linux0.11/include下的unistd.h，添加两个系统调用号 123456#define __NR_writeeax 72 !NR前面2个_，72是比里面最大的调用号大1个数#define __NR_readeax 73int writeeax(void); !在linux/include/unistd.h文件最下面添加Int readeax(void); 3.接着在linux/include/linux下的sys.h添加 123456extern int sys_writeeax();extern int sys_readeax();!Sys.h下面的sys_call_table[]里面到末尾按顺序添加：sys_writeeax,sys_readeax 4.到linux/kernel下编写一个mysys.c文件实现添加的两个系统调用函数 5.修改linux/kernel/Makefile最后面添加mysys.o 6.编写测试函数test.c 二、实验总结 在内核里面添加系统调用的基本步骤就是上面这几步，如果需要更深的了解还是需要好好找本内核的书《Linux内核完全剖析》来阅读，了解其中的原理。","tags":[{"name":"Linux0.11","slug":"Linux0-11","permalink":"http://harmansecurity.cn/tags/Linux0-11/"},{"name":"系统调用","slug":"系统调用","permalink":"http://harmansecurity.cn/tags/系统调用/"}]},{"title":"Linux0.11获取系统调用号","date":"2017-05-19T03:02:21.000Z","path":"2017/05/19/Linux0.11获取系统调用号/","text":"一、实验步骤1.修改linux0.11/kernel/sys_call.s添加call achieveEax 2.在linux0.11/kernel底下添加achieveEax.c文件 3.修改linux0.11/kernel/Makefile添加achieveEax.o 4.最后的运行结果 二、实验平台 1.实验平台源码：https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/hit-oslab-linux-20110823/oslab 2.获取调用号源码：https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/Linux0.11%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%8F%B7 3.实验平台使用：到“实验楼”搜索“操作系统原理与实践”：https://www.shiyanlou.com/courses/115,将第一个实验做一下就知道该如何使用平台了，这里不再赘述。","tags":[{"name":"Linux0.11","slug":"Linux0-11","permalink":"http://harmansecurity.cn/tags/Linux0-11/"},{"name":"系统调用号","slug":"系统调用号","permalink":"http://harmansecurity.cn/tags/系统调用号/"}]},{"title":"Bochs运行Linux0.11内核","date":"2017-05-19T02:36:21.000Z","path":"2017/05/19/Bochs运行Linux0.11内核/","text":"一、Bochs安装1.手动安装 具体的安装步骤可以参考这篇博客，很详细：http://os.51cto.com/art/201407/446838_all.htm 安装过程中遇到的一个小问题： 解决方法：我的解决方法与博客里面提到的不一样：打开Makefile文件，找到X_LIBS= 添加“-lpthread” 即 X_LIBS=-lpthread.S 2.源安装 安装本身源里面的bochs:sudo apt-get install bochs 二、编译Linux0.11内核 1.进入linux-0.11目录下：make 会提示: make：as86:命令未找到。解决办法是：sudo apt-get install bin86 2.因为我是64位的机器所以会报这样的错误：boot/head.s :Error...........。解决方法：在Makefile的as后面加 --32，注意“–”前面有空格；CFLAGS中加-m32，注意这个无空格。 三、总结 在Linux0.11编译的过程中会遇到很多问题，再加上Ubuntu各版本不同，需要耐心的解决。可编译成功的源码：https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/Linux-0.11-master。与bochs集成的Linux0.11编译开发环境：https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/linux-0.11-devel-040809。","tags":[{"name":"Bochs","slug":"Bochs","permalink":"http://harmansecurity.cn/tags/Bochs/"},{"name":"Linux0.11","slug":"Linux0-11","permalink":"http://harmansecurity.cn/tags/Linux0-11/"}]},{"title":"系统调用hook技术总结","date":"2017-05-19T02:13:21.000Z","path":"2017/05/19/系统调用Hook技术总结/","text":"一、系统调用原理 Linux中实现系统调用时是利用了i386体系结构中的软中断，通过产生0x80中 断，使程序由用户态进入内核态执行系统调用函数。当系统调用发生时，产生0x80中断，CPU被切换到内核态执行中断向量表IDT对应的0x80中断处理函数，即跳转到了system_call()的入口，system_call()函数检查系统调用号，到系统调用表sys_call_table中找到该 系统调用（号）对应的内核函数入口，接着调用这个内核函数，然后返回。 终端输入：sudo cat /proc/kallsyms | grep sys_call_table 终端输出：ffffffff81a001c0 R sys_call_table 由上面可发现其中 R 直接显示了这段内存是只读的性质，这就引出了第二步骤“取消页读写保护”。 整理出来的系统调用hook参考链接：(对hook感兴趣的可以了解下) http://www.tuicool.com/articles/nEnm2u http://blog.csdn.net/maochengtao/article/details/23598433 http://blog.csdn.net/force_eagle/article/details/3938150 http://blog.chinaunix.net/uid-9164976-id-2435342.html http://blog.chinaunix.net/uid-7330656-id-2644670.html http://www.oschina.net/code/snippet_54100_1509 http://blog.sina.com.cn/s/blog_a2acdfc70100zqa7.html http://blog.csdn.net/sun20082567/article/details/38729561 二、相关技术学习(C语言内联汇编的学习) http://www.nagain.com/activity/article/18/ http://blog.csdn.net/liuqiaoyu080512/article/details/8457528 http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html 三、naked函数 naked函数，即所谓的“裸函数”，对于这种函数，编译器不会生成任何函数入口代码和退出代码。这种函数一般应用在与操作系统内核相关的代码中，如中断处理函数、钩子函数等。 naked 特性仅适用于 x86和ARM，并不用于 x64 。 __attribute__((naked)) void test() 参考资料： http://blog.atelier39.org/compiler_disasm/94.html http://www.cnblogs.com/jiu0821/p/4507281.html 五、总结 上面的参考链接对我当时学习系统调用hook技术有很大帮助，这里整理出来分享给大家。 源码地址是：https://github.com/harmansecurity/Linux0.11-ARMLinux2.67_learning/tree/master/hookdemo","tags":[{"name":"系统调用","slug":"系统调用","permalink":"http://harmansecurity.cn/tags/系统调用/"},{"name":"hook","slug":"hook","permalink":"http://harmansecurity.cn/tags/hook/"}]},{"title":"2017年4月小结","date":"2017-05-03T13:19:31.000Z","path":"2017/05/03/2017年4月小结/","text":"最近一直在忙于看书和完成自己制定计划的第二阶段，没时间写博客。刚刚参加完“感动师大”的晚会，内心思绪万千，也对上个月做个小结。三月份的时候，对自己未来想要做什么有了一个大概的认识，制定了接下来要完成的相关计划。 第一阶段(2017.3.19-2017.4.10)：Java基础学习(深入),将某马的Java基础视频教程撸了一遍，记满了一个笔记本。对“反射”、“并发”、“多线程”、“IO流”、“序列化”、“集合泛型”等知识点又有了一个新的认识。期间也阅读了&lt;&lt;重构&gt;&gt;以及电子版的&lt;&lt; head first Java &gt;&gt;。原本想对每节基础课都写个博客，只是时间不允许，所以相关知识点都记在了笔记本上，这里直接放图啦啊，字写的有点潦草(⊙o⊙)。 第二阶段(2017.4.10-2017.5.15)：JavaWeb学习+(SpringMvc+MyBatics)，期间看了《代码整洁之道》、《Java多线程编程核心技术》、《深入理解Java虚拟机》(前两章)、《Java核心技术基础知识》并发这一章节。 前两个阶段的学习算是对以前学习的查漏补缺、巩固、总结，长时间不用很多都遗忘了。接下里的学习计划是阅读相关书籍(每个阶段根据计划内容阅读相关书籍)、学习分布式、框架详细研究、做算法题、项目开发。前两个阶段偏重于理论的学习，接下来的计划安排里应该会侧重于实践，把所看的书里面的知识点尽量能在项目中实现，这样体会更深刻。下面是劳动节前夕买的书，利用放假充裕的时间看书，哈哈。 因为阿里、网易在杭州，目标一直都是阿里，所以很想去杭州看看。趁着第一阶段的计划完成，四月的中旬去了趟杭州，玩了西湖、西溪湿地以及河坊街。原来杭州也很挤啊，人好多，总体感觉还行。不怎么喜欢拍照，室友都说我老，这里我厚着脸皮放一张照片为了证明我并不是那么丑，难道是我眼光的问题？ 来了师大这么久，很少参加活动，今天被邀请参加“感动师大”，真的是思绪万千，对师大人又有了一个新的认识，身边还是有很多优秀的人值得我们去学习，他们的精神我们也应该拥有。”知其然，知其所以然。”是自己的终极目标。","tags":[{"name":"小结","slug":"小结","permalink":"http://harmansecurity.cn/tags/小结/"}]},{"title":"Java基础学习笔记(九)","date":"2017-03-19T14:52:21.000Z","path":"2017/03/19/Java基础学习笔记(九) /","text":"参考链接：http://bbs.itheima.com/thread-270994-1-1.html","tags":[{"name":"Java语言基础","slug":"Java语言基础","permalink":"http://harmansecurity.cn/tags/Java语言基础/"},{"name":"多态","slug":"多态","permalink":"http://harmansecurity.cn/tags/多态/"},{"name":"抽象类","slug":"抽象类","permalink":"http://harmansecurity.cn/tags/抽象类/"},{"name":"接口","slug":"接口","permalink":"http://harmansecurity.cn/tags/接口/"}]},{"title":"Java基础学习笔记(八)","date":"2017-03-19T14:45:21.000Z","path":"2017/03/19/Java基础学习笔记(八)/","text":"08.01_面向对象(代码块的概述和分类)(了解)(面试的时候会问,开发不用或者很少用) A:代码块概述 在Java中，使用{}括起来的代码被称为代码块。 B:代码块分类 根据其位置和声明的不同，可以分为局部代码块，构造代码块，静态代码块，同步代码块(多线程讲解)。 C:常见代码块的应用 a:局部代码块 在方法中出现；限定变量生命周期，及早释放，提高内存利用率 b:构造代码块 (初始化块) 在类中方法外出现；多个构造方法方法中相同的代码存放到一起，每次调用构造都执行，并且在构造方法前执行 c:静态代码块 在类中方法外出现，并加上static修饰；用于给类进行初始化，在加载的时候就执行，并且只执行一次。 一般用于加载驱动 08.02_面向对象(代码块的面试题)(掌握) A:看程序写结果1234567891011121314151617181920212223242526class Student &#123; static &#123; System.out.println(&quot;Student 静态代码块&quot;); &#125; &#123; System.out.println(&quot;Student 构造代码块&quot;); &#125; public Student() &#123; System.out.println(&quot;Student 构造方法&quot;); &#125;&#125; class Demo2_Student &#123; static &#123; System.out.println(&quot;Demo2_Student静态代码块&quot;); &#125; public static void main(String[] args) &#123; System.out.println(&quot;我是main方法&quot;); Student s1 = new Student(); Student s2 = new Student(); &#125;&#125; 08.03_面向对象(继承案例演示)(掌握) A:继承(extends) 让类与类之间产生关系,子父类关系 B:继承案例演示： 动物类,猫类,狗类 定义两个属性(颜色,腿的个数)两个功能(吃饭，睡觉) C:案例演示 使用继承前 D:案例演示 使用继承后 08.04_面向对象(继承的好处和弊端)(掌握) A:继承的好处 a:提高了代码的复用性 b:提高了代码的维护性 c:让类与类之间产生了关系，是多态的前提 B:继承的弊端 类的耦合性增强了。 开发的原则：高内聚，低耦合。 耦合：类与类的关系 内聚：就是自己完成某件事情的能力 08.05_面向对象(Java中类的继承特点)(掌握) A:Java中类的继承特点 a:Java只支持单继承，不支持多继承。(一个儿子只能有一个爹) 有些语言是支持多继承，格式：extends 类1,类2,… b:Java支持多层继承(继承体系) B:案例演示 Java中类的继承特点 如果想用这个体系的所有功能用最底层的类创建对象 如果想看这个体系的共性功能,看最顶层的类 08.06_面向对象(继承的注意事项和什么时候使用继承)(掌握) A:继承的注意事项 a:子类只能继承父类所有非私有的成员(成员方法和成员变量) b:子类不能继承父类的构造方法，但是可以通过super(马上讲)关键字去访问父类构造方法。 c:不要为了部分功能而去继承 项目经理 姓名 工号 工资 奖金 程序员 姓名 工号 工资 B:什么时候使用继承 继承其实体现的是一种关系：”is a”。 Person Student Teacher 水果 苹果 香蕉 橘子 采用假设法。 如果有两个类A,B。只有他们符合A是B的一种，或者B是A的一种，就可以考虑使用继承。 08.07_面向对象(继承中成员变量的关系)(掌握) A:案例演示 a:不同名的变量 b:同名的变量###08.08_面向对象(this和super的区别和应用)(掌握) A:this和super都代表什么 this:代表当前对象的引用,谁来调用我,我就代表谁 super:代表当前对象父类的引用 B:this和super的使用区别 a:调用成员变量 this.成员变量 调用本类的成员变量,也可以调用父类的成员变量 super.成员变量 调用父类的成员变量 b:调用构造方法 this(…) 调用本类的构造方法 super(…) 调用父类的构造方法 c:调用成员方法 this.成员方法 调用本类的成员方法,也可以调用父类的方法 super.成员方法 调用父类的成员方法 08.09_面向对象(继承中构造方法的关系)(掌握) A:案例演示 子类中所有的构造方法默认都会访问父类中空参数的构造方法 B:为什么呢? 因为子类会继承父类中的数据，可能还会使用父类的数据。 所以，子类初始化之前，一定要先完成父类数据的初始化。 其实： 每一个构造方法的第一条语句默认都是：super() Object类最顶层的父类。 08.10_面向对象(继承中构造方法的注意事项)(掌握) A:案例演示 父类没有无参构造方法,子类怎么办? super解决 this解决 B:注意事项 super(…)或者this(….)必须出现在构造方法的第一条语句上 08.11_面向对象(继承中的面试题)(掌握) A:案例演示 看程序写结果1 123456789101112131415161718192021222324class Fu&#123; public int num = 10; public Fu()&#123; System.out.println(&quot;fu&quot;); &#125;&#125;class Zi extends Fu&#123; public int num = 20; public Zi()&#123; System.out.println(&quot;zi&quot;); &#125; public void show()&#123; int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(super.num); &#125;&#125;class Test1_Extends &#123; public static void main(String[] args) &#123; Zi z = new Zi(); z.show(); &#125;&#125; 看程序写结果2 1234567891011121314151617181920212223242526272829class Fu &#123; static &#123; System.out.println(&quot;静态代码块Fu&quot;); &#125; &#123; System.out.println(&quot;构造代码块Fu&quot;); &#125; public Fu() &#123; System.out.println(&quot;构造方法Fu&quot;); &#125;&#125; class Zi extends Fu &#123; static &#123; System.out.println(&quot;静态代码块Zi&quot;); &#125; &#123; System.out.println(&quot;构造代码块Zi&quot;); &#125; public Zi() &#123; System.out.println(&quot;构造方法Zi&quot;); &#125;&#125; Zi z = new Zi(); 请执行结果。 08.12_面向对象(继承中成员方法关系)(掌握) A:案例演示 a:不同名的方法 b:同名的方法 08.13_面向对象(方法重写概述及其应用)(掌握) A:什么是方法重写 重写:子父类出现了一模一样的方法(注意:返回值类型可以是子父类,这个我们学完面向对象讲) B:方法重写的应用： 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法。这样，即沿袭了父类的功能，又定义了子类特有的内容。 C:案例演示 a:定义一个手机类。 08.14_面向对象(方法重写的注意事项)(掌握) A:方法重写注意事项 a:父类中私有方法不能被重写 因为父类私有方法子类根本就无法继承 b:子类重写父类方法时，访问权限不能更低 最好就一致 c:父类静态方法，子类也必须通过静态方法进行重写 其实这个算不上方法重写，但是现象确实如此，至于为什么算不上方法重写，多态中我会讲解(静态只能覆盖静态) 子类重写父类方法的时候，最好声明一模一样。 B:案例演示 方法重写注意事项 08.15_面向对象(方法重写的面试题)(掌握) A:方法重写的面试题 Override和Overload的区别?Overload能改变返回值类型吗? overload可以改变返回值类型,只看参数列表 方法重写：子类中出现了和父类中方法声明一模一样的方法。与返回值类型有关,返回值是一致(或者是子父类)的 方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值类型无关。 子类对象调用方法的时候： 先找子类本身，再找父类。 08.16_面向对象(使用继承前的学生和老师案例)(掌握) A:案例演示 使用继承前的学生和老师案例 属性:姓名,年龄 行为:吃饭 老师有特有的方法:讲课 学生有特有的方法:学习 08.17_面向对象(使用继承后的学生和老师案例)(掌握) A:案例演示 使用继承后的学生和老师案例 08.18_面向对象(猫狗案例分析,实现及测试)(掌握) A:猫狗案例分析 B:案例演示 猫狗案例继承版 属性:毛的颜色,腿的个数 行为:吃饭 猫特有行为:抓老鼠catchMouse 狗特有行为:看家lookHome 08.19_面向对象(final关键字修饰类,方法以及变量的特点)(掌握) A:final概述 B:final修饰特点 修饰类，类不能被继承 修饰变量，变量就变成了常量，只能被赋值一次 修饰方法，方法不能被重写 C:案例演示 final修饰特点 08.20_面向对象(final关键字修饰局部变量)(掌握) A:案例演示 方法内部或者方法声明上都演示一下(了解) 基本类型，是值不能被改变 引用类型，是地址值不能被改变,对象中的属性可以改变 08.21_面向对象(final修饰变量的初始化时机)(掌握) A:final修饰变量的初始化时机 显示初始化 在对象构造完毕前即可 08.22_day08总结 把今天的知识点总结一遍。","tags":[{"name":"Java语言基础","slug":"Java语言基础","permalink":"http://harmansecurity.cn/tags/Java语言基础/"},{"name":"继承","slug":"继承","permalink":"http://harmansecurity.cn/tags/继承/"}]},{"title":"Java基础学习笔记(七)","date":"2017-03-19T14:41:21.000Z","path":"2017/03/19/Java基础学习笔记(七)/","text":"07.01_面向对象(构造方法Constructor概述和格式)(掌握) A:构造方法概述和作用 给对象的数据(属性)进行初始化 B:构造方法格式特点 a:方法名与类名相同(大小也要与类名一致) b:没有返回值类型，连void都没有 c:没有具体的返回值return; 07.02_面向对象(构造方法的重载及注意事项)(掌握) A:案例演示 构造方法的重载 重载:方法名相同,与返回值类型无关(构造方法没有返回值),只看参数列表 B:构造方法注意事项 a:如果我们没有给出构造方法，系统将自动提供一个无参构造方法。 b:如果我们给出了构造方法，系统将不再提供默认的无参构造方法。 注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法 07.03_面向对象(给成员变量赋值的两种方式的区别) A:setXxx()方法 修改属性值 B:构造方法 给对象中属性进行初始化 07.04_面向对象(学生类的代码及测试)(掌握) A:案例演示 学生类： 成员变量： name，age 构造方法： 无参，带两个参 成员方法： getXxx()/setXxx() show()：输出该类的所有成员变量值 B:给成员变量赋值： a:setXxx()方法 b:构造方法 C:输出成员变量值的方式： a:通过getXxx()分别获取然后拼接 b:通过调用show()方法搞定 07.05_面向对象(手机类的代码及测试)(掌握) A:案例演示 模仿学生类，完成手机类代码 07.06_面向对象(创建一个对象的步骤)(掌握) A:画图演示 画图说明一个对象的创建过程做了哪些事情? Student s = new Student(); 1,Student.class加载进内存 2,声明一个Student类型引用s 3,在堆内存创建对象, 4,给对象中属性默认初始化值 5,属性进行显示初始化 6,构造方法进栈,对对象中的属性赋值,构造方法弹栈 7,将对象的地址值赋值给s 07.07_面向对象(长方形案例练习)(掌握) A:案例演示 需求： 定义一个长方形类,定义 求周长和面积的方法， 然后定义一个测试类进行测试。 07.08_面向对象(员工类案例练习)(掌握) A:案例演示 需求：定义一个员工类Employee 自己分析出几个成员，然后给出成员变量 姓名name,工号id,工资salary 构造方法， 空参和有参的 getXxx()setXxx()方法， 以及一个显示所有成员信息的方法。并测试。 work 07.09_面向对象(static关键字及内存图)(了解) A:案例演示 通过一个案例引入static关键字。 人类：Person。每个人都有国籍，中国。 B:画图演示 带有static的内存图 07.10_面向对象(static关键字的特点)(掌握) A:static关键字的特点 a:随着类的加载而加载 b:优先于对象存在 c:被类的所有对象共享 举例：咱们班级的学生应该共用同一个班级编号。 其实这个特点也是在告诉我们什么时候使用静态? 如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。 举例： 饮水机(用静态修饰) 水杯(不能用静态修饰) 共性用静态,特性用非静态 d:可以通过类名调用 其实它本身也可以通过对象名调用。 推荐使用类名调用。 静态修饰的内容一般我们称其为：与类相关的，类成员 B:案例演示 static关键字的特点 07.11_面向对象(static的注意事项)(掌握) A:static的注意事项 a:在静态方法中是没有this关键字的 如何理解呢? 静态是随着类的加载而加载，this是随着对象的创建而存在。 静态比对象先存在。 b:静态方法只能访问静态的成员变量和静态的成员方法 静态方法： 成员变量：只能访问静态变量 成员方法：只能访问静态成员方法 非静态方法： 成员变量：可以是静态的，也可以是非静态的 成员方法：可是是静态的成员方法，也可以是非静态的成员方法。 简单记： 静态只能访问静态。 B:案例演示 static的注意事项 07.12_面向对象(静态变量和成员变量的区别)(掌握) 静态变量也叫类变量 成员变量也叫对象变量 A:所属不同 静态变量属于类，所以也称为为类变量 成员变量属于对象，所以也称为实例变量(对象变量) B:内存中位置不同 静态变量存储于方法区的静态区 成员变量存储于堆内存 C:内存出现时间不同 静态变量随着类的加载而加载，随着类的消失而消失 成员变量随着对象的创建而存在，随着对象的消失而消失 D:调用不同 静态变量可以通过类名调用，也可以通过对象调用 成员变量只能通过对 象名调用 07.13_面向对象(main方法的格式详细解释)(了解) A:格式 public static void main(String[] args) {} B:针对格式的解释 public 被jvm调用，访问权限足够大。 static 被jvm调用，不用创建对象，直接类名访问 void被jvm调用，不需要给jvm返回值 main 一个通用的名称，虽然不是关键字，但是被jvm识别 String[] args 以前用于接收键盘录入的 C:演示案例 通过args接收键盘例如数据 07.14_面向对象(工具类中使用静态)(了解) A:制作一个工具类 ArrayTool 1,获取最大值 2,数组的遍历 3,数组的反转 07.15_面向对象(说明书的制作过程)(了解) A:对工具类加入文档注释 B:通过javadoc命令生成说明书 @author(提取作者内容) @version(提取版本内容) javadoc -d 指定的文件目录 -author -version ArrayTool.java @param 参数名称//形式参数的变量名称@return 函数运行完返回的数据 07.16_面向对象(如何使用JDK提供的帮助文档)(了解) A:找到文档，打开文档 B:点击显示，找到索引，出现输入框 C:你应该知道你找谁?举例：Scanner D:看这个类的结构(需不需要导包) 成员变量 字段 构造方法 构造方法 成员方法 方法 07.17_面向对象(学习Math类的随机数功能)(了解) 打开JDK提供的帮助文档学习 A:Math类概述 类包含用于执行基本数学运算的方法 B:Math类特点 由于Math类在java.lang包下，所以不需要导包。 因为它的成员全部是静态的,所以私有了构造方法 C:获取随机数的方法 public static double random():返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。 D:我要获取一个1-100之间的随机数，肿么办? int number = (int)(Math.random()*100)+1; 07.18_面向对象(猜数字小游戏案例)(了解) A:案例演示 需求：猜数字小游戏(数据在1-100之间) 07.19_day07总结把今天的知识点总结一遍。","tags":[{"name":"Java语言基础","slug":"Java语言基础","permalink":"http://harmansecurity.cn/tags/Java语言基础/"},{"name":"构造方法","slug":"构造方法","permalink":"http://harmansecurity.cn/tags/构造方法/"},{"name":"static","slug":"static","permalink":"http://harmansecurity.cn/tags/static/"}]},{"title":"Java基础学习笔记(六)","date":"2017-03-19T14:40:21.000Z","path":"2017/03/19/Java基础学习笔记(六)/","text":"06.01_面向对象(面向对象思想概述)(了解) A:面向过程思想概述 第一步 第二步 B:面向对象思想概述 找对象(第一步,第二步) C:举例 买煎饼果子 洗衣服 D:面向对象思想特点 a:是一种更符合我们思想习惯的思想 b:可以将复杂的事情简单化 c:将我们从执行者变成了指挥者 角色发生了转换 E:面向对象开发 就是不断的创建对象，使用对象，指挥对象做事情。 F:面向对象设计 其实就是在管理和维护对象之间的关系。 G:面向对象特征 封装(encapsulation) 继承(inheritance) 多态(polymorphism) 06.02_面向对象(类与对象概述)(掌握) A:我们学习编程是为了什么 为了把我们日常生活中实物用学习语言描述出来 B:我们如何描述现实世界事物 属性 就是该事物的描述信息(事物身上的名词) 行为 就是该事物能够做什么(事物身上的动词) C:Java中最基本的单位是类,Java中用class描述事物也是如此 成员变量 就是事物的属性 成员方法 就是事物的行为 D:定义类其实就是定义类的成员(成员变量和成员方法) a:成员变量 和以前定义变量是一样的，只不过位置发生了改变。在类中，方法外。 b:成员方法 和以前定义方法是一样的，只不过把static去掉，后面在详细讲解static的作用。 E:类和对象的概念 a:类：是一组相关的属性和行为的集合 b:对象：是该类事物的具体体现 c:举例： 类 学生 对象 具体的某个学生就是一个对象 06.03_面向对象(学生类的定义)(掌握) A:学生事物 B:学生类 C:案例演示 属性:姓名,年龄,性别 行为:学习,睡觉 06.04_面向对象(手机类的定义)(掌握) 模仿学生类，让学生自己完成 属性:品牌(brand)价格(price) 行为:打电话(call),发信息(sendMessage)玩游戏(playGame) 06.05_面向对象(学生类的使用)(掌握) A:文件名问题 在一个java文件中写两个类：一个基本的类，一个测试类。 建议：文件名称和测试类名称一致。 B:如何使用对象? 创建对象并使用 格式：类名 对象名 = new 类名(); D:如何使用成员变量呢? 对象名.变量名 E:如何使用成员方法呢? 对象名.方法名(…) 06.06_面向对象(手机类的使用)(掌握) A:学生自己完成 模仿学生类，让学生自己完成 06.07_面向对象(一个对象的内存图)(掌握) A:画图演示 一个对象 06.08_面向对象(二个对象的内存图)(了解) A:画图演示 二个不同的对象 06.09_面向对象(三个引用两个对象的内存图)(了解) A:画图演示 三个引用，有两个对象的引用指向同一个地址 06.10_面向对象(成员变量和局部变量的区别)(掌握) A:在类中的位置不同 成员变量：在类中方法外 局部变量：在方法定义中或者方法声明上 B:在内存中的位置不同 成员变量：在堆内存(成员变量属于对象,对象进堆内存) 局部变量：在栈内存(局部变量属于方法,方法进栈内存) C:生命周期不同 成员变量：随着对象的创建而存在，随着对象的消失而消失 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 D:初始化值不同 成员变量：有默认初始化值 局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。 注意事项： 局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。 基本数据类型变量包括哪些:byte,short,int,long,float,double,boolean,char 引用数据类型变量包括哪些:数组,类,接口,枚举 06.11_面向对象(方法的形式参数是类名的时候如何调用)(掌握) A:方法的参数是类名public void print(Student s){}//print(new Student()); 如果你看到了一个方法的形式参数是一个类类型(引用类型)，这里其实需要的是该类的对象。 06.12_面向对象(匿名对象的概述和应用)(掌握) A:什么是匿名对象 没有名字的对象 B:匿名对象应用场景 a:调用方法，仅仅只调用一次的时候。 那么，这种匿名调用有什么好处吗? 节省代码 注意：调用多次的时候，不适合。匿名对象调用完毕就是垃圾。可以被垃圾回收器回收。 b:匿名对象可以作为实际参数传递 C:案例演示 匿名对象应用场景 06.13_面向对象(封装的概述)(掌握) A:封装概述 是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。 B:封装好处 隐藏实现细节，提供公共的访问方式 提高了代码的复用性 提高安全性。 C:封装原则 将不需要对外提供的内容都隐藏起来。 把属性隐藏，提供公共方法对其访问。 06.14_面向对象(private关键字的概述和特点)(掌握) A:人类赋值年龄的问题 B:private关键字特点 a:是一个权限修饰符 b:可以修饰成员变量和成员方法 c:被其修饰的成员只能在本类中被访问 C:案例演示 封装和private的应用： A:把成员变量用private修饰 B:提供对应的getXxx()和setXxx()方法 private仅仅是封装的一种体现形式,不能说封装就是私有 06.15_面向对象(this关键字的概述和应用)(掌握) A:this关键字特点 代表当前对象的引用 B:案例演示 this的应用场景 用来区分成员变量和局部变量重名 06.16_面向对象(手机类代码及其测试)(掌握) A:学生练习 请把手机类写成一个标准类，然后创建对象测试功能。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Demo2_Phone &#123; public static void main(String[] args) &#123; Phone p1 = new Phone(); p1.setBrand(\"三星\"); p1.setPrice(5288); System.out.println(p1.getBrand() + \"...\" + p1.getPrice()); p1.call(); p1.sendMessage(); p1.playGame(); &#125;&#125;/*手机类 属性:品牌brand,价格price 行为:打电话call,发短信sendMessage,玩游戏,playGame*/class Phone &#123; //java bean private String brand; //品牌 private int price; //价格 public void setBrand(String brand) &#123; //设置品牌 this.brand = brand; &#125; public String getBrand() &#123; //获取品牌 return this.brand; //this.可以省略,你不加系统会默认给你加 &#125; public void setPrice(int price) &#123; //设置价格 this.price = price; &#125; public int getPrice() &#123; //获取价格 return price; &#125; public void call() &#123; //打电话 System.out.println(\"打电话\"); &#125; public void sendMessage() &#123; //发短信 System.out.println(\"发短信\"); &#125; public void playGame() &#123; //玩游戏 System.out.println(\"玩游戏\"); &#125;&#125; 06.17_day06总结 把今天的知识点总结一遍。","tags":[{"name":"Java语言基础","slug":"Java语言基础","permalink":"http://harmansecurity.cn/tags/Java语言基础/"},{"name":"面向对象","slug":"面向对象","permalink":"http://harmansecurity.cn/tags/面向对象/"}]},{"title":"Java基础学习笔记(五)","date":"2017-03-19T14:39:22.000Z","path":"2017/03/19/Java基础学习笔记(五)/","text":"参考链接：http://bbs.itheima.com/thread-270882-1-1.html","tags":[{"name":"Java语言基础","slug":"Java语言基础","permalink":"http://harmansecurity.cn/tags/Java语言基础/"},{"name":"数组操作","slug":"数组操作","permalink":"http://harmansecurity.cn/tags/数组操作/"}]},{"title":"Java基础学习笔记(四)","date":"2017-03-19T14:38:21.000Z","path":"2017/03/19/Java基础学习笔记(四)/","text":"04.01_Java语言基础(循环结构概述和for语句的格式及其使用) A:循环结构的分类 for,while,do…while B:循环结构for语句的格式： for(初始化表达式;条件表达式;循环后的操作表达式) { 循环体; } C执行流程： a:执行初始化语句 b:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 c:执行循环体语句; d:执行循环后的操作表达式 e:回到B继续。 D:案例演示 在控制台输出10次”helloworld” 04.02_Java语言基础(循环结构for语句的练习之获取数据) A:案例演示 需求：请在控制台输出数据1-10 需求：请在控制台输出数据10-1 B:注意事项 a:判断条件语句无论简单还是复杂结果是boolean类型。 b:循环体语句如果是一条语句，大括号可以省略；如果是多条语句，大括号不能省略。建议永远不要省略。 c:一般来说：有左大括号就没有分号，有分号就没有左大括号 04.03_Java语言基础(循环结构for语句的练习之求和思想) A:案例演示 需求：求出1-10之间数据之和 B:学生练习 需求：求出1-100之间偶数和 需求：求出1-100之间奇数和 04.04_Java语言基础(循环结构for语句的练习之水仙花) A:案例演示 需求：在控制台输出所有的”水仙花数” 所谓的水仙花数是指一个三位数，其各位数字的立方和等于该数本身。 举例：153就是一个水仙花数。 153 = 111 + 555 + 333 = 1 + 125 + 27 = 153 04.05_Java语言基础(循环结构for语句的练习之统计思想) A:案例演示 需求：统计”水仙花数”共有多少个 04.06_Java语言基础(循环结构while语句的格式和基本使用) A:循环结构while语句的格式： while循环的基本格式：while(判断条件语句) { 循环体语句;} 完整格式： 初始化语句;while(判断条件语句) { 循环体语句; 控制条件语句;} B:执行流程： a:执行初始化语句 b:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 c:执行循环体语句; d:执行控制条件语句 e:回到B继续。 C:案例演示 需求：请在控制台输出数据1-10 04.07_Java语言基础(循环结构while语句的练习) A:求和思想 求1-100之和 B:统计思想 统计”水仙花数”共有多少个 04.08_Java语言基础(循环结构do…while语句的格式和基本使用) A:循环结构do…while语句的格式： do { 循环体语句; }while(判断条件语句); 完整格式； 初始化语句; do { 循环体语句; 控制条件语句; }while(判断条件语句); B:执行流程： a:执行初始化语句 b:执行循环体语句; c:执行控制条件语句 d:执行判断条件语句,看其返回值是true还是false 如果是true，就继续执行 如果是false，就结束循环 e:回到b继续。 C:案例演示 需求：请在控制台输出数据1-10 04.09_Java语言基础(循环结构三种循环语句的区别) A:案例演示 三种循环语句的区别: do…while循环至少执行一次循环体。 而for,while循环必须先判断条件是否成立，然后决定是否执行循环体语句。 B:案例演示 for循环和while循环的区别： A:如果你想在循环结束后，继续使用控制条件的那个变量，用while循环，否则用for循环。不知道用谁就用for循环。因为变量及早的从内存中消失，可以提高内存的使用效率。 04.10_Java语言基础(循环结构注意事项之死循环) A:一定要注意控制条件语句控制的那个变量的问题，不要弄丢了，否则就容易死循环。 B:两种最简单的死循环格式 while(true){…} for(;;){…} 04.11_Java语言基础(循环结构循环嵌套输出4行5列的星星) A:案例演示 需求：请输出一个4行5列的星星(*)图案。 如图： 1234******************** 注意： `System.out.println(&quot;*&quot;);和System.out.print(&quot;*&quot;);`的区别 B:结论： 外循环控制行数，内循环控制列数 04.12_Java语言基础(循环结构循环嵌套输出正三角形) A:案例演示 需求：请输出下列的形状 12345*************** 04.13_Java语言基础(循环结构九九乘法表) A:案例演示 需求：在控制台输出九九乘法表。 B:代码优化 注意： &apos;\\x&apos; x表示任意，\\是转义符号,这种做法叫转移字符。 &apos;\\t&apos; tab键的位置 &apos;\\r&apos; 回车 &apos;\\n&apos; 换行 &apos;\\&quot;&apos; &apos;\\&apos;&apos; 04.14_Java语言基础(控制跳转语句break语句) A:break的使用场景 只能在switch和循环中 04.15_Java语言基础(控制跳转语句continue语句) A:continue的使用场景 只能在循环中 04.16_Java语言基础(控制跳转语句标号) 标号:标记某个循环对其控制 标号组成规则:其实就是合法的标识符 04.17_Java语言基础(控制调整语句练习) A:练习题 for(int x=1; x&lt;=10; x++) { if(x%3==0) { //在此处填写代码 } System.out.println(“Java基础班”); } 我想在控制台输出2次:“Java基础班“ 我想在控制台输出7次:“Java基础班“ 我想在控制台输出13次:“Java基础班“ 04.18_Java语言基础(控制跳转语句return语句) A:return的作用 返回 其实它的作用不是结束循环的，而是结束方法的。 B:案例演示 return和break以及continue的区别? return是结束方法 break是跳出循环 continue是终止本次循环继续下次循环 04.19_Java语言基础(方法概述和格式说明) A:为什么要有方法 提高代码的复用性 B:什么是方法 完成特定功能的代码块。 C:方法的格式 修饰符 返回值类型 方法名(参数类型 参数名1,参数类型 参数名2...) { 方法体语句; return 返回值; } D:方法的格式说明 修饰符：目前就用 public static。后面我们再详细的讲解其他的修饰符。 返回值类型：就是功能结果的数据类型。 方法名：符合命名规则即可。方便我们的调用。 参数： 实际参数：就是实际参与运算的。 形式参数；就是方法定义上的，用于接收实际参数的。 参数类型：就是参数的数据类型 参数名：就是变量名 方法体语句：就是完成功能的代码。 return：结束方法的。 返回值：就是功能的结果，由return带给调用者。 04.20_Java语言基础(方法之求和案例及其调用) A:如何写一个方法 1,明确返回值类型 2,明确参数列表 B:案例演示 需求：求两个数据之和的案例 C:方法调用图解 04.21_Java语言基础(方法的注意事项) A:方法调用(有具体返回值) a:单独调用,一般来说没有意义，所以不推荐。 b:输出调用,但是不够好。因为我们可能需要针对结果进行进一步的操作。 c:赋值调用,推荐方案。 B:案例演示 a:方法不调用不执行 b:方法与方法是平级关系，不能嵌套定义 c:方法定义的时候参数之间用逗号隔开 d:方法调用的时候不用在传递数据类型 e:如果方法有明确的返回值，一定要有return带回一个值 04.22_Java语言基础(方法的练习) A:案例演示 需求：键盘录入两个数据，返回两个数中的较大值 B:案例演示 需求：键盘录入两个数据，比较两个数是否相等 04.23_Java语言基础(方法之输出星形及其调用) A:案例演示 需求：根据键盘录入的行数和列数，在控制台输出星形 B:方法调用：(无返回值,void) 单独调用 输出调用(错误) 赋值调用(错误) 04.24_Java语言基础(方法的练习) A:案例演示 需求：根据键盘录入的数据输出对应的乘法表 04.25_Java语言基础(方法重载概述和基本使用) A:方法重载概述 求和案例 2个整数 3个整数 4个整数 B:方法重载： 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。 参数列表不同： A:参数个数不同 B:参数类型不同 C:参数的顺序不同(算重载,但是在开发中不用) 04.26_Java语言基础(方法重载练习比较数据是否相等) A:案例演示 需求：比较两个数据是否相等。 参数类型分别为两个int类型，两个double类型，并在main方法中进行测试 04.27_day04总结把今天的知识点总结一遍。","tags":[{"name":"Java语言基础","slug":"Java语言基础","permalink":"http://harmansecurity.cn/tags/Java语言基础/"},{"name":"循环结构","slug":"循环结构","permalink":"http://harmansecurity.cn/tags/循环结构/"}]},{"title":"Java基础学习笔记(三)","date":"2017-03-19T14:36:21.000Z","path":"2017/03/19/Java基础学习笔记(三)/","text":"03.01_Java语言基础(逻辑运算符的基本用法)(掌握) A:逻辑运算符有哪些 &amp;,|,^,! &amp;&amp;,|| B:案例演示 逻辑运算符的基本用法 注意事项： a:逻辑运算符一般用于连接boolean类型的表达式或者值。 b:表达式：就是用运算符把常量或者变量连接起来的符合java语法的式子。 算术表达式：a + b 比较表达式：a == b(条件表达式) C:结论： &amp;逻辑与:有false则false。 |逻辑或:有true则true。 ^逻辑异或:相同为false，不同为true。 !逻辑非:非false则true，非true则false。 特点：偶数个不改变本身。 03.02_Java语言基础(逻辑运算符&amp;&amp;和&amp;的区别)(掌握) A:案例演示 &amp;&amp;和&amp;的区别? a:最终结果一样。 b:&amp;&amp;具有短路效果。左边是false，右边不执行。 &amp;是无论左边是false还是true,右边都会执行 B:同理||和|的区别?(学生自学) C:开发中常用谁? &amp;&amp;,||,! 03.03_Java语言基础(位运算符的基本用法1)(了解) A:位运算符有哪些 &amp;,|,^,~ ,&gt;&gt;,&gt;&gt;&gt;,&lt;&lt; B:案例演示 位运算符的基本用法1 &amp;,|,^,~ 的用法 &amp;:有0则0 |:有1则1 ^:相同则0，不同则1 ~:按位取反 03.04_Java语言基础(位异或运算符的特点及面试题)(掌握) A:案例演示 位异或运算符的特点 ^的特点：一个数据对另一个数据位异或两次，该数本身不变。 B:面试题： 请自己实现两个整数变量的交换 注意：以后讲课的过程中，我没有明确指定数据的类型，默认int类型。 03.05_Java语言基础(位运算符的基本用法2及面试题)(了解) A:案例演示 &gt;&gt;,&gt;&gt;&gt;,&lt;&lt;的用法: &lt;&lt;:左移 左边最高位丢弃，右边补齐0 :右移 最高位是0，左边补齐0;最高为是1，左边补齐1 :无符号右移 无论最高位是0还是1，左边补齐0 最有效率的算出2 * 8的结果 03.06_Java语言基础(三元运算符的基本用法)(掌握) A:三元运算符的格式 (关系表达式) ? 表达式1 : 表达式2; B:三元运算符的执行流程 C:案例演示 获取两个数中的最大值 03.07_Java语言基础(三元运算符的练习)(掌握) A:案例演示 比较两个整数是否相同 B:案例演示 获取三个整数中的最大值 03.08_Java语言基础(键盘录入的基本格式讲解)(掌握) A:为什么要使用键盘录入数据 a:为了让程序的数据更符合开发的数据 b:让程序更灵活一下 B:如何实现键盘录入呢? 先照格式来。 a:导包 格式： import java.util.Scanner; 位置： 在class上面。 b:创建键盘录入对象 格式： Scanner sc = new Scanner(System.in); c:通过对象获取数据 格式： int x = sc.nextInt(); C:案例演示 键盘录入1个整数，并输出到控制台。 键盘录入2个整数，并输出到控制台。 03.09_Java语言基础(键盘录入的练习1)(掌握) A:案例演示 键盘录入练习：键盘录入两个数据，并对这两个数据求和，输出其结果 B:案例演示 键盘录入练习：键盘录入两个数据，获取这两个数据中的最大值 03.10_Java语言基础(键盘录入的练习2)(掌握) A:案例演示 键盘录入练习：键盘录入两个数据，比较这两个数据是否相等 B:案例演示 键盘录入练习：键盘录入三个数据，获取这三个数据中的最大值 03.11_Java语言基础(顺序结构语句)(了解) A:什么是流程控制语句 流程控制语句：可以控制程序的执行流程。 B:流程控制语句的分类 顺序结构 选择结构 循环结构 C:执行流程： 从上往下，依次执行。 D:案例演示 输出几句话看效果即可 03.12_Java语言基础(选择结构if语句格式1及其使用)(掌握) A:选择结构的分类 if语句 switch语句 B:if语句有几种格式 格式1 格式2 格式3 C:if语句的格式1 if(比较表达式) { 语句体; } D:执行流程： 先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体； 如果是false，就不执行语句体； 03.13_Java语言基础(选择结构if语句注意事项)(掌握) A:案例演示 a:比较表达式无论简单还是复杂，结果必须是boolean类型 b:if语句控制的语句体如果是一条语句，大括号可以省略； 如果是多条语句，就不能省略。建议永远不要省略。 c:一般来说：有左大括号就没有分号，有分号就没有左大括号 03.14_Java语言基础(选择结构if语句格式2及其使用)(掌握) A:if语句的格式2 if(比较表达式) { 语句体1; }else { 语句体2; } B:执行流程： 首先计算比较表达式的值，看其返回值是true还是false。 如果是true，就执行语句体1； 如果是false，就执行语句体2； C:案例演示 a:获取两个数据中较大的值 b:判断一个数据是奇数还是偶数,并输出是奇数还是偶数 注意事项：else后面是没有比较表达式的，只有if后面有。 03.15_Java语言基础(if语句的格式2和三元的相互转换问题)(掌握) A:案例演示 if语句和三元运算符完成同一个效果 B:案例演示 if语句和三元运算符的区别 三元运算符实现的，都可以采用if语句实现。反之不成立。 什么时候if语句实现不能用三元改进呢? 当if语句控制的操作是一个输出语句的时候就不能。 为什么呢?因为三元运算符是一个运算符，运算符操作完毕就应该有一个结果，而不是一个输出。 03.16_Java语言基础(选择结构if语句格式3及其使用)(掌握) A:if语句的格式3： if(比较表达式1) { 语句体1; }else if(比较表达式2) { 语句体2; }else if(比较表达式3) { 语句体3; } ... else { 语句体n+1; } B:执行流程： 首先计算比较表达式1看其返回值是true还是false， 如果是true，就执行语句体1，if语句结束。 如果是false，接着计算比较表达式2看其返回值是true还是false， 如果是true，就执行语句体2，if语句结束。 如果是false，接着计算比较表达式3看其返回值是true还是false， 如果都是false，就执行语句体n+1。 C:注意事项:最后一个else可以省略,但是建议不要省略,可以对范围外的错误值提示 03.17_Java语言基础(选择结构if语句格式3练习)(掌握) A:练习1 需求：键盘录入一个成绩，判断并输出成绩的等级。 90-100 优 80-89 良 70-79 中 60-69 及 0-59 差 B:练习2 需求： 键盘录入x的值，计算出y的并输出。 x&gt;=3 y = 2 * x + 1; -1&lt;x&lt;3 y = 2 * x; x&lt;=-1 y = 2 * x - 1; 03.18_Java语言基础(选择结构if语句的嵌套使用)(掌握) A:案例演示 需求：获取三个数据中的最大值 if语句的嵌套使用。 03.19_Java语言基础(选择结构switch语句的格式及其解释)(掌握) A:switch语句的格式 switch(表达式) { case 值1： 语句体1; break; case 值2： 语句体2; break; … default： 语句体n+1; break; } B:switch语句的格式解释 C:面试题 byte可以作为switch的表达式吗? long可以作为switch的表达式吗? String可以作为switch的表达式吗? C:执行流程 先计算表达式的值 然后和case后面的匹配，如果有就执行对应的语句，否则执行default控制的语句 03.20_Java语言基础(选择结构switch语句的练习)(掌握) A:整数(给定一个值,输出对应星期几) 03.21_Java语言基础(选择结构switch语句的注意事项)(掌握) A:案例演示 a:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的 b:default可以省略吗? 可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。 特殊情况： case就可以把值固定。 A,B,C,D c:break可以省略吗? 最后一个可以省略,其他最好不要省略 会出现一个现象：case穿透。 最终我们建议不要省略 d:default一定要在最后吗? 不是，可以在任意位置。但是建议在最后。 e:switch语句的结束条件 a:遇到break就结束了 b:执行到switch的右大括号就结束了 03.22_Java语言基础(选择结构switch语句练习)(掌握) A:看程序写结果： int x = 2; int y = 3; switch(x){ default: y++; break; case 3: y++; case 4: y++; } System.out.println(&quot;y=&quot;+y); B:看程序写结果： int x = 2; int y = 3; switch(x){ default: y++; case 3: y++; case 4: y++; } System.out.println(&quot;y=&quot;+y); 03.23_Java语言基础(选择结构if语句和switch语句的区别)(掌握) A:总结switch语句和if语句的各自使用场景 switch建议判断固定值的时候用 if建议判断区间或范围的时候用 B:案例演示 分别用switch语句和if语句实现下列需求： 键盘录入月份，输出对应的季节 03.24_day03总结把今天的知识点总结一遍。","tags":[{"name":"Java语言基础","slug":"Java语言基础","permalink":"http://harmansecurity.cn/tags/Java语言基础/"},{"name":"流程控制语句","slug":"流程控制语句","permalink":"http://harmansecurity.cn/tags/流程控制语句/"},{"name":"逻辑运算符","slug":"逻辑运算符","permalink":"http://harmansecurity.cn/tags/逻辑运算符/"}]},{"title":"Java基础学习笔记(二)","date":"2017-03-19T14:35:21.000Z","path":"2017/03/19/Java基础学习笔记(二)/","text":"02.01_Java语言基础(常量的概述和使用)(掌握) A:什么是常量 在程序执行的过程中其值不可以发生改变 B:Java中常量的分类 字面值常量 自定义常量(面向对象部分讲) C:字面值常量的分类 字符串常量 用双引号括起来的内容 整数常量 所有整数 小数常量 所有小数 字符常量 用单引号括起来的内容,里面只能放单个数字,单个字母或单个符号 布尔常量 较为特殊，只有true和false 空常量 null(数组部分讲解) D:案例演示 用输出语句输出各种常量。null不演示 02.02_Java语言基础(进制概述和二,八,十六进制图解)(了解) A:什么是进制 进制：就是进位制，是人们规定的一种进位方法。 对于任何一种进制–X进制，就表示某一位置上的数运算时是逢X进一位。二进制就是逢二进一，八进制是逢八进一，十进制是逢十进一，十六进制是逢十六进一。 例如一周有七天,七进制,一年有十二个月,十二进制 B:十进制的由来 十进制的由来是因为人类有十个手指 C:二进制的由来 其实二进制来源与中国,请看史料记载 18世纪德国数理哲学大师莱布尼兹从他的传教士朋友鲍威特寄给他的拉丁文译本《易经》中，读到了八卦的组成结构，惊奇地发现其基本素数（0）（1），即《易经》的阴爻yao- -和__阳爻，其进位制就是二进制，并认为这是世界上数学进制中最先进的。20世纪被称作第三次科技革命的重要标志之一的计算机的发明与应用，其运算模式正是二进制。它不但证明了莱布尼兹的原理是正确的，同时也证明了《易经》数理学是很了不起的。 D:八进制的由来 任何数据在计算机中都是以二进制的形式存在的。二进制早期由电信号开关演变而来。一个整数在内存中一样也是二进制的，但是使用一大串的1或者0组成的数值进行使用很麻烦。 所以就想把一大串缩短点，将二进制中的三位用一位表示。这三位可以取到的最大值就是7.超过7就进位了，这就是八进制。 E:十六进制的由来 但是对于过长的二进制变成八进制还是较长，所以出现的用4个二进制位表示一位的情况，四个二进制位最大是15，这就是十六进制。 F:不同进制表现同一个数据的形式特点 进制越大，表现形式越短 02.03_Java语言基础(不同进制数据的表现形式)(掌握) A:二进制的数据表现形式 由0,1组成。以0b(b可以大写也可以小写)开头(JDK1.7版本可以表示二进制了) B:八进制的数据表现形式 由0,1,…7组成。以0开头 C:十进制的数据表现形式 由0,1,…9组成。整数默认是十进制的 D:十六进制的数据表现形式 由0,1,…9,a,b,c,d,e,f(大小写均可)。以0x开头 E:案例演示 输出不同进制表现100的数据。 0b100 0100 100 0x100 02.04_Java语言基础(任意进制到十进制的转换图解)(了解) A:任意进制到十进制的转换原理 系数：就是每一位上的数据。 基数：X进制，基数就是X。 权：在右边，从0开始编号，对应位上的编号即为该位的权。 结果：把系数*基数的权次幂相加即可。 B:画图练习 二进制–十进制 八进制–十进制 十六进制–十进制 02.05_Java语言基础(十进制到任意进制的转换图解)(了解) A:十进制到任意进制的转换原理 除积倒取余 B:画图练习 十进制–二进制 十进制–八进制 十进制–十六进制 02.06_Java语言基础(快速的进制转换法)(了解) A:8421码及特点 8421码是中国大陆的叫法，8421码是BCD代码中最常用的一种。在这种编码方式中每一位二值代码的1都是代表一个固定数值，把每一位的1代表的十进制数加起来，得到的结果就是它所代表的十进制数码。 B:通过8421码的方式进行二进制和十进制的相互转换 C:二进制到八进制的简易方式 D:二进制到十六进制的简易方式 02.07_Java语言基础(原码反码补码)(了解) A:为什么要学习原码反码补码? 后面要学习强制类型转换,如果不知道有原反补会看不懂结果 B:有符号数据表示法的几种方式 原码 就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”表示负，其余位表示数值的大小。 通过一个字节,也就是8个二进制位表示+7和-7 0(符号位) 0000111 1(符号位) 0000111 反码 正数的反码与其原码相同；负数的反码是对其原码逐位取反，但符号位除外。 补码 正数的补码与其原码相同；负数的补码是在其反码的末位加1。 02.08_Java语言基础(原码反码补码的练习)(了解) A:已知原码求补码 0b10110100 B:已知补码求原码 0b11101110 02.09_Java语言基础(变量的概述及格式)(掌握) A:什么是变量 在程序执行的过程中，在某个范围内其值可以发生改变的量 B:变量的定义格式 数据类型 变量名 = 变量值; C:为什么要定义变量 用来不断的存放同一类型的常量，并可以重复使用 02.10_Java语言基础(数据类型的概述和分类)(掌握) A:为什么有数据类型 Java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间 B:Java中数据类型的分类 基本数据类型 引用数据类型 面向对象部分讲解 C:基本数据类型分类(4类8种) 整数型 byte 占一个字节 -128到127 short 占两个字 -2^15~2^15-1 int 占四个字节 -2^31~2^31-1 long 占八个字节 -2^63~2^63-1 浮点型 float 占四个字节 -3.403E38~3.403E38 单精度 double 占八个字节-1.798E308~1.798E308 双精度 字符型 char 占两个字节 0~65535 布尔型 boolean boolean理论上是占八分之一个字节,因为一个开关就可以决定是true和false了,但是java中boolean类型没有明确指定他的大小 02.11_Java语言基础(定义不同数据类型的变量)(掌握) A:案例演示 定义不同基本数据类型的变量，并输出 赋值时候注意float类型,long类型 02.12_Java语言基础(使用变量的注意事项)(掌握) A:案例演示 a:作用域问题 同一个区域不能使用相同的变量名 b:初始化值问题 局部变量在使用之前必须赋值 c:一条语句可以定义几个变量 int a,b,c…; 02.13_Java语言基础(数据类型转换之隐式转换)(掌握) A:案例演示 a:int + int b:byte + int B:Java中的默认转换规则 取值范围小的数据类型与取值范围大的数据类型进行运算,会先将小的数据类型提升为大的,再运算 C:画图解释byte+int类型的问题 02.14_Java语言基础(数据类型转换之强制转换)(掌握) A:强制转换问题 int a = 10; byte b = 20; b = a + b; B:强制转换的格式 b = (byte)(a + b); C:强制转换的注意事项 如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同 02.15_Java语言基础(面试题之变量相加和常量相加的区别)(掌握) A:案例演示 面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。 byte b1 = 3; byte b2 = 4; byte b3 = b1 + b2; 从两方面去回答这个题 b1和b2是两个变量,变量里面存储的值都是变化的,所以在程序运行中JVM是无法判断里面具体的值 byte类型的变量在进行运算的时候,会自动类型提升为int类型 byte b4 = 3 + 4; 3和4都是常量,java有常量优化机制,就是在编译的的时候直接把3和4的结果赋值给b4了 02.16_Java语言基础(long与float的取值范围谁大谁小)(了解) 进行混合运算的时候,byte,short,char不会相互转换,都会自动类型提升为int类型,其他类型进行混合运算的是小的数据类型提升为大的 byte,short,char – int – long – float – double long: 8个字节 float：4个字节 IEEE754 4个字节是32个二进制位 1位是符号位 8位是指数位 00000000 11111111 0到255 1到254 -126到127 23位是尾数位 每个指数位减去127 A:它们底层的存储结构不同。 B:float表示的数据范围比long的范围要大 long：2^63-1 float：3.4*10^38 &gt; 2*10^38 &gt; 2*8^38 = 2*2^3^38 = 2*2^114 &gt; 2^63-1 02.17_Java语言基础(字符和字符串参与运算)(掌握) A:案例演示 System.out.println(‘a’); System.out.println(‘a’+1); 通过看结果知道’a’的值是多少,由此引出ASCII码表 B:ASCII码表的概述 记住三个值： ‘0’ 48 ‘A’ 65 ‘a’ 97 C:案例演示 System.out.println(“hello”+’a’+1); System.out.println(‘a’+1+”hello”); D:+在有字符串参与中被称为字符串连接符 System.out.println(“5+5=”+5+5); System.out.println(5+5+”=5+5”); 02.18_Java语言基础(char数据类型)(掌握) A:char c = 97; 0到65535 B:Java语言中的字符char可以存储一个中文汉字吗?为什么呢? 可以。因为Java语言采用的是Unicode编码。Unicode编码中的每个字符占用两个字节。中文也是占的两个字节 所以，Java中的字符可以存储一个中文汉字 02.19_Java语言基础(算术运算符的基本用法)(掌握) A:什么是运算符 就是对常量和变量进行操作的符号。 B:运算符的分类 算术运算符，赋值运算符，比较(关系或条件)运算符，逻辑运算符，位运算符，三目(元)运算符 C:算数运算符有哪些 +,-,*,/,%,++,– D:注意事项： a:+号在java中有三种作用,代表正号,做加法运算,字符串的连接符 b:整数相除只能得到整数。如果想得到小数，必须把数据变化为浮点数类型 c:/获取的是除法操作的商，%获取的是除法操作的余数 %运算符 当左边的绝对值小于右边绝对值时,结果是左边 当左边的绝对值等于右边或是右边的倍数时,结果是0 当左边的绝对值大于右边绝对值时,结果是余数 %运算符结果的符号只和左边有关系,与右边无关 任何一个正整数%2结果不是0就是1可以用来当作切换条件 02.20_Java语言基础(算术运算符++和–的用法)(掌握) A:++,–运算符的作用 自加（++）自减（–）运算 ++:自加。对原有的数据进行+1 –:自减。对原有的数据进行-1 B:案例演示 a:单独使用： 放在操作数的前面和后面效果一样。(这种用法是我们比较常见的) b:参与运算使用： 放在操作数的前面，先自增或者自减，然后再参与运算。 放在操作数的后面，先参与运算，再自增或者自减。 02.21_Java语言基础(算术运算符++和–的练习)(掌握) A:案例演示 请分别计算出a,b,c的值?1234567891011121314 int a = 10; int b = 10; int c = 10; a = b++; c = --a; b = ++a; a = c--; ``` * B:案例演示 * 请分别计算出x,y的值?```java int x = 4; int y = (x++)+(++x)+(x*10); C:面试题 byte b = 10; b++; b = b + 1; 问哪句会报错,为什么 02.22_Java语言基础(赋值运算符的基本用法)(掌握) A:赋值运算符有哪些 a:基本的赋值运算符：= 把=右边的数据赋值给左边。 b:扩展的赋值运算符：+=,-=,*=,/=,%= += 把左边和右边做加法，然后赋值给左边。 02.23_Java语言基础(赋值运算符的面试题)(掌握) A:案例演示 面试题:看下面的程序是否有问题，如果有问题，请指出并说明理由。 short s=1;s = s+1; short s=1;s+=1; 02.24_Java语言基础(关系运算符的基本用法及其注意事项)(掌握) A:关系运算符有哪些(比较运算符,条件运算符) ==,!=,&gt;,&gt;=,&lt;,&lt;= 注意事项： 无论你的操作是简单还是复杂，结果是boolean类型。 “==”不能写成”=”。 02.25_day02总结 把今天的知识点总结一遍。","tags":[{"name":"Java语言基础","slug":"Java语言基础","permalink":"http://harmansecurity.cn/tags/Java语言基础/"},{"name":"数据类型","slug":"数据类型","permalink":"http://harmansecurity.cn/tags/数据类型/"},{"name":"运算符","slug":"运算符","permalink":"http://harmansecurity.cn/tags/运算符/"}]},{"title":"Java基础学习笔记(一)","date":"2017-03-19T14:34:21.000Z","path":"2017/03/19/Java基础学习笔记(一)/","text":"01.01_计算机基础知识(计算机概述)(了解) A:什么是计算机?计算机在生活中的应用举例 计算机（Computer）全称：电子计算机，俗称电脑。是一种能够按照程序运行，自动、高速处理海量数据的现代化智能电子设备。由硬件和软件所组成，没有安装任何软件的计算机称为裸机。常见的形式有台式计算机、笔记本计算机、大型计算机等。 应用举例 1：科学计算 2、数据处理 3、自动控制 4、计算机辅助设计 5、人工智能 6、多媒体应用 7、计算机网络 … B:什么是硬件?硬件举例 计算机硬件（Computer Hardware）是指计算机系统中由电子，机械和光电元件等组成的各种物理装置的总称。这些物理装置按系统结构的要求构成一个有机整体为计算机软件运行提供物质基础。 冯.诺依曼体系结构 计算机的硬件分成5大组成部件：运算器、控制器、存储器、输入设备和输出设备。 运算器和控制器是计算机的核心，合称中央处理单元（Central Processing Unit，CPU）或处理器。CPU的内部还有一些高速存储单元，被称为寄存器。其中运算器执行所有的算术和逻辑运算；控制器负责把指令逐条从存储器中取出，经译码后向计算机发出各种控制命令；而寄存器为处理单元提供操作所需要的数据。 存储器是计算机的记忆部分，用来存放程序以及程序中涉及的数据。它分为内部存储器和外部存储器。内部存储器用于存放正在执行的程序和使用的数据，其成本高、容量小，但速度快。外部存储器可用于长期保存大量程序和数据，其成本低、容量大，但速度较慢。 输入设备和输出设备统称为外部设备，简称外设或I/O设备，用来实现人机交互和机间通信。微型机中常用的输入设备有键盘、鼠标等，输出设备有显示器、打印机等。 C:什么是软件?软件分类及举例 计算机软件(Computer Software)是使用计算机过程中必不可少的东西，计算机软件可以使计算机按照事先预定好的顺序完成特定的功能 计算机软件按照其功能划分为系统软件与应用软件 系统软件： DOS(Disk Operating System), Windows, Linux, Unix, Mac, Android, iOS 应用软件：office QQ聊天 YY语言 扫雷 01.02_计算机基础知识(软件开发和计算机语言概述)(了解) A:什么是软件 按照特定顺序组织的计算机数据和指令的集合 B:什么是开发 软件的制作过程 C:什么是软件开发 借助开发工具与计算机语言制作软件 D:什么是计算机语言 人与计算机之间进行信息交流沟通的一种特殊语言 E:计算机语言的分类 机器语言： 机器语言是直接用二进制代码指令表达的计算机语言，指令是用0和1组成的一串代码，它们有一定的位数，并分成若干段，各段的编码表示不同的含义。 汇编语言： 汇编语言是使用一些特殊的符号来代替机器语言的二进制码，计算机不能直接识别，需要用一种软件将汇编语言翻译成机器语言。 高级语言： 使用普通英语进行编写源代码，通过编译器将源代码翻译成计算机直接识别的机器语言，之后再由计算机执行。 高级语言包括C,C++,C#,JAVA 01.03_计算机基础知识(人机交互)(了解) A:人机交互的两种方式 a:命令行方式 需要有一个控制台，输入特定的指令，让计算机完成一些操作。较为麻烦，需要记录住一些命令。 b:图形化界面方式 这种方式简单直观，使用者易于接受，容易上手操作。 01.04_计算机基础知识(键盘功能键和快捷键)(掌握) A:键盘功能键 a:Tab b:Shift c:Ctrl d:Alt e:空格 f:Enter g:Window h:上下左右键 i:PrtSc(PrintScreen)屏幕截图 B:键盘快捷键 a:Ctrl+A 全选 b:Ctrl+C 复制 c:Ctrl+V 粘贴 d:Ctrl+X 剪切 e:Ctrl+Z 撤销 f:Ctrl+S 保存 01.05_计算机基础知识(如何打开DOS控制台)(掌握) A:xp下如何打开DOS控制台？ a:开始–程序–附件–命令提示符 b:开始–运行–cmd–回车 c:win+r–cmd–回车 B:win7下如何打开DOS控制台？ a:开始–所有程序–附件–命令提示符 b:开始–搜索程序和文件–cmd–回车 c:win+r–cmd–回车 C:win8下如何打开DOS控制台 a:鼠标左击开始–下箭头–命令提示符 b:鼠标右击开始–搜索–cmd–回车 c:鼠标右击开始–运行–cmd–回车 d:win+r–cmd–回车 01.06_计算机基础知识(常见的DOS命令讲解) A:d: 回车 盘符切换 B:dir(directory):列出当前目录下的文件以及文件夹 C:cd (change directory)改变指定目录(进入指定目录) D:cd.. : 退回到上一级目录 E:cd\\: 退回到根目录 F:cls : (clear screen)清屏 G:exit : 退出dos命令行(分割线上的需要掌握,下的了解) /========================================================= md (make directory) : 创建目录 rd (remove directory): 删除目录 del (delete): 删除文件,删除一堆后缀名一样的文件*.txt notepad 创建文件 删除带内容的文件夹 rd + /s 文件夹名称(询问是否删除) rd + /q + /s 文件夹名称(直接删除) 01.07_Java语言基础(Java语言概述)(了解) A:Java语言发展史 詹姆斯·高斯林（James Gosling）1977年获得了加拿大卡尔加里大学计算机科学学士学位，1983年获得了美国卡内基梅隆大学计算机科学博士学位，毕业后到IBM工作，设计IBM第一代工作站NeWS系统，但不受重视。后来转至Sun公司，1990年，与Patrick，Naughton和Mike Sheridan等人合作“绿色计划”，后来发展一套语言叫做“Oak”，后改名为Java。 SUN(Stanford University Network，斯坦福大学网络公司) B:Java语言版本 JDK 1.1.4 Sparkler 宝石 1997-09-12 JDK 1.1.5 Pumpkin 南瓜 1997-12-13 JDK 1.1.6 Abigail 阿比盖尔–女子名 1998-04-24 JDK 1.1.7 Brutus 布鲁图–古罗马政治家和将军 1998-09-28 JDK 1.1.8 Chelsea 切尔西–城市名 1999-04-08 J2SE 1.2 Playground 运动场 1998-12-04 J2SE 1.2.1 none 无 1999-03-30 J2SE 1.2.2 Cricket 蟋蟀 1999-07-08 J2SE 1.3 Kestrel 美洲红隼(sǔn) 2000-05-08 J2SE 1.3.1 Ladybird 瓢虫 2001-05-17 J2SE 1.4.0 Merlin 灰背隼 2002-02-13 J2SE 1.4.1 grasshopper 蚱蜢 2002-09-16 J2SE 1.4.2 Mantis 螳螂 2003-06-26 JAVASE 5.0 (1.5.0) Tiger 老虎 JAVASE 5.1 (1.5.1) Dragonfly 蜻蜓 JAVASE 6.0 (1.6.0) Mustang 野马 JAVASE 7.0 (1.7.0) Dolphin 海豚 C:Java语言平台 J2SE(Java 2 Platform Standard Edition)标准版 是为开发普通桌面和商务应用程序提供的解决方案,该技术体系是其他两者的基础，可以完成一些桌面应用程序的开发 J2ME(Java 2 Platform Micro Edition)小型版 是为开发电子消费产品和嵌入式设备提供的解决方案 J2EE(Java 2 Platform Enterprise Edition)企业版 是为开发企业环境下的应用程序提供的一套解决方案,该技术体系中包含的技术如 Servlet、Jsp等，主要针对于Web应用程序开发 C:Java语言特点 简单性 解释性 面向对象 高性能 分布式处理 多线程 健壮性 动态 结构中立 安全性 开源 跨平台 01.08_Java语言基础(Java语言跨平台原理)(掌握) A:什么是跨平台性 B:Java语言跨平台原理 只要在需要运行java应用程序的操作系统上，先安装一个Java虚拟机(JVM Java Virtual Machine)即可。由JVM来负责Java程序在该系统中的运行。 C:Java语言跨平台图解 write once ,run anywhere!(一处编译,到处运行) 01.09_Java语言基础(JRE和JDK的概述)(掌握) A:什么是JRE 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 JRE:JVM+类库。 B:什么是JDK JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。 其中的开发工具：编译工具(javac.exe) 打包工具(jar.exe)等 JDK:JRE+JAVA的开发工具。 C:为什么JDK中包含一个JRE 为什么JDK中包含一个JRE呢？ 开发完的程序，需要运行一下看看效果。 D:JDK,JRE,JVM的作用和关系 01.10_Java语言基础(JDK的下载和安装过程图解)(了解) A:JDK的下载 a:官网 http://www.oracle.com b:演示下载流程 B:JDK的安装 a:傻瓜式安装 双击安装程序，然后一路next即可(但是不建议) b:安装的推荐方式 安装路径不要有中文或者特殊符号如空格等。 所有和开发相关的软件最好安装目录统一。 举例：我的JDK安装路径 D:\\develop\\Java\\jdk1.7.0_72 当提示安装JRE时，可以选择不安装。建议还是安装上。 c:演示安装流程 可以先在d盘建立一个文件夹develop 然后演示安装过程 C:验证安装是否成功 a:通过DOS命令，切换到JDK安装的bin目录下。 D:\\develop\\Java\\jdk1.7.0_72\\bin b:然后分别输入javac和java，如果正常显示一些内容，说明安装成功 01.11_Java语言基础(JDK安装路径下的目录解释)(了解) a:bin目录：该目录用于存放一些可执行程序。 如javac.exe（java编译器）、java.exe(java运行工具)，jar.exe(打包工具)和* javadoc.exe(文档生成工具)等。 b:db目录：db目录是一个小型的数据库。 从JDK 6.0开始，Java中引用了一个新的成员JavaDB，这是一个纯Java实现、开源的数据库管理系统。这个数据库不仅轻便，而且支持JDBC 4.0所有的规范，在学习JDBC 时，不再需要额外地安装一个数据库软件，选择直接使用JavaDB即可。 c:jre目录：”jre”是 Java Runtime Environment 的缩写，意为Java程序运行时环境。此目录是Java运行时环境的根目录，它包括Java虚拟机，运行时的类包，Java应用启动器以及一个bin目录，但不包含开发环境中的开发工具。 d:include目录：由于JDK是通过C和C++实现的，因此在启动时需要引入一些C语言的头文件，该目录就是用于存放这些头文件的。 e:lib目录：lib是library的缩写，意为 Java 类库或库文件，是开发工具使用的归档包文件。 f:src.zip文件：src.zip为src文件夹的压缩文件，src中放置的是JDK核心类的源代码，通过该文件可以查看Java基础类的源代码。 01.12_Java语言基础(Java开发工具介绍)(了解) A:notepad(微软操作系统自带) B:Editplus/Notepad++ C:Eclipse D:MyEclipse 给大家简单的介绍一下这些工具，然后说说我们使用这些工具的顺序。 基础班：先notepad，然后Editplus，再Eclipse。 就业班：MyEclipse和Eclipse都用。 01.13_Java语言基础(HelloWorld案例的编写和运行)(掌握) A:定义类 B:写main方法 C:写输出语句 D:Java程序开发运行与工作原理 E:编译和运行程序12345class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"HelloWorld\"); &#125;&#125; 01.14_Java语言基础(HelloWorld案例常见问题)(掌握) A:找不到文件(都演示一下，让学生看看出现的都是什么问题) a:文件扩展名隐藏导致编译失败 b:文件名写错了 B:单词拼写问题(都演示一下，让学生看看出现的都是什么问题) a:class写成Class b:String写成string c:System写成system d:main写成mian C:括号匹配问题(都演示一下，让学生看看出现的都是什么问题) a:把类体的那对大括号弄掉一个 b:把方法体的那对大括号弄掉一个 c:把输出语句的那对小括号弄掉一个 D:中英文问题(都演示一下，让学生看看出现的都是什么问题) a:提示信息：错误: 非法字符: \\????的格式 注意：java编程中需要的基本上都是英文字符 01.15_Java语言基础(Java语言的书写格式(约定俗成)) (掌握) 1,大括号要对齐,并且成对写 2,左大括号前面有空格 3,遇到左大括号要缩进,Tab 4,方法和程序块之间加空行让程序看起来清晰 5,并排语句之间加空格,例如for语句 6,运算符两侧加空格 01.16_Java语言基础(path环境变量的作用及配置方式1)(掌握) A:在JDK的bin目录下开发程序容易产生的问题 a:如果文件过多，不方便管理 b:删除自己写过的不需要的文件，可能不小心把JDK自带的工具给删除了 B:如何解决问题呢 notepad这样的命令为什么在任何路径下都能够执行,配置path环境变量 C:配置方式 a:xp系统 右键点击桌面计算机→选择属性→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。 b:win7/win8系统 右键点击桌面计算机→选择属性→选择高级系统设置→选择高级选项卡→点击环境变量→下方系统变量中查找path→双击path→将jdk安装目录下的bin目录添加到最左边并添加分号。 path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件 01.17_Java语言基础(Path环境变量的配置方式2)(掌握) A:先配置JAVA_HOME B:再修改path C:最后说一下path是有先后顺序关系的 01.18_Java语言基础(classpath环境变量的作用及其配置)(了解) A:为什么要配置classpath B:classpath配置的原理 C:如何配置classpath 如果将Java执行环境比喻为操作系统，如果设置Path变量是为了让操作系统找到指定的工具程序(以Windows来说就是找到.exe文件)，则设置Classpath的目的就是让Java执行环境找到指定的Java程序(也就是.class文件)。 path和classpath的区别 path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件 classpath配置的java的类文件,就是.class文件 01.19_Java语言基础(Editplus开发程序并编译运行)(了解) A:配置快捷键编译运行 B:去除备份文件 01.20_Java语言基础(注释概述及其分类)(掌握) A:什么是注释 B:注释的分类及讲解 文档注释目前不讲，说后面讲解 注释的作用 A:解释说明程序 B:帮助我们调试错误 01.21_Java语言基础(关键字的概述和使用)(掌握) A:什么是关键字 被Java语言赋予特定含义的单词 B:关键字的特点 组成关键字的字母全部小写 C:常见关键字 public static void class等 D:关键字的注意事项 goto和const作为保留字存在,目前并不使用,类似Editplus这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 01.22_Java语言基础(标识符的概述和组成规则)(掌握) A:什么是标识符 就是给类,接口,方法,变量等起名字时使用的字符序列 B:标识符的组成规则 英文大小写字母 数字字符 $和__ C:标识符注意事项 1,不能使用关键字 2,不能数字开头 01.23_Java语言基础(标识符中常见的命名规则)(了解) 见名知意 A:包 最好是域名倒过来,要求所有的字母小写 B:类或者接口 如果是一个单词首字母大写 如果是多个单词每个单词首字母大写(驼峰标识) C:方法或者变量 如果是一个单词全部小写 如果是多个单词,从第二个单词首字母大写 D:常量 如果是一个单词,所有字母大写 如果是多个单词,所有的单词大写,用下划线区分每个单词 01.24_day01总结 把今天的知识点总结一遍。","tags":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"http://harmansecurity.cn/tags/计算机基础知识/"},{"name":"Java语言基础","slug":"Java语言基础","permalink":"http://harmansecurity.cn/tags/Java语言基础/"}]},{"title":"2017年3月小记","date":"2017-03-19T14:07:22.000Z","path":"2017/03/19/2017年3月小记/","text":"最近一直在忙着挑战杯以及看论文写论文，没有太多的时间来写博客。回想之前做的事，虽然都是有收获的但是有些还是没继续做到最后。自从寒假前想清楚以后要做的是从事技术，一直在盘算着未来到底做哪一块，什么样的岗位，想更适合做哪些领域的工作，早作决定然后早点准备，打牢基础。 对待买书这件事上一直不是很吝啬的，从去年到现在购买书所花费的费用快接近千元了，很多书都过了一遍，有些经典的书一时半会儿还吃不完，等以后有时间慢慢消化。本科有一些Java前端和后台开发的基础，对我来说选择Java更容易上手。但是之前所学深感都是皮毛，为了开发一个东西而开发，理解的深度不够。最近新购了一批Java相关的书籍，利用接下来的时间过一遍，从最基础的开始，温故而知新。也在看某马的Java基础教程，发现有些基础知识已经遗忘，这套视频的好处，每节课都会有一个markdown写的笔记，我打算看完一节视频，更新一下笔记，虽然都是基础，但是牢牢掌握还是很有必要的。先从基础开始，然后多动手实践。上学期看的相关安全类的书和做的一些简单小实验对自己还是有很大启发的，以前的开发中从未考虑过安全，很多细节在之后的开发中都需要注意。下面的就是书单，在这边发上来，也督促自己先把这些书看完。","tags":[{"name":"小记","slug":"小记","permalink":"http://harmansecurity.cn/tags/小记/"}]},{"title":"ELK搭建社工库","date":"2017-02-25T07:07:21.000Z","path":"2017/02/25/ELK搭建社工库/","text":"一、简介1.核心组成ELK由Elasticsearch、Logstash和Kibana三部分组件组成； Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。 Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。 Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。 2.三大组件 Logstash: logstash server端用来搜集数据； Elasticsearch: 存储各类数据； Kibana: web化接口用作查寻和可视化数据； 3.工作流程 以日志分析为例：Logstash收集AppServer产生的Log，并存放到ElasticSearch集群中，而Kibana则从ES集群中查询数据生成图表，再返回给Browser。 二、ELK搭建1.系统环境 win7(X86) ElasticSearch: 2.1.1 Logstash: 1.5.1 Kibana: 5.2.1 JDK1.8(安装java至少7以上的版本,并且配置JAVA_HOME环境变量) 2.安装Elasticsearch 下载地址：https://www.elastic.co/downloads/ 解压即可，配置文件elasticsearch.yml,默认也行。 12345#按照自己的需求修改也行，我选择的是默认，没有修改。cluster.name: esdemo #(集群的描述信息)node.name: 63 #(节点名称)network.host: 192.168.1.5 #(绑定的IP地址)http.port: 9200 #(端口号 默认9200) 执行elasticsearch.bat即可启动 访问http://localhost:9200可查看是否正常运行，运行成功效果如下： 3.安装Kibana 下载地址：https://www.elastic.co/downloads/ 解压即可，执行kibana.bat启动即可启动 访问http://localhost:5601可查看是否正常运行，运行成功效果如下： 4.安装logstash 下载地址：https://www.elastic.co/downloads/ 解压即可。 三、社工库搭建 因为是.sql文件，所以先导入mysql,然后再导出csv文件。也就是说不同的网站数据库最终全部是csv文件，并且是格式相同的csv。有字段不存在的则使用空字符替代。这样的话,可以在不更改logstash配置文件的情况下直接导入ES，也方便进行迁移。 数据库中的文件导出csv文件格式。 1select * from md5_sgk into outfile 'f://scolib.csv' fields terminated by ','optionally enclosed by ''lines terminated by '/n'; 新建logstash.config并进行配置。 1234567891011121314151617181920212223242526272829303132333435363738394041input&#123; file&#123; #需要被导入的数据库文件路径 path =&gt;&quot;f:/soclib.csv&quot; start_position =&gt;beginning &#125;&#125;filter&#123; grok&#123; #表达式路径，这里自定义了一行内容S \\s用来匹配换行符 patterns_dir =&gt;&quot;f:/test.txt&quot; #写入ES的字段名 match =&gt;&#123;&quot;message&quot;=&gt;&quot;%&#123;DATA:id&#125;,%&#123;DATA:username&#125;,%&#123;DATA:password&#125;,%&#123;DATA:email&#125;,%&#123;DATA:salt&#125;,%&#123;DATA:order&#125;&quot;&#125; &#125; grok&#123; #提取文件名 match =&gt;[&quot;path&quot;,&quot;f:/%&#123;GREEDYDATA:from&#125;\\.csv&quot;] &#125; mutate&#123; #删除一些ES自带的字段很占用空间 remove_field =&gt;[&quot;host&quot;,&quot;path&quot;,&quot;message&quot;] &#125;&#125;output&#123; elasticsearch&#123; #ES地址 hosts =&gt; &quot;localhost:9200&quot; #索引名称 index =&gt;&quot;sdb&quot; document_type =&gt;&quot;sdb&quot; #如果启用了shield则需要配置用户名和密码 #user =&gt;&quot;填写密码&quot; #password =&gt;&quot;填写用户名&quot; &#125; stdout&#123; codec=&gt;rubydebug &#125;&#125; 在logstash bin目录下面执行logstash.bat -f logstash.config 四、参考文献 http://www.tuicool.com/articles/uuaqeyf 百度搜索ELK，对原理有大概的了解。 五、总结 上一篇文章没有做任何的处理，直接通过sql语句进行查询，数据库中大概有九千万的数据，查询一次需要四分钟左右，速度还是很慢的，之前在论坛里听有人说用ELK搭建，所以这次就试了下。ELK处理数据应该是特别快的，不过真的很迟内存，按照我上面的步骤没有错，不过执行到最后一步，电脑内存耗尽直接有点死了，由于装的是32位的系统，占用内存本来就比较小，所以我就终止了程序。如果有人感兴趣的话电脑配置也比较高可以按照我的步骤执行下，一起交流。","tags":[{"name":"社工库","slug":"社工库","permalink":"http://harmansecurity.cn/tags/社工库/"},{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://harmansecurity.cn/tags/Elasticsearch/"},{"name":"Logstash","slug":"Logstash","permalink":"http://harmansecurity.cn/tags/Logstash/"},{"name":"Kinaba","slug":"Kinaba","permalink":"http://harmansecurity.cn/tags/Kinaba/"}]},{"title":"搭建社工库","date":"2017-02-20T12:53:12.000Z","path":"2017/02/20/搭建社工库/","text":"社工库顾名思义就是社工数据库查询工具。网站自称可帮助您判断您的密码或个人信息是否已经被公开或泄漏，即如果您输入自己密码可以在社工库上查到，就意味着你的账号已被盗（过）。这两天正好得到了一些数据，简单做一个社工库。 简单介绍下MySql的使用 由于我之前的数据库中已经有数据为了方便演示，我把数据删掉，正好也回顾一下MySql的使用。我使用的是Navicat这个支持MySql的可视化工具，由于数据比较多，我直接从CMD终端进行操作删除。 很多时候我们电脑的MySQL服务没有开启，net start mysql开启MySQL服务。 进入MySQL数据库,在终端中输入mysql -u root -p,根据提示输入密码。 查看所有的数据库，show databases;我们会看到之前新建的数据库。 使用之前的数据库use &lt;库名&gt;;,然后查看当前数据库下面的表,show tables;。 删除表里面的所有数据delete from &lt;表名&gt;;。 处理数据，实现保存和查询的功能 我得到的数据是txt格式，每一行是用户名，密码，邮箱，由于这一行数据可能是以多个空格或者分号或者只有用户名没有密码，所以还需要对每一行的数据进行适当的处理然后保存到数据库中。我读取了一下txt文件，txt中有二百多万条数据，大概花了40秒左右，但是将数据存储到数据库中花的时间太长了，由于时间的原因，只向数据库中插入了十万多条数据。 对txt文件数据进行处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public static void readFileByLines(String fileName)&#123; File file = new File(fileName); //用户名 String userName=null; //用户密码 String userPwd=null; //用户邮箱 String userMail=null; BufferedReader reader = null; try &#123; System.out.println(\"以行为单位读取文件内容，一次读一整行：\"); reader=new BufferedReader(new FileReader(file)); String tempString=null; int line=1; //开始时间 long startTime=System.currentTimeMillis(); // 一次读入一行，直到读入null为文件结束 while((tempString=reader.readLine())!=null)&#123; // 显示每行的数据 System.out.println(\"line \" + line + \": \" + tempString); //因为txt文件里每行数据可能是以多个空格或者;来分隔 String[] tempArray = tempString.split(\"\\\\s+|;\"); //有的数据里面只有用户名或者密码，缺少邮箱，不这样处理的话溢出 //如果字符串只有用户名和密码，那么字符数组的长度为2 //那么插入数据到数据库的时候，如果直接赋值tempArray[2]肯定会报错 if(tempArray.length==2)&#123; tempArray=(String[]) Arrays.copyOf(tempArray, tempArray.length+1); tempArray[tempArray.length-1]=\" \"; &#125; //System.out.println(tempArray[0]); //System.out.println(tempArray[1]); // System.out.println(tempArray[2]); //把拆分的数据分别赋值然后保存到数据库中 userName=tempArray[0]; userPwd=tempArray[1]; userMail=tempArray[2]; //把数据插入到数据库中 operateData.insertData(userName, userPwd, userMail); line++; &#125; //结束时间 long endTime=System.currentTimeMillis(); //程序运行的时间 double seconds=(endTime-startTime)/1000.0; System.out.println(\"程序运行的时间是：\"+seconds+\"s\"); //总共数据量 System.out.println(\"总共数据量是：\"+(line-1)); reader.close(); &#125; catch (IOException e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally&#123; if(reader!=null)&#123; try &#123; reader.close(); &#125; catch (IOException e1) &#123; // TODO: handle exception &#125; &#125; &#125;&#125; 将处理完的数据保存到数据库中(插入操作) 123456789101112131415161718/** * 将文本中的数据插入到数据库中 * @param userName * @param userPwd * @param userMail */static void insertData(String userName,String userPwd,String userMail)&#123; ConnDB cdb = new ConnDB(); String sql = \"insert into userInfo (userName,userPwd,userMail) values ('\"+userName+\"','\"+userPwd+\"','\"+userMail+\"')\"; //执行增删改 cdb.getModify(sql); //不知道是否插入成功，可通过下面的代码来判断 /* int i=cdb.getModify(sql); if(i==1) System.out.println(\"添加成功\"); else System.out.println(\"添加失败\");*/&#125; 对数据库中的数据进行查询(查询操作) 123456789101112131415161718192021222324252627282930/** * 根据用户名或者邮箱查询数据 * @param data */static void queryData(String data)&#123; String userName=null; ConnDB cdb = new ConnDB(); ResultSet rs = cdb.getSelect(\"select * from userinfo where userName='\"+data+\"' or userMail='\"+data+\"';\"); try &#123; while(rs.next())&#123; userName=rs.getString(\"userName\"); System.out.print(rs.getString(\"userName\")+\"\\t\"); System.out.print(rs.getString(\"userPwd\")+\"\\t\"); System.out.println(rs.getString(\"userMail\")); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;finally&#123; try &#123; if(userName==null)&#123; System.out.println(\"对不起，您查找的用户不存在！\"); &#125; cdb.closeResultSet(rs); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; Eclipse控制台运行效果 该项目地址GitHUB：https://github.com/harmansecurity/SocilaLibrary 还是个小白，要学的东西还有很多，待会儿我把代码上传到我的GitHub中，等明天电脑到之后准备搭一个渗透环境，多实践。提到电脑还是很感动的，因为实验室到现在还没有配台式机(这里我就不吐槽这件事了)，跟朋友说了下目前的情况，立马把她的旧电脑寄给我做实验了，满满的感动，感激。时间的原因，我先暂时不做一个网页了，做一个搜索的网页无非就是一个搜索栏然后连接数据库查询数据，实现起来不是很难。如果对数据感兴趣的朋友可以私聊我或者留言，到时候转发给你，如果做违法犯罪行为，本人概不负责任。","tags":[{"name":"社工库","slug":"社工库","permalink":"http://harmansecurity.cn/tags/社工库/"},{"name":"Java","slug":"Java","permalink":"http://harmansecurity.cn/tags/Java/"},{"name":"MySql","slug":"MySql","permalink":"http://harmansecurity.cn/tags/MySql/"}]},{"title":"Http抓包与调试(Wireshark)","date":"2017-02-14T06:23:27.000Z","path":"2017/02/14/Http抓包与调试(Wireshark)/","text":"wireshark是非常流行的网络封包分析软件，功能十分强大。可以截取各种网络封包，显示网络封包的详细信息。使用wireshark的人必须了解网络协议，否则就看不懂wireshark了。为了安全考虑，wireshark只能查看封包，而不能修改封包的内容，或者发送封包。wireshark能获取HTTP，也能获取HTTPS，但是不能解密HTTPS，所以wireshark看不懂HTTPS中的内容，总结，如果是处理HTTP,HTTPS 还是用Fiddler, 其他协议比如TCP,UDP就用wireshark. 1.wireshark是搞IT经常用到的一个工具，主要整理了一下一些资料可供参考： http://blog.csdn.net/lina_acm/article/details/53404429 http://www.cnblogs.com/dragonir/p/6219541.html http://www.9upk.com/article/2537.html http://www.cnblogs.com/TankXiao/archive/2012/10/10/2711777.html http://blog.jobbole.com/70907/(一站式学习系列文章可以参考) 2.比较详细的wireshark过滤规则 http://blog.csdn.net/hzhsan/article/details/43453251 3.比较详细的wireshark使用教程文档 链接：http://pan.baidu.com/s/1nvCv52p 密码：s1vd 4.以上的资料就是介绍了wireshark的基本用法，下面的视频教程讲解wireshark更加的详细，有时间的话可以学习下： http://edu.51cto.com/lesson/id-62644.html","tags":[{"name":"Wireshark","slug":"Wireshark","permalink":"http://harmansecurity.cn/tags/Wireshark/"},{"name":"抓包分析","slug":"抓包分析","permalink":"http://harmansecurity.cn/tags/抓包分析/"}]},{"title":"解决端口被占用","date":"2017-02-10T12:45:13.000Z","path":"2017/02/10/解决端口被占用/","text":"1.开始—-&gt;运行—-&gt;cmd，调出命令窗口2.输入命令：netstat -ano，列出所有端口的情况。在列表中我们观察被占用的端口，比如是4000，首先找到它。 3.查看被占用端口对应的PID，输入命令：netstat -aon|findstr “4000”，回车，记下最后一位数字，即PID,这里是372 4.继续输入tasklist|findstr “372”，回车，查看是哪个进程或者程序占用了372端口 5.结束该进程：在任务管理器中选中该进程点击”结束进程“按钮，或者是在cmd的命令窗口中输入：taskkill /f /t /im nvvsvc.exe","tags":[{"name":"端口占用","slug":"端口占用","permalink":"http://harmansecurity.cn/tags/端口占用/"}]},{"title":"Http抓包与调试(Fiddler)","date":"2017-02-09T13:19:07.000Z","path":"2017/02/09/Http抓包与调试(Fiddler)/","text":"一、什么是Fiddler？ 1.Fiddler是位于客户端和服务器端的HTTP代理，也是目前最常用的http抓包工具之一。它能够记录客户端和服务器之间的所有HTTP请求，可以针对特定的HTTP请求，分析请求数据、设置断点、调试web应用、修改请求的数据，甚至可以修改服务器返回的数据，功能非常强大，是web调试的利器。既然是代理，也就是说：客户端的所有请求都要先经过Fiddler，然后转发到相应的服务器，反之，服务器端的所有响应，也都会先经过Fiddler然后发送到客户端，基于这个原因，Fiddler支持所有可以设置http代理为 127.0.0.1:8888 的浏览器和应用程序。使用了Fiddler之后，web客户端和服务器的请求如下所示: 2.Fiddler 作为系统代理，当启用Fiddler时，IE的PROXY设定会变成 127.0.0.1:8888，因此如果你的浏览器在开启fiddler之后没有设置相应的代理，则fiddler是无法捕获到HTTP请求的。如下是启动Fiddler之后，IE浏览器的代理设置： 3.以Firefox为例，默认情况下，firefox是没有启用代理的（如果你安装了proxy等代理工具或插件，是另外一种情况），在firefox中配置http代理的步骤如下：工具-&gt;选项-&gt;高级-&gt;网络-&gt;设置。并配置相应的代理如下就可以使用Fiddler抓取Firefox的HTTP请求了。 二、Fiddler使用界面简介Fiddler主界面的布局如下： 主界面中主要包括四个常用的块： Fiddler的菜单栏，上图绿色部分。包括捕获http请求，停止捕获请求，保存http请求，载入本地session、设置捕获规则等功能。 Fiddler的工具栏,上图红色部分。Replay：回放按钮; X：清空监控面板； Go：调试Debug； Stream：模式切换；（流模式与缓冲模式） Decode：解压请求； Keep session：保持会话； Any Process：过滤请求；（如只查看Chrome的请求） Find：查找； Save：保存会话； 保存截图； 计时器； Browser：快速启动浏览器； TextWizard：编码/解码；（非常常用） Tearoff：分离面板； MSDN Search：MSDN搜索； web Session面板，上图黄色区域，主要是Fiddler抓取到的每条http请求（每一条称为一个session）,主要包含了请求的url，协议，状态码，body等信息，详细的字段含义如下图所示： 详情和数据统计面板。针对每条http请求的具体统计（例如发送/接受字节数，发送/接收时间，还有粗略统计世界各地访问该服务器所花费的时间）和数据包分析。如inspector面板下，提供headers、textview、hexview,Raw等多种方式查看单条http请求的请求报文的信息：而composer面板下，则可以模拟向相应的服务器发送数据的过程（这就是灌水机器人的基本原理,也可以是部分http flood的一种方式）。也可以粘贴一次请求的raw http headers,达到模拟请求的目的： 三、Fiddler内置命令 为了更加方便的管理所有的session, Fiddler提供了一系列内置的函数用于筛选和操作这些session.输入命令的位置在websession管理面板的下方（通过快捷键alt+q可以focus到命令行）.Fiddler内置的命令有如下几种： 1. select命令。选择所有相应类型（指content-type）为指定类型的HTTP请求，如选择图片，使用命令select image.而select css则可以选择所有相应类型为css的请求，select html则选择所有响应为HTML的请求（怎么样，是不是跟SQL语句很像？）。如图是执行select image之后的结果： 2. allbut命令。allbut命令用于选择所有响应类型不是给定类型的HTTP请求。如allbut image用于选择所有相应类型不是图片的session(HTTP请求)，该命令还有一个别名keeponly.需要注意的是，keeponly和allbut命令是将不是该类型的session删除，留下的都是该类型的响应。因此，如果你执行allbut xxxx（不存在的类型），实际上类似与执行cls命令（删除所有的session, ctrl+x快捷键也是这个作用） 3. ?text命令选择所有 URL 匹配问号后的字符的全部 session 4. &gt;size 和 &lt;size命令选择响应大小大于某个大小（单位是b）或者小于某个大小的所有HTTP请求 5. =status命令选择响应状态等于给定状态的所有HTTP请求。例如，选择所有状态为200的HTTP请求：=200 6. @host命令选择包含指定 HOST 的全部 HTTP请求。例如：@csdn.net选择所有host包含csdn.net的请求 7. Bpafter， Bps, bpv, bpm, bpu这几个命令主要用于批量设置断点：Bpafter xxx: 中断 URL 包含指定字符的全部 session 响应Bps xxx: 中断 HTTP 响应状态为指定字符的全部 session 响应。Bpv xxx: 中断指定请求方式的全部 session 响应Bpm xxx: 中断指定请求方式的全部 session 响应。等同于bpv xxxBpu xxx:与bpafter类似。当这些命令没有加参数时，会清空所有设置了断点的HTTP请求。 四、Fiddler抓包分析 抓包是Fiddler的最基本的应用，在Fiddler的web session界面捕获到HTTP请求。各字段的详细说明已经解释过，这里不再说明。需要注意的是#号列中的图标，每种图标代表不同的相应类型，具体的类型包括： 另外，注意请求的host字段。可以看到有来自多个www.csdn.net的子域名的响应，说明在大型网站的架构中，大多需要多个子域名，这些子域名可能是单独用于缓存静态资源的，也可能是专门负责媒体资源的，或者是专门负责数据统计的（如pingback）。右键单击其中的一条请求。可以选择的操作有：save(保存请求的报文信息，可以是请求报文，可以是响应报文)。如果想要重新发送某些请求，可以选中这些请求，然后点击工具栏中的reply.就可以重新发送选中的这些请求。左键点击单条HTTP请求，可以在右侧的tab面板中看到如下信息：(1). Statistic。关于HTTP请求的性能和其他数据分析，使用Statistics页签，用户可以通过选择多个会话来得来这几个会话的总的信息统计，比如多个请求和传输的字节数。选择第一个请求和最后一个请求，可获得整个页面加载所消耗的总体时间。从条形图表中还可以分别出哪些请求耗时最多，从而对页面的访问进行访问速度优化。 (2). Inspectors。分为上下两个部分，上半部分是请求头部分，下半部分是响应头部分。对于每一部分，提供了多种不同格式查看每个请求和响应的内容。JPG 格式使用 ImageView 就可以看到图片，HTML/JS/CSS 使用 TextView可以看到响应的内容。Raw标签可以查看原始的符合HTTP标准的请求和响应头。Auth则可以查看授权Proxy-Authorization和Authorization的相关信息。Cookies标签可以看到请求的cookie和响应的set-cookie头信息。 Http Request HeaderCache 头域If-Modified-Since作用：把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端 就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中。例如：If-Modified-Since: Thu, 09 Feb 2012 09:07:57 GMTIf-None-Match作用: If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用 本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能例如: If-None-Match: “03f2b33c0bfcc1:0”Pragma作用：防止页面被缓存， 在HTTP/1.1版本中，它和Cache-Control:no-cache作用一模一样。Pargma只有一个用法，例如：Pragma: no-cache.注意: 在HTTP/1.0版本中，只实现了Pragema:no-cache, 没有实现Cache-Control。Cache-Control作用: 这个是非常重要的规则。 这个用来指定Response-Request遵循的缓存机制。各个指令含义如下 Cache-Control:Public 可以被任何缓存所缓存（） Cache-Control:Private 内容只缓存到私有缓存中 Cache-Control:no-cache 所有内容都不会被缓存 Client 头域 Accept: text/html代表浏览器可以接受服务器回发的类型为 text/html 也就是我们常说的html文档,如果服务器无法返回text/html类型的数据，服务器应该返回一个406错误(non acceptable)。 Accept: / 代表浏览器可以处理所有类型，(一般浏览器发给服务器都是发这个)。 Accept-Encoding：作用：浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。 Accept-Language作用： 浏览器申明自己接收的语言。 User-Agent作用：告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本.我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息User-Agent请求报头域允许客户端将它的操作系统、浏览 器和其它属性告诉服务器。 Accept-Charset作用：浏览器申明自己接收的字符集，这就是本文前面介绍的各种字符集和字符编码，如gb2312，utf-8（通常我们说Charset包括了相应的字符编码方案） Cookie/Login 头域Cookie:作用：最重要的header, 将cookie的值发送给HTTP 服务器 Entity头域Content-Length作用：发送给HTTP服务器数据的长度。 Content-Type: application/x-www-form-urlencoded Miscellaneous 头域Referer:作用：提供了Request的上下文信息的服务器，告诉服务器我是从哪个链接过来的，比如从我主页上链接到一个朋友那里，他的服务器就能够从HTTP Referer中统计出每天有多少用户点击我主页上的链接访问他的网站。 Transport 头域Connection 例如：Connection: keep-alive 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接 例如：Connection: close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。 Host（发送请求时，该报头域是必需的）作用: 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。例如: 我们在浏览器中输入：http://www.guet.edu.cn/index.html。浏览器发送的请求消息中，就会包含Host请求报头域，如下：Host：http://www.guet.edu.cn此处使用缺省端口号80，若指定了端口号，则变成：Host：指定端口号 (3). AutoResponder。Fiddler比较重要且比较强大的功能之一。可用于拦截某一请求，并重定向到本地的资源，或者使用Fiddler的内置响应。可用于调试服务器端代码而无需修改服务器端的代码和配置，因为拦截和重定向后，实际上访问的是本地的文件或者得到的是Fiddler的内置响应。当勾选EnableRules并设置相应的规则后（本例中的规则是将http://www.cnblogs.com/HYanqing/p/5294968.html的请求拦截到本地的文件）,如下图所示: 然后在浏览器中访问http://www.cnblogs.com/HYanqing/p/5294968.html，得到的结果实际为本地的网页。说明请求已经成功被拦截到本地.当然也可以使用Fiddler的内置响应。因此如果要调试服务器的某个脚本文件，可以将该脚本拦截到本地，在本地修改完脚本之后，再修改服务器端的内容，这可以保证，尽量在真实的环境下去调试，从而最大限度的减少bug发生的可能性。不仅是单个url，Fiddler支持多种url匹配的方式：I. 字符匹配如 example可以匹配 http://www.example.com和http://example.com.cnII. 完全匹配以EXACT开头表示完全匹配，如上边的例子EXACT:http://www.cnblogs.com/HYanqing/p/5294968.htmlIII. 正则表达式匹配以regex: 开头，使用正则表达式来匹配URL.如：regex:(?insx).*\\.(css|js|php)$ 表示匹配所有以css,js,php结尾的请求url(4). Composer。（模拟请求）老版本的fiddler中叫request-builder.顾名思义，可以构建相应的请求，有两种常用的方式构建请求:(1)Parsed 输入请求的url之后executed即可，也可以修改相应的头信息（如添加常用的accept, host, referrer, cookie，cache-control等头部）后execute.这个功能的常见应用是：“刷票”（不是火车票！！），如刷新页面的访问量。(2)Raw。使用HTTP头部信息构建http请求。与上类似。不多叙述(5). Filter。Fiddler另一个比较强大的功能。Fiddler提供了多维度的过滤规则，足以满足日常开发调试的需求。过滤规则有：a. host和zone过滤。可以过滤只显示intranet或则internet的HTTP请求。也可以选择特定域名的HTTP请求。b. client process:可以捕获指定进程的请求。这对于调试单个应用的请求很有帮助。五、Fiddler中设置断点修改Request Fiddler最强大的功能莫过于设置断点了，设置好断点后，你可以修改httpRequest的任何信息包括host,cookie或者表单中的数据。设置断点有两种方法：第一种：打开Fiddler 点击Rules-&gt; Automatic Breakpoint -&gt;Before Requests(这种方法会中断所有的会话)如何消除命令呢？ 点击Rules-&gt; Automatic Breakpoint -&gt;Disabled第二种: 在命令行中输入命令: bpu www.baidu.com (这种方法只会中断www.baidu.com)如何消除命令呢？ 在命令行中输入命令 bpu看个实例，模拟麦子学院的登录，在火狐中打开麦子学院的登录页面，输入错误的用户名和密码，用Fiddler中断会话，修改成正确的用户名密码。这样就能成功登录：1. 用火狐打开麦子学院的登录界面 http://www.maiziedu.com/2. 打开Fiddler, 在命令行中输入bpu http://www.maiziedu.com/3. 输入错误的用户名和密码，点击登录4. Fiddler 能中断这次会话，选择被中断的会话，点击Inspectors tab下的WebForms tab 修改用户名密码，然后点击Run to Completion 如下图所示:5. 结果是正确地登录了麦子学院六、Fiddler中设置断点修改Response当然Fiddler中也能修改Response：第一种：打开Fiddler 点击Rules-&gt; Automatic Breakpoint -&gt;After Response (这种方法会中断所有的会话)如何消除命令呢？ 点击Rules-&gt; Automatic Breakpoint -&gt;Disabled第二种: 在命令行中输入命令: bpuafter www.baidu.com (这种方法只会中断www.baidu.com)如何消除命令呢？ 在命令行中输入命令 bpuafter 七、Watcher(安全扫描工具，第三方扩展) Watcher是一个实时的，被动分析基于HTTP协议的Web应用程序的安全工具(Fiddler插件)。所谓被动分析就是指它不会对现有系统产生任何破坏。Watcher可以被安全的用于分布式网络，共享式网络和专用宿主网络。Watcher能够自动检查这些问题：cookie设置、SSL配置、信息泄露等。另外，Watcher是一个非常好的HTTP协议调试工具，不过，它的HTTP调试功能是以Fiddler插件方式工作的。总之，Watcher是一个很好的渗透测试工具，有助于渗透测试人员的渗透测试工作。 八、参考文献 http://www.cnblogs.com/HYanqing/p/5294968.html http://blog.csdn.net/ohmygirl/article/details/17846199 http://blog.csdn.net/ohmygirl/article/details/17849983 http://www.imooc.com/course/note/id/37?sort=last&amp;page=1 http://www.freebuf.com/sectool/6770.html","tags":[{"name":"Http抓包与调试","slug":"Http抓包与调试","permalink":"http://harmansecurity.cn/tags/Http抓包与调试/"},{"name":"Fiddler","slug":"Fiddler","permalink":"http://harmansecurity.cn/tags/Fiddler/"},{"name":"浏览器代理","slug":"浏览器代理","permalink":"http://harmansecurity.cn/tags/浏览器代理/"},{"name":"拦截请求或响应","slug":"拦截请求或响应","permalink":"http://harmansecurity.cn/tags/拦截请求或响应/"},{"name":"抓包和重放","slug":"抓包和重放","permalink":"http://harmansecurity.cn/tags/抓包和重放/"}]},{"title":"Http抓包与调试(Firefox插件)","date":"2017-01-19T08:22:55.000Z","path":"2017/01/19/Http抓包与调试(Firefox插件)/","text":"这边主要介绍火狐的几款插件工具分别是Firebug、TamperData、LiveHttpHeaders、Hackbar和ModifyHeaders，它们可以用来测试和发掘Web应用程序中的跨站漏洞。 1.Firebug(抓包与各种调试) Firebug是Firefox浏览器的一个扩展插件，可以动态修改html代码、探索DOM结构、监视网络请求和响应、调试和监测任何页面的CSS、HTML和JavaScript等等。 1)安装城成功后按F12启动Firebug 打开Firebug后，看到六个标签按钮分别是（控制台、HTML查看器、CSS查看器、脚本调试器、DOM查看器、网络状况监视器）。 2)控制台 控制台能够显示当前页面中的JavaScript错误以及警告，并提示出错的文件和行号，使用控制台可以测试一段代码或者函数的执行时间。启用控制台，在窗口的底部能看到命令行输入，以“&gt;”开头，在这里输入JavaScript代码后按Enter键即可执行。 3)动态修改HTML元素 Frebug可以显示脚本输出的最终源代码，而html查看器只能显示页面本身的源代码。单击查看页面元素按钮，当光标停留在某个元素上时，浏览器会高亮显示对应元素，可以对页面文本节点进行修改，其修改结果马上回反映到浏览器窗口。 4)查看网络状况 将Frebug的当前标签切换到“网络”，该标签用来监控网络流量。如果通过XMLHttpRequest对象向服务器端发出一个请求，Firebug会记录该请求的GET或者POST内容，以及回应的头信息和内容。Firebug也能将页面中的CSS、JavaScript以及网页中引用的图片载入所消耗的时间以矩状图显示出来，通过右键就可以复制文件地址、HTTP请求头的信息和响应头信息等等。以登录麦子学院网站为例，惊奇的发现它的账号和密码都是明文传输。:) 5)DOM查看器 DOM包含了大量的对象以及函数，事件，通过使用Firebug可以检查当前打开程序的各个部分。 2.Tamper Data(拦截修改) 当测试Web应用程序的安全性的时候，经常会需要对HTTP流量进行分析和动态的修改，这时就需要用到这款工具。安装成功后，在Firefox的工具栏打开，随后在浏览网页的时候发出的每一个Http请求及其对应的响应都会被Tamper Data记录下来。 1)Tamper Data界面主要是由三部分组成 第一部分：（上方）HTTP请求概要信息 第二部分：（左下方）显示出对应的HTTP请求的头部信息 第三部分：（右下方）显示出对应的HTTP响应 2)查看细节、源码信息以及网页打开时间 在主窗口的第一部分单击鼠标右键，此时可以查看细节、源代码信息，单击【GraphAll】按钮，会以图形的方式直观地显示每个页面元素及其打开它们所花的时间。 3)Http请求截取 在Tamper Data中选择StartTamper菜单项，便开启了对HTTP请求的截取，此时浏览器发出的每一个请求，TamperData都会截取。在开启该功能后单击网页上的任意超链接，便可以看到浏览器弹出一个对话框，然后单击【Tamper】按钮，会弹出一个“TamperPopup”窗口，这个窗口显示了HTTP请求的各种头信息，可以在此随意修改或者添加其他合法的HTTP请求头部字段或POST参数。 3.Live HTTP Headers(重放功能) Live HTTP Headers是一款用来分析HTTP流量的Firefox扩展插件，直接在火狐浏览器里面搜索即可安装。 窗口底部有一个“capture”复选框，选中后可以使LIVE HTTP Headers 停止向下滚动，以便对已经产生的通信流量进行分析 在主窗口选择其中一段请求，然后单击窗口底部的“Replay”按钮会弹出窗口，可对请求进行各种修改，修改后再次单击“replay”可重放请求。 4.Hackbar(编码解码/POST提交) HackBar是firefox浏览器上的一个插件,安装方法跟之前的几个插件一样。HackBar其实是一个小工具包，包含一些黑客常用的工具。比如SQL injection,XSS,加密等!功能很多可以下载下来去尝试一下。 load url是将地址栏中的网络复制到hackbar中 在sql注入中有一个联合查询，比如字段数是11要是手工的话我们打出union select 1,2,3,4,5,6,7,8,9,10,11这样感觉有点麻烦。通过hackbar的sql选项里面的unionselectstatement在其中输入字段数，hackbar会自动的帮助我们输入那一大串文字。 我们可以对url进行各种编码操作，我们可以在endoding选项下进行url、16进制、base64进行编码解码，可以在xss选项下进行html实体编码，在sql选项下进行空格编码。 在encryption选项中我们可以进行md5,sha1，sha256，rot13加密，单击里面的选项，在弹出的对话框中输入要加密的数据。 5.Modify Headers(修改头部) 这个插件的主要作用是对Firefox的HTTP request headers进行添加、修改和过滤等操作。当我们访问网站的时候，某些网站服务器会对访问网站的浏览器Header信息进行判断，然后决定用什么方式把网站内容呈现给浏览器。服务器也会根据浏览器的header中包含的其他信息（譬如浏览器所在的IP地址）判断是否要讲某一特定的信息呈现给浏览器。 选择Add，右边的HeaderName,HeaderValue和DescriptiveComment等字段都会变得可编辑。由于我们要模拟不同地域的IP对网站进行访问(伪造IP地址)，所以HeaderName字段中，我们填入X-Forwarded-For。Header value中，填入你要模拟的地域IP地址，然后在Descriptive comment中填上备注就好。 User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。修改User-Agent来模拟用iPhone访问网站。 伪造IP地址和修改了User Agent，看一下访问百度的请求头信息发生了什么变化。","tags":[{"name":"Http抓包与调试","slug":"Http抓包与调试","permalink":"http://harmansecurity.cn/tags/Http抓包与调试/"},{"name":"Firebug","slug":"Firebug","permalink":"http://harmansecurity.cn/tags/Firebug/"},{"name":"Tamper Data","slug":"Tamper-Data","permalink":"http://harmansecurity.cn/tags/Tamper-Data/"},{"name":"LiveHttpHeaders","slug":"LiveHttpHeaders","permalink":"http://harmansecurity.cn/tags/LiveHttpHeaders/"},{"name":"Hackbar","slug":"Hackbar","permalink":"http://harmansecurity.cn/tags/Hackbar/"},{"name":"Modify Headers","slug":"Modify-Headers","permalink":"http://harmansecurity.cn/tags/Modify-Headers/"}]},{"title":"PBC库的常用函数解释","date":"2017-01-18T10:59:57.000Z","path":"2017/01/18/PBC库的常用函数解释/","text":"PBC库使用G1、G2和GT分别表示双线性映射:e:G1xG2-&gt;GT中的G1、G2和GT，他们的阶都为r。Zr表示模r的整数环。配对运算输入两个元素，一个元素来自群G1，另一个元素来自群G2，输出结果是GT中的一个元素。G1和G2也可以是同一个群，即是一个对称配对，这种情况下它们的元素可以相互混淆使用。 1.配对的初始化方式1) 以标准的方式初始化配对12pairing_t pairing;//声明一个配对类型的变量pairingpairing_init_inp_str(pairing,stdin);//参数stdin表示配对的输入参数方式为标准输入 2) 指定类型的方式初始化配对1234a_param_input(pairing);//将配对变量pairing初始化为类型A的配对d_param_input(pairing);//将配对变量pairing初始化为类型D的配对f_param_input(pairing);//将配对变量pairing初始化为类型F的配对pairing_clear(pairing);//调用该函数释放pairing占用的资源 2.元素的初始化1234567void element_init(element_t e,field_ptr f);//将元素变量e初始化为代数结构f中的元素void element_init_G1(element_t e,pairing_t pairing);//将元素变量e初始化为群G1中的元素void element_init_G2(element_t e,pairing_t pairing);//将元素变量e初始化为群G2中的元素void element_init_GT(element_t e,pairing_t pairing);//将元素变量e初始化为群GT中的元素void element_init_Zr(element_t e,pairing_t pairing);//将元素变量e初始化为群Zr中的元素void element_init_same_as(element_t e,element_t e2);//将元素变量e初始化为元素变量e2所在的代数结构中的元素void element_clear(element_t e);//清楚元素变量e并释放其所占用的资源 3.运算函数1234567891011121314151617void element_add(element_t n,element_t a,element_t b);//输入a和b，输出n=a+bvoid element_sub(element_t n,element_t a,element_t b);//输入a和b，输出n=a-bvoid element_mul(element_t n,element_t a,element_t b);//输入a和b，输出n=axbvoid element_mul_si(element_t n,element_t a,signed long int z);//输入a和z，输出n=axz,z是一个长整型数据void element_mul_zn(element_t n,element_t a,element_t z);//输入a和z，输出n=axz,z是整数环中的一个元素void element_div(element_t n,element_t a,element_t b);//输入a和b，输出n=a/bvoid element_double(element_t n,element_t a);//输入a，输出n=a+avoid element_halve(element_t n,element_t a);//输入a，输出n=a/2void element_square(element_t n,element_t a);//输入a，输出n=a^2void element_neg(element_t n,element_t a);//输入a，输出n=-avoid element_invert(element_t n,element_t a);//输入a，输出a的逆元nvoid element_pow_mpz(element_t x,element_t a,mpz_t n);//输入a和n，输出x=a^nvoid element_pow_zn(element_t x,element_t a,element_t n);//输入a和n，输出x=a^n，n是整数环中的元素//输入a1,a2和n1,n2，输出x=a1^n1xa2^n2void element_pow2_mpz(element_t x,element_t a1,mpz_t n1,element_t a2,mpz_t n2);//输入a1,a2和n1,n2，输出x=a1^n1xa2^n2,n1,n2是整数环中的元素void element_pow2_zn(element_t x,element_t a1,element_t n1,element_t a2,element_t n2); 4.其它函数1234567int element_length_in_bytes(element_t e);//获得元素变量e的字节数void element_random(element_t e);//函数从这个代数结构中均匀随机选择一个元素并赋值给eint element_cmp(element_t a,element_t b);//若变量a和b相等，则函数返回0否则返回1void element_to_mpz(mpz_t z,element_t e);//将元素e转换为一个GMP整数并存储在mpz_t类型的变量z中//PBC库中没有提供计算Hash值的函数，这里只是以获得的Hash值作为输入，从中截取一部分表示域中的某个元素void element_from_hash(element_t e,void * data,int len);int element_printf(const char * format,...);//格式化打印元素值 以上列举了PBC库中的一些常用函数及其代表的意思，如有特殊需求可查阅PBC官方文档。","tags":[{"name":"PBC","slug":"PBC","permalink":"http://harmansecurity.cn/tags/PBC/"},{"name":"密码学","slug":"密码学","permalink":"http://harmansecurity.cn/tags/密码学/"},{"name":"双线性配对","slug":"双线性配对","permalink":"http://harmansecurity.cn/tags/双线性配对/"}]},{"title":"VC6.0插件安装","date":"2017-01-17T06:49:04.000Z","path":"2017/01/17/VC6.0插件安装/","text":"因为PBC源码库的一些函数不是很全，导致用VS写了几个程序只好放弃，而支持VC6.0的PBC库比较全，绕了一圈所以只好转战VC++6.0。VC++6.0是一款很老的工具，不是很人性化，对于我这个深度完美主义者肯定是不能接受的，想方设法使它更适合开发，所以安装了一些插件，使开发效率更高。 我主要安装的插件是:1.Visual studio Boosteer;(源码窗口管理) 下载地址:http://pan.baidu.com/s/1pJAZApP. 功能:方便查看源码，一页里面可以打开多个C文件。 2.Visual assist Options;(强烈推荐) 下载地址:http://pan.baidu.com/s/1dDh7Mtb. 功能:自动识别各种关键字，系统函数，成员变量，自动给出输入提示，自动更正大小写错误，自动标示错误等等。 3.为了解决VC++6.0不能添加和打开文件的功能安装了FileTool。 下载地址:http://download.csdn.net/detail/ttfy1234/9696351. 功能:VC6.0在添加和打开文件时经常会崩掉，这个插件就是为了解决这个问题。 4.VC6LineNumberAddin; 下载地址:http://pan.baidu.com/s/1dD8CfGd 功能:VC6.0不自带行号，不方便阅读查找，这个是行号插件。 5.Comment Wizard; 下载地址:http://www.cppblog.com/fwxjj/. 功能:Visual C++插件，提供了VC源代码注解标准化与自动化功能。在它的帮助下，您可快速创建标头文件信息注解，文件中模块注解， C++处理方式，以及Ｃ语言功能与历史校正功能注解等等。 6.WndTabs+3.20 实现窗口tab效果。 下载地址:http://www.wndtabs.com/. 功能:WndTabs主要是在编辑窗口中显示了所有已经打开的文件，在VC中能够更方便的操作这些文件，比如修改文件属性，copy文件路径、文件名等,与第一个VS Booster的功能相近。 参考的资料: http://blog.csdn.net/cooljun618/article/details/6866798 http://bbs.csdn.net/topics/390776572 一个人性化的环境搭好了,下面就是导入项目，官网给的支持VC的PBC源码直接打开有点问题，这边我直接把调通好的源码放在GitHub上面，有需要的人可以去下载，地址是:https://github.com/harmansecurity/PBC-0.4.7-vc6.0.","tags":[{"name":"PBC","slug":"PBC","permalink":"http://harmansecurity.cn/tags/PBC/"},{"name":"密码学","slug":"密码学","permalink":"http://harmansecurity.cn/tags/密码学/"},{"name":"VC6.0","slug":"VC6-0","permalink":"http://harmansecurity.cn/tags/VC6-0/"}]},{"title":"这半年为什么止步不前？","date":"2017-01-15T14:42:06.000Z","path":"2017/01/15/2016总结/","text":"时间过得很快，读研已半年，这半年来我一直都没好好想过这个问题，这半年我到底做了什么？我试着给自己答案——积累、沉淀，但是却有种莫名的心虚。 回顾2016年下半年的历程。七月份，在中科院信工所的物联网安全研发中心实习。去之前，本以为是朝九晚五的上班场景，心里还是忐忑的，结果与我想的截然相反，这里都是研究生，学习氛围很浓厚。那段日子应该就是我研究生阶段的预备期，或许是因为仰慕那些学姐学长基础扎实，编码能力强，为了缩短差距，我坚持每天早晨八点打卡，每晚坚持跑步回去到宿舍已基本十二点，从未给过自己一天的休息时间。当时我的任务是“如何检测内存异常访问”，因为项目的需求，需要了解Linux内核，期间泛读了《Python核心编程》、《鸟哥的Linux私房菜》、《Linux内核完全注释》(强烈推荐)，这三本书可以当做字典来用，没有必要全部读完。也重温了《计算机操作系统》、《计算机组成原理》、《深入理解计算机系统》。在这次实习中，最大的感受就是理论知识的缺乏，大学里面的基础课程在日后还是有很大作用的，于是决定利用接下来的三年时间多积累沉淀，多看些书。 入学的那段时间还是比较空闲的，我的计划是先看两本自己研究领域的书籍，虽然导师这边是偏理论，但其实自己对应用还是很热衷的，所以决定再看两本WEB安全的入门书籍。所看的密码学书：《图解密码技术》、《深入浅出密码学》、《基于配对的密码学》；WEB安全相关的书：《WEB安全前端黑客技术解密》、《XSS跨站脚本》(未读完)、《SQL注入攻击与防御》(未读)，此外对余弦发布的技能表做了相应的对照学习。 写到这里，也差不多能知道问题出在哪了：在理论上没有多大的进展，仍处于连门都没入的阶段，程序写的不多，没有学习太多的新技术，这就是莫名心虚的原因。最初的想法是先偏理论，不管是否选择继续走学术这条路都要发论文，研一暑假再决定最终是否工作。可能是心急了，要是很多东西一下子就能见成果，那就没多大意义了。或许临近期末的原因，躁动不安，扰乱了情绪，胡思乱想。 —2016.1.5 by LiangHui 最近也在思考，当初为什么会有读博的想法？“因为之前做的一些东西，只知道如何去实现而不知道机制和原理，想在博士期间好好深入研究。”通过这半年的了解,很多其实并不是当初所想的那样，博士是在一个很小的方向上进行研究并能作出自己的突破。如果读现在的方向的博士达不到当初想要的效果，所以必须明确到底想要什么！接下来的一年将会把重心放在web安全技术上，利用空余的时间多读点书，多去实践。早做决定，早做打算。 —2016.1.15","tags":[{"name":"总结","slug":"总结","permalink":"http://harmansecurity.cn/tags/总结/"}]}]